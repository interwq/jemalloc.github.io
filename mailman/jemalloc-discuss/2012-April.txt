From mh+jemalloc at glandium.org  Mon Apr  2 00:03:27 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 2 Apr 2012 09:03:27 +0200
Subject: [PATCH 1/2] Move zone registration to zone.c
In-Reply-To: <20120330180626.GB8273@glandium.org>
References: <1332850813-10182-1-git-send-email-mh+jemalloc@glandium.org>
	<20120327124614.GA1833@glandium.org>
	<19FA7E67-2D0D-45E7-9270-FBC687984FFC@canonware.com>
	<20120330180352.GA8273@glandium.org>
	<20120330180626.GB8273@glandium.org>
Message-ID: <20120402070327.GA3549@glandium.org>

On Fri, Mar 30, 2012 at 08:06:26PM +0200, Mike Hommey wrote:
> On Fri, Mar 30, 2012 at 08:03:52PM +0200, Mike Hommey wrote:
> > On Fri, Mar 30, 2012 at 10:54:36AM -0700, Jason Evans wrote:
> > > On Mar 27, 2012, at 5:46 AM, Mike Hommey wrote:
> > > > On Tue, Mar 27, 2012 at 02:20:12PM +0200, Mike Hommey wrote:
> > > >> @@ -743,8 +723,8 @@ void
> > > >> jemalloc_darwin_init(void)
> > > >> {
> > > >> 
> > > >> -	if (malloc_init_hard())
> > > >> -		abort();
> > > >> +	if (!malloc_init_hard())
> > > >> +		register_zone();
> > > >> }
> > > >> #endif
> > > > 
> > > > Please note that I first attempted to move this function too, and do
> > > > lazy initialization of jemalloc, but that ends up in a dead lock because
> > > > pthread_atfork calls malloc.
> > > 
> > > Now that pthread_atfork() isn't being called on Darwin, does deadlock
> > > still occur due to some other memory allocation during initialization?
> > 
> > I haven't experienced deadlocks during initialization, even when
> > pthread_atfork was called.
> 
> D'oh, I did. End of week confusion. Mmm I'll have to check. I guess it
> could work, now.

And it does. Patch incoming.

Mike


From mh+jemalloc at glandium.org  Mon Apr  2 00:04:54 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon,  2 Apr 2012 09:04:54 +0200
Subject: [PATCH] Move last bit of zone initialization in zone.c,
	and lazy-initialize
In-Reply-To: <20120402070327.GA3549@glandium.org>
References: <20120402070327.GA3549@glandium.org>
Message-ID: <1333350294-4135-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 include/jemalloc/internal/jemalloc_internal.h.in |   12 ------------
 include/jemalloc/internal/zone.h                 |   22 ----------------------
 src/jemalloc.c                                   |   11 -----------
 src/zone.c                                       |    1 +
 4 files changed, 1 insertion(+), 45 deletions(-)
 delete mode 100644 include/jemalloc/internal/zone.h

diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index b7b8df8..f6924a4 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -304,9 +304,6 @@ static const bool config_ivsalloc =
 #include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
-#ifdef JEMALLOC_ZONE
-#include "jemalloc/internal/zone.h"
-#endif
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_TYPES
@@ -332,9 +329,6 @@ static const bool config_ivsalloc =
 #include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
-#ifdef JEMALLOC_ZONE
-#include "jemalloc/internal/zone.h"
-#endif
 #include "jemalloc/internal/prof.h"
 
 typedef struct {
@@ -402,9 +396,6 @@ void	jemalloc_postfork_child(void);
 #include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
-#ifdef JEMALLOC_ZONE
-#include "jemalloc/internal/zone.h"
-#endif
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_EXTERNS
@@ -567,9 +558,6 @@ choose_arena(void)
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/hash.h"
-#ifdef JEMALLOC_ZONE
-#include "jemalloc/internal/zone.h"
-#endif
 
 #ifndef JEMALLOC_ENABLE_INLINE
 void	*imalloc(size_t size);
diff --git a/include/jemalloc/internal/zone.h b/include/jemalloc/internal/zone.h
deleted file mode 100644
index 9eb4252..0000000
--- a/include/jemalloc/internal/zone.h
+++ /dev/null
@@ -1,22 +0,0 @@
-#ifndef JEMALLOC_ZONE
-#  error "This source file is for zones on Darwin (OS X)."
-#endif
-/******************************************************************************/
-#ifdef JEMALLOC_H_TYPES
-
-#endif /* JEMALLOC_H_TYPES */
-/******************************************************************************/
-#ifdef JEMALLOC_H_STRUCTS
-
-#endif /* JEMALLOC_H_STRUCTS */
-/******************************************************************************/
-#ifdef JEMALLOC_H_EXTERNS
-
-void register_zone(void);
-
-#endif /* JEMALLOC_H_EXTERNS */
-/******************************************************************************/
-#ifdef JEMALLOC_H_INLINES
-
-#endif /* JEMALLOC_H_INLINES */
-/******************************************************************************/
diff --git a/src/jemalloc.c b/src/jemalloc.c
index c0fe6c9..23541ae 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -717,17 +717,6 @@ malloc_init_hard(void)
 	return (false);
 }
 
-#ifdef JEMALLOC_ZONE
-JEMALLOC_ATTR(constructor)
-void
-jemalloc_darwin_init(void)
-{
-
-	if (malloc_init_hard() == false)
-		register_zone();
-}
-#endif
-
 /*
  * End initialization functions.
  */
diff --git a/src/zone.c b/src/zone.c
index 9fc87bb..6c1e415 100644
--- a/src/zone.c
+++ b/src/zone.c
@@ -166,6 +166,7 @@ zone_force_unlock(malloc_zone_t *zone)
 		jemalloc_postfork_parent();
 }
 
+JEMALLOC_ATTR(constructor)
 void
 register_zone(void)
 {
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Mon Apr  2 02:37:32 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon,  2 Apr 2012 11:37:32 +0200
Subject: [PATCH] Avoid NULL check in je_free
Message-ID: <1333359452-13980-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

The original patch from Igor Bukanov <igor at mir2.org>, in
https://bugzilla.mozilla.org/show_bug.cgi?id=571332, was also
modifying idalloc and arena_dalloc to avoid two CHUNK_ADDR2BASE
invocation, but since both functions are inlined, I doubt this
actually makes a difference.
---
 include/jemalloc/internal/jemalloc_internal.h.in |   10 +++-------
 src/jemalloc.c                                   |   22 ++++++++++------------
 2 files changed, 13 insertions(+), 19 deletions(-)

diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index f6924a4..b997031 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -632,11 +632,9 @@ ipalloc(size_t usize, size_t alignment, bool zero)
 JEMALLOC_INLINE size_t
 isalloc(const void *ptr)
 {
-	size_t ret;
+	size_t ret = 0;
 	arena_chunk_t *chunk;
 
-	assert(ptr != NULL);
-
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 	if (chunk != ptr) {
 		/* Region. */
@@ -644,7 +642,7 @@ isalloc(const void *ptr)
 			ret = arena_salloc_demote(ptr);
 		else
 			ret = arena_salloc(ptr);
-	} else
+	} else if (ptr != NULL)
 		ret = huge_salloc(ptr);
 
 	return (ret);
@@ -666,12 +664,10 @@ idalloc(void *ptr)
 {
 	arena_chunk_t *chunk;
 
-	assert(ptr != NULL);
-
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 	if (chunk != ptr)
 		arena_dalloc(chunk->arena, chunk, ptr);
-	else
+	else if (ptr != NULL)
 		huge_dalloc(ptr, true);
 }
 
diff --git a/src/jemalloc.c b/src/jemalloc.c
index 23541ae..e883085 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -1101,21 +1101,19 @@ void
 je_free(void *ptr)
 {
 
-	if (ptr != NULL) {
-		size_t usize;
+	size_t usize;
 
-		assert(malloc_initialized || IS_INITIALIZER);
+	assert(malloc_initialized || IS_INITIALIZER);
 
-		if (config_prof && opt_prof) {
-			usize = isalloc(ptr);
-			prof_free(ptr, usize);
-		} else if (config_stats) {
-			usize = isalloc(ptr);
-		}
-		if (config_stats)
-			thread_allocated_tsd_get()->deallocated += usize;
-		idalloc(ptr);
+	if (config_prof && opt_prof) {
+		usize = isalloc(ptr);
+		prof_free(ptr, usize);
+	} else if (config_stats) {
+		usize = isalloc(ptr);
 	}
+	if (config_stats)
+		thread_allocated_tsd_get()->deallocated += usize;
+	idalloc(ptr);
 }
 
 /*
-- 
1.7.9.5



From jasone at canonware.com  Mon Apr  2 13:59:18 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 2 Apr 2012 13:59:18 -0700
Subject: Crash in arenas_cleanup on linux x86-64
In-Reply-To: <20120331071232.GA26585@glandium.org>
References: <20120328194233.GA8471@glandium.org>
	<A7E96D1E-E020-4976-90E7-28E0BBE59E7C@canonware.com>
	<077A5BB9-C341-47EC-B012-21B2D3E66F1C@canonware.com>
	<20120329153450.GA32702@glandium.org>
	<7666DB67-6467-4A42-8D6B-37FA4E33B462@canonware.com>
	<20120331071232.GA26585@glandium.org>
Message-ID: <90B572E3-DCBA-4158-A705-82889259A09A@canonware.com>

On Mar 31, 2012, at 12:12 AM, Mike Hommey wrote:
> Before I forget, I'll just mention that malloc_printf fails when
> building with --enable-debug, and using %p for a NULL pointer, because
> its implementation prints "0x0", but vsnprintf printfs "(nil)", so the
> asserts to compare vsnprintf output fail.

The "(nil)" output is a glibc-ism, so matching output on all platforms would require some conditional logic.  I just ripped out the validation code to keep the mess from getting even bigger.

Thanks,
Jason

From jasone at canonware.com  Mon Apr  2 14:18:22 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 2 Apr 2012 14:18:22 -0700
Subject: [PATCH] Move last bit of zone initialization in zone.c,
	and lazy-initialize
In-Reply-To: <1333350294-4135-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120402070327.GA3549@glandium.org>
	<1333350294-4135-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <887C7DBB-1BE5-475A-8115-AE1427ED0DEC@canonware.com>

On Apr 2, 2012, at 12:04 AM, Mike Hommey wrote:
> include/jemalloc/internal/jemalloc_internal.h.in |   12 ------------
> include/jemalloc/internal/zone.h                 |   22 ----------------------
> src/jemalloc.c                                   |   11 -----------
> src/zone.c                                       |    1 +
> 4 files changed, 1 insertion(+), 45 deletions(-)
> delete mode 100644 include/jemalloc/internal/zone.h

Applied; thanks.

Jason

From jasone at canonware.com  Mon Apr  2 15:00:48 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 2 Apr 2012 15:00:48 -0700
Subject: [PATCH] Avoid NULL check in je_free
In-Reply-To: <1333359452-13980-1-git-send-email-mh+jemalloc@glandium.org>
References: <1333359452-13980-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <AAF1C29F-168A-4E16-BB66-6141355A4D8F@canonware.com>


On Apr 2, 2012, at 2:37 AM, Mike Hommey wrote:

> From: Mike Hommey <mh at glandium.org>
> 
> The original patch from Igor Bukanov <igor at mir2.org>, in
> https://bugzilla.mozilla.org/show_bug.cgi?id=571332, was also
> modifying idalloc and arena_dalloc to avoid two CHUNK_ADDR2BASE
> invocation, but since both functions are inlined, I doubt this
> actually makes a difference.
> ---
> include/jemalloc/internal/jemalloc_internal.h.in |   10 +++-------
> src/jemalloc.c                                   |   22 ++++++++++------------
> 2 files changed, 13 insertions(+), 19 deletions(-)

Applied, with some tweaks and additional tests.

http://www.canonware.com/cgi-bin/gitweb.cgi?p=jemalloc.git;a=commitdiff;h=96d4120ac08db3f2d566e8e5c3bc134a24aa0afc

Unfortunately, I just realized that it introduces a bug due to overly strict assertions, but I'll get that fixed in a moment.

Thanks,
Jason



From jasone at canonware.com  Mon Apr  2 15:26:27 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 2 Apr 2012 15:26:27 -0700
Subject: [PATCH] Avoid NULL check in je_free
In-Reply-To: <AAF1C29F-168A-4E16-BB66-6141355A4D8F@canonware.com>
References: <1333359452-13980-1-git-send-email-mh+jemalloc@glandium.org>
	<AAF1C29F-168A-4E16-BB66-6141355A4D8F@canonware.com>
Message-ID: <784CB0E4-88C3-4480-8EE7-275D69CACBAB@canonware.com>

On Apr 2, 2012, at 3:00 PM, Jason Evans wrote:
> On Apr 2, 2012, at 2:37 AM, Mike Hommey wrote:
>> From: Mike Hommey <mh at glandium.org>
>> 
>> The original patch from Igor Bukanov <igor at mir2.org>, in
>> https://bugzilla.mozilla.org/show_bug.cgi?id=571332, was also
>> modifying idalloc and arena_dalloc to avoid two CHUNK_ADDR2BASE
>> invocation, but since both functions are inlined, I doubt this
>> actually makes a difference.
>> ---
>> include/jemalloc/internal/jemalloc_internal.h.in |   10 +++-------
>> src/jemalloc.c                                   |   22 ++++++++++------------
>> 2 files changed, 13 insertions(+), 19 deletions(-)
> 
> Applied, with some tweaks and additional tests.
> 
> http://www.canonware.com/cgi-bin/gitweb.cgi?p=jemalloc.git;a=commitdiff;h=96d4120ac08db3f2d566e8e5c3bc134a24aa0afc
> 
> Unfortunately, I just realized that it introduces a bug due to overly strict assertions, but I'll get that fixed in a moment.

Actually, the patch is untenable because the thread_allocated_tsd_get() call in free() isn't safe until after initialization has occurred, and there's no cheaper way to assure initialized state than to check whether ptr is NULL.  Oh well.

Jason

From mh+jemalloc at glandium.org  Tue Apr  3 09:21:21 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 3 Apr 2012 18:21:21 +0200
Subject: Jemalloc stats
In-Reply-To: <7272EAB5-55EC-424F-8E3B-597B459856F2@canonware.com>
References: <20120322180302.GA1229@glandium.org>
	<7272EAB5-55EC-424F-8E3B-597B459856F2@canonware.com>
Message-ID: <20120403162121.GA16074@glandium.org>

On Thu, Mar 22, 2012 at 11:22:03AM -0700, Jason Evans wrote:
> On Mar 22, 2012, at 11:03 AM, Mike Hommey wrote:
> > In Firefox, we're tracking some of the stats provided by our fork of
> > jemalloc. One of them is: - HeapCommitted - Memory mapped by the
> > heap allocator that is committed, i.e. in physical memory or paged
> > to disk.  When heap-committed is larger than heap-allocated, the
> > difference between the two values is likely due to external
> > fragmentation; that is, the allocator allocated a large block of
> > memory and is unable to decommit it because a small part of that
> > block is currently in use.
> > 
> > It would seem like this could match stats.active, but i'm not
> > entirely sure it is the case. In particular, we don't count madvised
> > pages in that metric, but it would seem stats.active does, although
> > I haven't dug deep enough yet.
> 
> stats.active tracks all pages with active application allocations in
> them.  It does not include dirty unused pages for which madvise() has
> not yet been called, nor does it include pages that are entirely
> devoted to allocator metadata.

So essentially, what we are currently tracking as committed, which
doesn't include metadata, would be
stats.active + stats.arenas.<i>.pdirty for each arena

I'm starting to think it would be convenient to have special variables
that return the sum of the corresponding variables for all arenas.
Something like stats.arenas.pdirty that would be the sum of all
stats.arenas.<i>.pdirty.

Another thing we do in that committed number is that we only count pages
for huge allocations instead of complete chunks. If you allocate
chunk_size + a few pages, stats.active will count 2 * chunk_size, while
what we are after is chunk_size + a few pages. As I'm considering
pushing this upstream, I would like to know whether you'd rather this be
done in stats.active, or a separate variable.

Mike


From jasone at canonware.com  Wed Apr  4 10:31:41 2012
From: jasone at canonware.com (Jason Evans)
Date: Wed, 4 Apr 2012 10:31:41 -0700
Subject: Jemalloc stats
In-Reply-To: <20120403162121.GA16074@glandium.org>
References: <20120322180302.GA1229@glandium.org>
	<7272EAB5-55EC-424F-8E3B-597B459856F2@canonware.com>
	<20120403162121.GA16074@glandium.org>
Message-ID: <2BE441CC-E75B-4FB2-B05A-53B914153E51@canonware.com>

On Apr 3, 2012, at 9:21 AM, Mike Hommey wrote:
> On Thu, Mar 22, 2012 at 11:22:03AM -0700, Jason Evans wrote:
>> On Mar 22, 2012, at 11:03 AM, Mike Hommey wrote:
>>> In Firefox, we're tracking some of the stats provided by our fork of
>>> jemalloc. One of them is: - HeapCommitted - Memory mapped by the
>>> heap allocator that is committed, i.e. in physical memory or paged
>>> to disk.  When heap-committed is larger than heap-allocated, the
>>> difference between the two values is likely due to external
>>> fragmentation; that is, the allocator allocated a large block of
>>> memory and is unable to decommit it because a small part of that
>>> block is currently in use.
>>> 
>>> It would seem like this could match stats.active, but i'm not
>>> entirely sure it is the case. In particular, we don't count madvised
>>> pages in that metric, but it would seem stats.active does, although
>>> I haven't dug deep enough yet.
>> 
>> stats.active tracks all pages with active application allocations in
>> them.  It does not include dirty unused pages for which madvise() has
>> not yet been called, nor does it include pages that are entirely
>> devoted to allocator metadata.
> 
> So essentially, what we are currently tracking as committed, which
> doesn't include metadata, would be
> stats.active + stats.arenas.<i>.pdirty for each arena
> 
> I'm starting to think it would be convenient to have special variables
> that return the sum of the corresponding variables for all arenas.
> Something like stats.arenas.pdirty that would be the sum of all
> stats.arenas.<i>.pdirty.

This already exists.  You can pass narenas as the value for <i>, and you get summed statistics.

> Another thing we do in that committed number is that we only count pages
> for huge allocations instead of complete chunks. If you allocate
> chunk_size + a few pages, stats.active will count 2 * chunk_size, while
> what we are after is chunk_size + a few pages. As I'm considering
> pushing this upstream, I would like to know whether you'd rather this be
> done in stats.active, or a separate variable.

jemalloc tracks usable size rather than request size for all allocations, whether small, large, or huge, and it supports using the full size reported by malloc_usable_size() (not to mention the "real size" reported by the *allocm() API).  Modifying huge allocations to no longer be a multiple of the chunk size would have some unfortunate chunk management side effects.  Is this causing special pain in the context of Windows?

Thanks,
Jason

From justin.lebar at gmail.com  Wed Apr  4 10:36:40 2012
From: justin.lebar at gmail.com (Justin Lebar)
Date: Wed, 4 Apr 2012 13:36:40 -0400
Subject: Jemalloc stats
In-Reply-To: <2BE441CC-E75B-4FB2-B05A-53B914153E51@canonware.com>
References: <20120322180302.GA1229@glandium.org>
	<7272EAB5-55EC-424F-8E3B-597B459856F2@canonware.com>
	<20120403162121.GA16074@glandium.org>
	<2BE441CC-E75B-4FB2-B05A-53B914153E51@canonware.com>
Message-ID: <CAFWcpZ7FnvL6=45ZsjdyKBQ8LJY=SA21MzYYxRCpGYWqkCmajA@mail.gmail.com>

> jemalloc tracks usable size rather than request size for all allocations, whether small, large, or huge, and it supports using the full size reported by malloc_usable_size() (not to mention the "real size" reported by the *allocm() API).

Yeah, I changed this in our port.  :)  The usable size of a huge
allocation is rounded up to the next page, so rather than "usable
size", it's "size you can use without committing any additional
memory".

> ?Modifying huge allocations to no longer be a multiple of the chunk size would have some
> unfortunate chunk management side effects. ?Is this causing special pain in the context of Windows?

We still allocate the chunk rounded up to the next MB, but we report
its usable size rounded up to the next page.  I think I added a new
field to the huge rbtree node to store this.

We did this because our memory reporters (about:memory) use
malloc_usable_size to determine how much memory an allocation uses,
and it's important that we be able to distinguish between committed
memory and uncommitted memory.


From mh+jemalloc at glandium.org  Thu Apr  5 02:45:25 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 5 Apr 2012 11:45:25 +0200
Subject: [PATCH 3/3] Improve zone support for OSX
In-Reply-To: <CAFWcpZ52eDJfNsLst1Zw9U8L06jeum_seTzdCoGqUm2A9apyiQ@mail.gmail.com>
References: <1332262898-31839-1-git-send-email-mh+jemalloc@glandium.org>
	<CAFWcpZ656Z=VaTpKp2NLd=VYdxi1yEp=48WA+LGkwWtxd3AReQ@mail.gmail.com>
	<20120320171048.GA32129@glandium.org>
	<CAFWcpZ52eDJfNsLst1Zw9U8L06jeum_seTzdCoGqUm2A9apyiQ@mail.gmail.com>
Message-ID: <20120405094525.GA23644@glandium.org>

On Tue, Mar 20, 2012 at 01:18:13PM -0400, Justin Lebar wrote:
> On Tue, Mar 20, 2012 at 1:10 PM, Mike Hommey <mh+jemalloc at glandium.org> wrote:
> > On Tue, Mar 20, 2012 at 01:04:54PM -0400, Justin Lebar wrote:
> >> btw, I'm skeptical of the value of supporting OSX 10.5, because 10.5
> >> occasionally passes invalid pointers to ozone_size [1].
> >>
> >> [1] https://bugzilla.mozilla.org/show_bug.cgi?id=694335
> >
> > For one, not all jemalloc users are going to have the problem, which is
> > limited to some APIs.
> 
> True, but we of course don't know the full set of circumstances under
> which OSX will pass an invalid pointer.
> 
> > Also, AIUI, the current jemalloc code does the right thing for the
> > ozone_size, which is not the case in the old jemalloc fork we use in
> > Firefox, so depending on what is done with the result of ozone_size,
> > it might be okay.
> 
> What's the difference in behavior?
> 
> > BTW, I guess you wanted to point to
> > https://bugzilla.mozilla.org/show_bug.cgi?id=702250#c30
> 
> Yes, thanks.  And my analysis there is that 10.5 tries to free the
> internal pointer.  I'd be impressed if jemalloc handled this
> correctly!  (And even more impressed if it worked in general, for
> non-huge allocations too.  :)

>From my trivial testing, it actually works for allocations > (1 << 15).

That is:
char *ptr = malloc((1 << 15) + 1); free(ptr + 32);
does free the pointer, while
char *ptr = malloc(1 << 15); free(ptr + 32);
doesn't.

Neither crash (which is better than the crash we get with our fork :) )

Jason, how actually safe is jemalloc now, when trying to free a pointer
inside an allocation it gave out?

Mike


From mh+jemalloc at glandium.org  Thu Apr  5 09:02:22 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 5 Apr 2012 18:02:22 +0200
Subject: JEMALLOC_THREADED_INIT
Message-ID: <20120405160222.GA1034@glandium.org>

Hi,

I see that 41b6afb (Port to FreeBSD) added JEMALLOC_THREADED_INIT, but
nothing AC_DEFINEs it. Is that expected? (I bumped into this because I
was looking at pthread functions use)

Mike


From jasone at canonware.com  Thu Apr  5 10:45:30 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 5 Apr 2012 10:45:30 -0700
Subject: JEMALLOC_THREADED_INIT
In-Reply-To: <20120405160222.GA1034@glandium.org>
References: <20120405160222.GA1034@glandium.org>
Message-ID: <037851CB-C0E5-4DB1-8030-1CA90C952B9D@canonware.com>

On Apr 5, 2012, at 9:02 AM, Mike Hommey wrote:
> I see that 41b6afb (Port to FreeBSD) added JEMALLOC_THREADED_INIT, but
> nothing AC_DEFINEs it. Is that expected? (I bumped into this because I
> was looking at pthread functions use)

Whoops, that's supposed to be defined on Linux, but as a side effect of that mistake, I also broke the code without noticing.  I'll get it sorted out today.

Thanks,
Jason

From jasone at canonware.com  Thu Apr  5 10:52:07 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 5 Apr 2012 10:52:07 -0700
Subject: [PATCH 3/3] Improve zone support for OSX
In-Reply-To: <20120405094525.GA23644@glandium.org>
References: <1332262898-31839-1-git-send-email-mh+jemalloc@glandium.org>
	<CAFWcpZ656Z=VaTpKp2NLd=VYdxi1yEp=48WA+LGkwWtxd3AReQ@mail.gmail.com>
	<20120320171048.GA32129@glandium.org>
	<CAFWcpZ52eDJfNsLst1Zw9U8L06jeum_seTzdCoGqUm2A9apyiQ@mail.gmail.com>
	<20120405094525.GA23644@glandium.org>
Message-ID: <446F887B-0833-4347-8D80-3190EE501E3F@canonware.com>

On Apr 5, 2012, at 2:45 AM, Mike Hommey wrote:
> On Tue, Mar 20, 2012 at 01:18:13PM -0400, Justin Lebar wrote:
>> On Tue, Mar 20, 2012 at 1:10 PM, Mike Hommey <mh+jemalloc at glandium.org> wrote:
>>> On Tue, Mar 20, 2012 at 01:04:54PM -0400, Justin Lebar wrote:
>>>> btw, I'm skeptical of the value of supporting OSX 10.5, because 10.5
>>>> occasionally passes invalid pointers to ozone_size [1].
>>>> 
>>>> [1] https://bugzilla.mozilla.org/show_bug.cgi?id=694335
>>> 
>>> For one, not all jemalloc users are going to have the problem, which is
>>> limited to some APIs.
>> 
>> True, but we of course don't know the full set of circumstances under
>> which OSX will pass an invalid pointer.
>> 
>>> Also, AIUI, the current jemalloc code does the right thing for the
>>> ozone_size, which is not the case in the old jemalloc fork we use in
>>> Firefox, so depending on what is done with the result of ozone_size,
>>> it might be okay.
>> 
>> What's the difference in behavior?
>> 
>>> BTW, I guess you wanted to point to
>>> https://bugzilla.mozilla.org/show_bug.cgi?id=702250#c30
>> 
>> Yes, thanks.  And my analysis there is that 10.5 tries to free the
>> internal pointer.  I'd be impressed if jemalloc handled this
>> correctly!  (And even more impressed if it worked in general, for
>> non-huge allocations too.  :)
> 
> From my trivial testing, it actually works for allocations > (1 << 15).
> 
> That is:
> char *ptr = malloc((1 << 15) + 1); free(ptr + 32);
> does free the pointer, while
> char *ptr = malloc(1 << 15); free(ptr + 32);
> doesn't.
> 
> Neither crash (which is better than the crash we get with our fork :) )
> 
> Jason, how actually safe is jemalloc now, when trying to free a pointer
> inside an allocation it gave out?

There are assertions that catch attempts to free interior pointers for small allocations, but as far as I know, freeing interior pointers for small allocations will otherwise work.  Freeing interior pointers for large and huge allocations will always cause some sort of metadata corruption.  I expect that both of your test cases are actually causing corruption.  Do you have assertions enabled?  I think (hope) there are assertions that will fail in both cases.

Thanks,
Jason

From mh+jemalloc at glandium.org  Thu Apr  5 11:42:07 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 5 Apr 2012 20:42:07 +0200
Subject: [PATCH 3/3] Improve zone support for OSX
In-Reply-To: <446F887B-0833-4347-8D80-3190EE501E3F@canonware.com>
References: <1332262898-31839-1-git-send-email-mh+jemalloc@glandium.org>
	<CAFWcpZ656Z=VaTpKp2NLd=VYdxi1yEp=48WA+LGkwWtxd3AReQ@mail.gmail.com>
	<20120320171048.GA32129@glandium.org>
	<CAFWcpZ52eDJfNsLst1Zw9U8L06jeum_seTzdCoGqUm2A9apyiQ@mail.gmail.com>
	<20120405094525.GA23644@glandium.org>
	<446F887B-0833-4347-8D80-3190EE501E3F@canonware.com>
Message-ID: <20120405184207.GA9763@glandium.org>

On Thu, Apr 05, 2012 at 10:52:07AM -0700, Jason Evans wrote:
> On Apr 5, 2012, at 2:45 AM, Mike Hommey wrote:
> > On Tue, Mar 20, 2012 at 01:18:13PM -0400, Justin Lebar wrote:
> >> On Tue, Mar 20, 2012 at 1:10 PM, Mike Hommey
> >> <mh+jemalloc at glandium.org> wrote:
> >>> On Tue, Mar 20, 2012 at 01:04:54PM -0400, Justin Lebar wrote:
> >>>> btw, I'm skeptical of the value of supporting OSX 10.5, because
> >>>> 10.5 occasionally passes invalid pointers to ozone_size [1].
> >>>> 
> >>>> [1] https://bugzilla.mozilla.org/show_bug.cgi?id=694335
> >>> 
> >>> For one, not all jemalloc users are going to have the problem,
> >>> which is limited to some APIs.
> >> 
> >> True, but we of course don't know the full set of circumstances
> >> under which OSX will pass an invalid pointer.
> >> 
> >>> Also, AIUI, the current jemalloc code does the right thing for the
> >>> ozone_size, which is not the case in the old jemalloc fork we use
> >>> in Firefox, so depending on what is done with the result of
> >>> ozone_size, it might be okay.
> >> 
> >> What's the difference in behavior?
> >> 
> >>> BTW, I guess you wanted to point to
> >>> https://bugzilla.mozilla.org/show_bug.cgi?id=702250#c30
> >> 
> >> Yes, thanks.  And my analysis there is that 10.5 tries to free the
> >> internal pointer.  I'd be impressed if jemalloc handled this
> >> correctly!  (And even more impressed if it worked in general, for
> >> non-huge allocations too.  :)
> > 
> > From my trivial testing, it actually works for allocations > (1 <<
> > 15).
> > 
> > That is: char *ptr = malloc((1 << 15) + 1); free(ptr + 32); does
> > free the pointer, while char *ptr = malloc(1 << 15); free(ptr + 32);
> > doesn't.
> > 
> > Neither crash (which is better than the crash we get with our fork
> > :) )
> > 
> > Jason, how actually safe is jemalloc now, when trying to free a
> > pointer inside an allocation it gave out?
> 
> There are assertions that catch attempts to free interior pointers for
> small allocations, but as far as I know, freeing interior pointers for
> small allocations will otherwise work.  Freeing interior pointers for
> large and huge allocations will always cause some sort of metadata
> corruption.  I expect that both of your test cases are actually
> causing corruption.  Do you have assertions enabled?  I think (hope)
> there are assertions that will fail in both cases.

You're unfortunately right, with assertions, it fails:
<jemalloc>: ../src/arena.c:1437: Failed assertion: "((uintptr_t)ptr &
PAGE_MASK) == 0"

But I was under the impression that the isvalloc check was
making things safer.

Mike


From mh+jemalloc at glandium.org  Thu Apr  5 11:44:13 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 5 Apr 2012 20:44:13 +0200
Subject: JEMALLOC_THREADED_INIT
In-Reply-To: <037851CB-C0E5-4DB1-8030-1CA90C952B9D@canonware.com>
References: <20120405160222.GA1034@glandium.org>
	<037851CB-C0E5-4DB1-8030-1CA90C952B9D@canonware.com>
Message-ID: <20120405184413.GB9763@glandium.org>

On Thu, Apr 05, 2012 at 10:45:30AM -0700, Jason Evans wrote:
> On Apr 5, 2012, at 9:02 AM, Mike Hommey wrote:
> > I see that 41b6afb (Port to FreeBSD) added JEMALLOC_THREADED_INIT,
> > but nothing AC_DEFINEs it. Is that expected? (I bumped into this
> > because I was looking at pthread functions use)
> 
> Whoops, that's supposed to be defined on Linux, but as a side effect
> of that mistake, I also broke the code without noticing.  I'll get it
> sorted out today.

By the way, the pthread_create interception in src/mutex.c could use
the value of is_threaded instead of pthread_once().

Mike


From jasone at canonware.com  Thu Apr  5 12:04:43 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 5 Apr 2012 12:04:43 -0700
Subject: [PATCH 3/3] Improve zone support for OSX
In-Reply-To: <20120405184207.GA9763@glandium.org>
References: <1332262898-31839-1-git-send-email-mh+jemalloc@glandium.org>
	<CAFWcpZ656Z=VaTpKp2NLd=VYdxi1yEp=48WA+LGkwWtxd3AReQ@mail.gmail.com>
	<20120320171048.GA32129@glandium.org>
	<CAFWcpZ52eDJfNsLst1Zw9U8L06jeum_seTzdCoGqUm2A9apyiQ@mail.gmail.com>
	<20120405094525.GA23644@glandium.org>
	<446F887B-0833-4347-8D80-3190EE501E3F@canonware.com>
	<20120405184207.GA9763@glandium.org>
Message-ID: <83FFDEF9-5302-4987-867B-C2A544E6FC9A@canonware.com>

On Apr 5, 2012, at 11:42 AM, Mike Hommey wrote:
> On Thu, Apr 05, 2012 at 10:52:07AM -0700, Jason Evans wrote:
>> On Apr 5, 2012, at 2:45 AM, Mike Hommey wrote:
>>> On Tue, Mar 20, 2012 at 01:18:13PM -0400, Justin Lebar wrote:
>>>> On Tue, Mar 20, 2012 at 1:10 PM, Mike Hommey
>>>> <mh+jemalloc at glandium.org> wrote:
>>>>> On Tue, Mar 20, 2012 at 01:04:54PM -0400, Justin Lebar wrote:
>>>>>> btw, I'm skeptical of the value of supporting OSX 10.5, because
>>>>>> 10.5 occasionally passes invalid pointers to ozone_size [1].
>>>>>> 
>>>>>> [1] https://bugzilla.mozilla.org/show_bug.cgi?id=694335
>>>>> 
>>>>> For one, not all jemalloc users are going to have the problem,
>>>>> which is limited to some APIs.
>>>> 
>>>> True, but we of course don't know the full set of circumstances
>>>> under which OSX will pass an invalid pointer.
>>>> 
>>>>> Also, AIUI, the current jemalloc code does the right thing for the
>>>>> ozone_size, which is not the case in the old jemalloc fork we use
>>>>> in Firefox, so depending on what is done with the result of
>>>>> ozone_size, it might be okay.
>>>> 
>>>> What's the difference in behavior?
>>>> 
>>>>> BTW, I guess you wanted to point to
>>>>> https://bugzilla.mozilla.org/show_bug.cgi?id=702250#c30
>>>> 
>>>> Yes, thanks.  And my analysis there is that 10.5 tries to free the
>>>> internal pointer.  I'd be impressed if jemalloc handled this
>>>> correctly!  (And even more impressed if it worked in general, for
>>>> non-huge allocations too.  :)
>>> 
>>> From my trivial testing, it actually works for allocations > (1 <<
>>> 15).
>>> 
>>> That is: char *ptr = malloc((1 << 15) + 1); free(ptr + 32); does
>>> free the pointer, while char *ptr = malloc(1 << 15); free(ptr + 32);
>>> doesn't.
>>> 
>>> Neither crash (which is better than the crash we get with our fork
>>> :) )
>>> 
>>> Jason, how actually safe is jemalloc now, when trying to free a
>>> pointer inside an allocation it gave out?
>> 
>> There are assertions that catch attempts to free interior pointers for
>> small allocations, but as far as I know, freeing interior pointers for
>> small allocations will otherwise work.  Freeing interior pointers for
>> large and huge allocations will always cause some sort of metadata
>> corruption.  I expect that both of your test cases are actually
>> causing corruption.  Do you have assertions enabled?  I think (hope)
>> there are assertions that will fail in both cases.
> 
> You're unfortunately right, with assertions, it fails:
> <jemalloc>: ../src/arena.c:1437: Failed assertion: "((uintptr_t)ptr &
> PAGE_MASK) == 0"

This is an assertion in isalloc().  If the assertion were absent, then a different assertion in arena_dalloc() would notice that the pointer isn't page-aligned.  Absent that assertion, things would just happen to work for objects that don't fit in thread cache (> 32 KiB), but for thread-cached free, the application could end up getting the unaligned pointer back as a new allocation, thus resulting in a "short" allocation, potential alignment issues, etc.

> But I was under the impression that the isvalloc check was
> making things safer.

The ivsalloc check makes sure that the pointer is within a chunk of memory that jemalloc owns, but it doesn't provide any additional safety.

Jason

From mh+jemalloc at glandium.org  Tue Apr 10 06:11:52 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 10 Apr 2012 15:11:52 +0200
Subject: [PATCH] Avoid using "common" macro names as goto labels
Message-ID: <1334063512-5342-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

OUT and ERROR are defined under mingw.
---
 src/prof.c |   14 +++++++-------
 src/util.c |    4 ++--
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/prof.c b/src/prof.c
index d2532ec..2807057 100644
--- a/src/prof.c
+++ b/src/prof.c
@@ -854,7 +854,7 @@ prof_dump(bool propagate_err, const char *filename, bool leakcheck)
 			if (opt_abort)
 				abort();
 		}
-		goto ERROR;
+		goto ERR;
 	}
 
 	/* Merge per thread profile stats, and sum them in cnt_all. */
@@ -870,7 +870,7 @@ prof_dump(bool propagate_err, const char *filename, bool leakcheck)
 		    " [%"PRIu64": %"PRIu64"] @ heapprofile\n",
 		    cnt_all.curobjs, cnt_all.curbytes,
 		    cnt_all.accumobjs, cnt_all.accumbytes))
-			goto ERROR;
+			goto ERR;
 	} else {
 		if (prof_printf(propagate_err,
 		    "heap profile: %"PRId64": %"PRId64
@@ -878,22 +878,22 @@ prof_dump(bool propagate_err, const char *filename, bool leakcheck)
 		    cnt_all.curobjs, cnt_all.curbytes,
 		    cnt_all.accumobjs, cnt_all.accumbytes,
 		    ((uint64_t)1U << opt_lg_prof_sample)))
-			goto ERROR;
+			goto ERR;
 	}
 
 	/* Dump  per ctx profile stats. */
 	for (tabind = 0; ckh_iter(&bt2ctx, &tabind, &bt.v, &ctx.v)
 	    == false;) {
 		if (prof_dump_ctx(propagate_err, ctx.p, bt.p))
-			goto ERROR;
+			goto ERR;
 	}
 
 	/* Dump /proc/<pid>/maps if possible. */
 	if (prof_dump_maps(propagate_err))
-		goto ERROR;
+		goto ERR;
 
 	if (prof_flush(propagate_err))
-		goto ERROR;
+		goto ERR;
 	close(prof_dump_fd);
 	prof_leave();
 
@@ -909,7 +909,7 @@ prof_dump(bool propagate_err, const char *filename, bool leakcheck)
 	}
 
 	return (false);
-ERROR:
+ERR:
 	prof_leave();
 	return (true);
 }
diff --git a/src/util.c b/src/util.c
index 107bdcf..8a62738 100644
--- a/src/util.c
+++ b/src/util.c
@@ -349,7 +349,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	f = format;
 	while (true) {
 		switch (*f) {
-		case '\0': goto OUT;
+		case '\0': goto END;
 		case '%': {
 			bool alt_form = false;
 			bool zero_pad = false;
@@ -542,7 +542,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 			break;
 		}}
 	}
-	OUT:
+	END:
 	if (i < size)
 		str[i] = '\0';
 	else
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Tue Apr 10 06:29:18 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 10 Apr 2012 15:29:18 +0200
Subject: [PATCH] Ignore whitespaces when comparing test results with expected
	output
Message-ID: <1334064558-5804-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

In mingw, the test result may contain CRLF while the .exp files don't, or
the other way around.
---
 Makefile.in |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Makefile.in b/Makefile.in
index 821c063..7df4fc6 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -205,7 +205,7 @@ check: tests
 			$(TEST_LIBRARY_PATH) $${t} @abs_srcroot@ @abs_objroot@ \
 			  > @objroot@$${t}.out 2>&1; \
 			if test -e "@srcroot@$${t}.exp"; then \
-				diff -u @srcroot@$${t}.exp \
+				diff -w -u @srcroot@$${t}.exp \
 				  @objroot@$${t}.out >/dev/null 2>&1; \
 				fail=$$?; \
 				if test "$${fail}" -eq "1" ; then \
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Tue Apr 10 09:19:45 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 10 Apr 2012 18:19:45 +0200
Subject: [PATCH] Remove MAP_NORESERVE support
Message-ID: <1334074785-8519-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

It was only used by the swap feature, and that is gone.
---
 include/jemalloc/internal/chunk_mmap.h |    1 -
 src/chunk_mmap.c                       |   37 +++++++++++---------------------
 2 files changed, 12 insertions(+), 26 deletions(-)

diff --git a/include/jemalloc/internal/chunk_mmap.h b/include/jemalloc/internal/chunk_mmap.h
index 07b50a4..3f60315 100644
--- a/include/jemalloc/internal/chunk_mmap.h
+++ b/include/jemalloc/internal/chunk_mmap.h
@@ -10,7 +10,6 @@
 #ifdef JEMALLOC_H_EXTERNS
 
 void	*chunk_alloc_mmap(size_t size);
-void	*chunk_alloc_mmap_noreserve(size_t size);
 void	chunk_dealloc_mmap(void *chunk, size_t size);
 
 bool	chunk_mmap_boot(void);
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index 749a2da..6d16191 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -15,16 +15,15 @@ malloc_tsd_funcs(JEMALLOC_INLINE, mmap_unaligned, bool, false,
 /******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
-static void	*pages_map(void *addr, size_t size, bool noreserve);
+static void	*pages_map(void *addr, size_t size);
 static void	pages_unmap(void *addr, size_t size);
-static void	*chunk_alloc_mmap_slow(size_t size, bool unaligned,
-    bool noreserve);
-static void	*chunk_alloc_mmap_internal(size_t size, bool noreserve);
+static void	*chunk_alloc_mmap_slow(size_t size, bool unaligned);
+static void	*chunk_alloc_mmap_internal(size_t size);
 
 /******************************************************************************/
 
 static void *
-pages_map(void *addr, size_t size, bool noreserve)
+pages_map(void *addr, size_t size)
 {
 	void *ret;
 
@@ -33,10 +32,6 @@ pages_map(void *addr, size_t size, bool noreserve)
 	 * of existing mappings, and we only want to create new mappings.
 	 */
 	int flags = MAP_PRIVATE | MAP_ANON;
-#ifdef MAP_NORESERVE
-	if (noreserve)
-		flags |= MAP_NORESERVE;
-#endif
 	ret = mmap(addr, size, PROT_READ | PROT_WRITE, flags, -1, 0);
 	assert(ret != NULL);
 
@@ -78,7 +73,7 @@ pages_unmap(void *addr, size_t size)
 }
 
 static void *
-chunk_alloc_mmap_slow(size_t size, bool unaligned, bool noreserve)
+chunk_alloc_mmap_slow(size_t size, bool unaligned)
 {
 	void *ret;
 	size_t offset;
@@ -87,7 +82,7 @@ chunk_alloc_mmap_slow(size_t size, bool unaligned, bool noreserve)
 	if (size + chunksize <= size)
 		return (NULL);
 
-	ret = pages_map(NULL, size + chunksize, noreserve);
+	ret = pages_map(NULL, size + chunksize);
 	if (ret == NULL)
 		return (NULL);
 
@@ -126,7 +121,7 @@ chunk_alloc_mmap_slow(size_t size, bool unaligned, bool noreserve)
 }
 
 static void *
-chunk_alloc_mmap_internal(size_t size, bool noreserve)
+chunk_alloc_mmap_internal(size_t size)
 {
 	void *ret;
 
@@ -161,7 +156,7 @@ chunk_alloc_mmap_internal(size_t size, bool noreserve)
 	if (mmap_unaligned_booted && *mmap_unaligned_tsd_get() == false) {
 		size_t offset;
 
-		ret = pages_map(NULL, size, noreserve);
+		ret = pages_map(NULL, size);
 		if (ret == NULL)
 			return (NULL);
 
@@ -171,14 +166,13 @@ chunk_alloc_mmap_internal(size_t size, bool noreserve)
 			mmap_unaligned_tsd_set(&mu);
 			/* Try to extend chunk boundary. */
 			if (pages_map((void *)((uintptr_t)ret + size),
-			    chunksize - offset, noreserve) == NULL) {
+			    chunksize - offset) == NULL) {
 				/*
 				 * Extension failed.  Clean up, then revert to
 				 * the reliable-but-expensive method.
 				 */
 				pages_unmap(ret, size);
-				ret = chunk_alloc_mmap_slow(size, true,
-				    noreserve);
+				ret = chunk_alloc_mmap_slow(size, true);
 			} else {
 				/* Clean up unneeded leading space. */
 				pages_unmap(ret, chunksize - offset);
@@ -187,7 +181,7 @@ chunk_alloc_mmap_internal(size_t size, bool noreserve)
 			}
 		}
 	} else
-		ret = chunk_alloc_mmap_slow(size, false, noreserve);
+		ret = chunk_alloc_mmap_slow(size, false);
 
 	return (ret);
 }
@@ -196,14 +190,7 @@ void *
 chunk_alloc_mmap(size_t size)
 {
 
-	return (chunk_alloc_mmap_internal(size, false));
-}
-
-void *
-chunk_alloc_mmap_noreserve(size_t size)
-{
-
-	return (chunk_alloc_mmap_internal(size, true));
+	return (chunk_alloc_mmap_internal(size));
 }
 
 void
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Tue Apr 10 10:50:33 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 10 Apr 2012 19:50:33 +0200
Subject: [PATCH] Add a chunk_aligned_alloc function handling alignment
	constraints on chunks
Message-ID: <1334080233-20646-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 include/jemalloc/internal/chunk.h      |   15 ++++++++++-
 include/jemalloc/internal/chunk_dss.h  |    2 +-
 include/jemalloc/internal/chunk_mmap.h |    2 +-
 src/chunk.c                            |    7 ++---
 src/chunk_dss.c                        |   46 +++++++++++++++++++-------------
 src/chunk_mmap.c                       |   28 +++++++++----------
 src/huge.c                             |   33 ++---------------------
 7 files changed, 63 insertions(+), 70 deletions(-)

diff --git a/include/jemalloc/internal/chunk.h b/include/jemalloc/internal/chunk.h
index 8e24e8f..8ade6eb 100644
--- a/include/jemalloc/internal/chunk.h
+++ b/include/jemalloc/internal/chunk.h
@@ -42,7 +42,7 @@ extern size_t		chunk_npages;
 extern size_t		map_bias; /* Number of arena chunk header pages. */
 extern size_t		arena_maxclass; /* Max size class for arenas. */
 
-void	*chunk_alloc(size_t size, bool base, bool *zero);
+void	*chunk_aligned_alloc(size_t size, size_t align, bool base, bool *zero);
 void	chunk_dealloc(void *chunk, size_t size, bool unmap);
 bool	chunk_boot0(void);
 bool	chunk_boot1(void);
@@ -51,6 +51,19 @@ bool	chunk_boot1(void);
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
+#ifndef JEMALLOC_ENABLE_INLINE
+void 	*chunk_alloc(size_t size, bool base, bool *zero);
+#endif
+
+#if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_CHUNK_C_))
+JEMALLOC_INLINE void *
+chunk_alloc(size_t size, bool base, bool *zero)
+{
+
+	return chunk_aligned_alloc(size, chunksize, base, zero);
+}
+#endif
+
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
 
diff --git a/include/jemalloc/internal/chunk_dss.h b/include/jemalloc/internal/chunk_dss.h
index a39a203..6ef97aa 100644
--- a/include/jemalloc/internal/chunk_dss.h
+++ b/include/jemalloc/internal/chunk_dss.h
@@ -9,7 +9,7 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-void	*chunk_alloc_dss(size_t size, bool *zero);
+void	*chunk_alloc_dss(size_t size, size_t align, bool *zero);
 bool	chunk_in_dss(void *chunk);
 bool	chunk_dealloc_dss(void *chunk, size_t size);
 bool	chunk_dss_boot(void);
diff --git a/include/jemalloc/internal/chunk_mmap.h b/include/jemalloc/internal/chunk_mmap.h
index 3f60315..54f693c 100644
--- a/include/jemalloc/internal/chunk_mmap.h
+++ b/include/jemalloc/internal/chunk_mmap.h
@@ -9,7 +9,7 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-void	*chunk_alloc_mmap(size_t size);
+void	*chunk_alloc_mmap(size_t size, size_t align);
 void	chunk_dealloc_mmap(void *chunk, size_t size);
 
 bool	chunk_mmap_boot(void);
diff --git a/src/chunk.c b/src/chunk.c
index 8fcd61e..fc0a1a3 100644
--- a/src/chunk.c
+++ b/src/chunk.c
@@ -27,19 +27,20 @@ size_t		arena_maxclass; /* Max size class for arenas. */
  * advantage of them if they are returned.
  */
 void *
-chunk_alloc(size_t size, bool base, bool *zero)
+chunk_aligned_alloc(size_t size, size_t align, bool base, bool *zero)
 {
 	void *ret;
 
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
+	assert((align & chunksize_mask) == 0);
 
 	if (config_dss) {
-		ret = chunk_alloc_dss(size, zero);
+		ret = chunk_alloc_dss(size, align, zero);
 		if (ret != NULL)
 			goto RETURN;
 	}
-	ret = chunk_alloc_mmap(size);
+	ret = chunk_alloc_mmap(size, align);
 	if (ret != NULL) {
 		*zero = true;
 		goto RETURN;
diff --git a/src/chunk_dss.c b/src/chunk_dss.c
index 405dc29..ed14d7f 100644
--- a/src/chunk_dss.c
+++ b/src/chunk_dss.c
@@ -28,41 +28,49 @@ static extent_tree_t	dss_chunks_ad;
 /******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
-static void	*chunk_recycle_dss(size_t size, bool *zero);
+static void	*chunk_recycle_dss(size_t size, size_t align, bool *zero);
 static extent_node_t *chunk_dealloc_dss_record(void *chunk, size_t size);
 
 /******************************************************************************/
 
 static void *
-chunk_recycle_dss(size_t size, bool *zero)
+chunk_recycle_dss(size_t size, size_t align, bool *zero)
 {
 	extent_node_t *node, key;
 
 	cassert(config_dss);
 
 	key.addr = NULL;
-	key.size = size;
+	key.size = size + align - chunksize;
 	malloc_mutex_lock(&dss_mtx);
 	node = extent_tree_szad_nsearch(&dss_chunks_szad, &key);
 	if (node != NULL) {
-		void *ret = node->addr;
+		size_t offset = (size_t)((uintptr_t)(node->addr) & (align - 1));
+		void *ret;
+		if (offset > 0)
+			offset = align - offset;
+		ret = (void *)((uintptr_t)(node->addr) + offset);
 
 		/* Remove node from the tree. */
 		extent_tree_szad_remove(&dss_chunks_szad, node);
-		if (node->size == size) {
-			extent_tree_ad_remove(&dss_chunks_ad, node);
-			base_node_dealloc(node);
-		} else {
-			/*
-			 * Insert the remainder of node's address range as a
-			 * smaller chunk.  Its position within dss_chunks_ad
-			 * does not change.
-			 */
-			assert(node->size > size);
-			node->addr = (void *)((uintptr_t)node->addr + size);
-			node->size -= size;
+		extent_tree_ad_remove(&dss_chunks_ad, node);
+		if (offset > 0) {
+			/* Insert the leading space as a smaller chunk. */
+			node->size = offset;
 			extent_tree_szad_insert(&dss_chunks_szad, node);
+			extent_tree_ad_insert(&dss_chunks_ad, node);
 		}
+		if (align - chunksize > offset) {
+			if (offset > 0)
+				node = base_node_alloc();
+			/* Insert the trailing space as a smaller chunk. */
+			node->addr = (void *)((uintptr_t)(ret) + size);
+			node->size = align - chunksize - offset;
+			extent_tree_szad_insert(&dss_chunks_szad, node);
+			extent_tree_ad_insert(&dss_chunks_ad, node);
+		} else if (offset == 0)
+			base_node_dealloc(node);
+
 		malloc_mutex_unlock(&dss_mtx);
 
 		if (*zero)
@@ -75,13 +83,13 @@ chunk_recycle_dss(size_t size, bool *zero)
 }
 
 void *
-chunk_alloc_dss(size_t size, bool *zero)
+chunk_alloc_dss(size_t size, size_t align, bool *zero)
 {
 	void *ret;
 
 	cassert(config_dss);
 
-	ret = chunk_recycle_dss(size, zero);
+	ret = chunk_recycle_dss(size, align, zero);
 	if (ret != NULL)
 		return (ret);
 
@@ -110,7 +118,7 @@ chunk_alloc_dss(size_t size, bool *zero)
 			 * chunk-align the end of the DSS.
 			 */
 			incr = (intptr_t)size
-			    - (intptr_t)CHUNK_ADDR2OFFSET(dss_max);
+			    - (intptr_t)((uintptr_t)(dss_max) & (align - 1));
 			if (incr == (intptr_t)size)
 				ret = dss_max;
 			else {
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index 6d16191..e3e70fc 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -17,8 +17,8 @@ malloc_tsd_funcs(JEMALLOC_INLINE, mmap_unaligned, bool, false,
 
 static void	*pages_map(void *addr, size_t size);
 static void	pages_unmap(void *addr, size_t size);
-static void	*chunk_alloc_mmap_slow(size_t size, bool unaligned);
-static void	*chunk_alloc_mmap_internal(size_t size);
+static void	*chunk_alloc_mmap_slow(size_t size, size_t align, bool unaligned);
+static void	*chunk_alloc_mmap_internal(size_t size, size_t align);
 
 /******************************************************************************/
 
@@ -73,7 +73,7 @@ pages_unmap(void *addr, size_t size)
 }
 
 static void *
-chunk_alloc_mmap_slow(size_t size, bool unaligned)
+chunk_alloc_mmap_slow(size_t size, size_t align, bool unaligned)
 {
 	void *ret;
 	size_t offset;
@@ -82,21 +82,21 @@ chunk_alloc_mmap_slow(size_t size, bool unaligned)
 	if (size + chunksize <= size)
 		return (NULL);
 
-	ret = pages_map(NULL, size + chunksize);
+	ret = pages_map(NULL, size + align);
 	if (ret == NULL)
 		return (NULL);
 
 	/* Clean up unneeded leading/trailing space. */
-	offset = CHUNK_ADDR2OFFSET(ret);
+	offset = (size_t)((uintptr_t)(ret) & (align - 1));
 	if (offset != 0) {
 		/* Note that mmap() returned an unaligned mapping. */
 		unaligned = true;
 
 		/* Leading space. */
-		pages_unmap(ret, chunksize - offset);
+		pages_unmap(ret, align - offset);
 
 		ret = (void *)((uintptr_t)ret +
-		    (chunksize - offset));
+		    (align - offset));
 
 		/* Trailing space. */
 		pages_unmap((void *)((uintptr_t)ret + size),
@@ -104,7 +104,7 @@ chunk_alloc_mmap_slow(size_t size, bool unaligned)
 	} else {
 		/* Trailing space only. */
 		pages_unmap((void *)((uintptr_t)ret + size),
-		    chunksize);
+		    align);
 	}
 
 	/*
@@ -121,7 +121,7 @@ chunk_alloc_mmap_slow(size_t size, bool unaligned)
 }
 
 static void *
-chunk_alloc_mmap_internal(size_t size)
+chunk_alloc_mmap_internal(size_t size, size_t align)
 {
 	void *ret;
 
@@ -160,7 +160,7 @@ chunk_alloc_mmap_internal(size_t size)
 		if (ret == NULL)
 			return (NULL);
 
-		offset = CHUNK_ADDR2OFFSET(ret);
+		offset = (size_t)((uintptr_t)(ret) & (align - 1));
 		if (offset != 0) {
 			bool mu = true;
 			mmap_unaligned_tsd_set(&mu);
@@ -172,7 +172,7 @@ chunk_alloc_mmap_internal(size_t size)
 				 * the reliable-but-expensive method.
 				 */
 				pages_unmap(ret, size);
-				ret = chunk_alloc_mmap_slow(size, true);
+				ret = chunk_alloc_mmap_slow(size, align, true);
 			} else {
 				/* Clean up unneeded leading space. */
 				pages_unmap(ret, chunksize - offset);
@@ -181,16 +181,16 @@ chunk_alloc_mmap_internal(size_t size)
 			}
 		}
 	} else
-		ret = chunk_alloc_mmap_slow(size, false);
+		ret = chunk_alloc_mmap_slow(size, align, false);
 
 	return (ret);
 }
 
 void *
-chunk_alloc_mmap(size_t size)
+chunk_alloc_mmap(size_t size, size_t align)
 {
 
-	return (chunk_alloc_mmap_internal(size));
+	return (chunk_alloc_mmap_internal(size, align));
 }
 
 void
diff --git a/src/huge.c b/src/huge.c
index a4e6cc8..efcf5fa 100644
--- a/src/huge.c
+++ b/src/huge.c
@@ -69,7 +69,7 @@ void *
 huge_palloc(size_t size, size_t alignment, bool zero)
 {
 	void *ret;
-	size_t alloc_size, chunk_size, offset;
+	size_t chunk_size;
 	extent_node_t *node;
 
 	/*
@@ -84,46 +84,17 @@ huge_palloc(size_t size, size_t alignment, bool zero)
 
 	chunk_size = CHUNK_CEILING(size);
 
-	if (size >= alignment)
-		alloc_size = chunk_size + alignment - chunksize;
-	else
-		alloc_size = (alignment << 1) - chunksize;
-
 	/* Allocate an extent node with which to track the chunk. */
 	node = base_node_alloc();
 	if (node == NULL)
 		return (NULL);
 
-	ret = chunk_alloc(alloc_size, false, &zero);
+	ret = chunk_aligned_alloc(size, alignment, false, &zero);
 	if (ret == NULL) {
 		base_node_dealloc(node);
 		return (NULL);
 	}
 
-	offset = (uintptr_t)ret & (alignment - 1);
-	assert((offset & chunksize_mask) == 0);
-	assert(offset < alloc_size);
-	if (offset == 0) {
-		/* Trim trailing space. */
-		chunk_dealloc((void *)((uintptr_t)ret + chunk_size), alloc_size
-		    - chunk_size, true);
-	} else {
-		size_t trailsize;
-
-		/* Trim leading space. */
-		chunk_dealloc(ret, alignment - offset, true);
-
-		ret = (void *)((uintptr_t)ret + (alignment - offset));
-
-		trailsize = alloc_size - (alignment - offset) - chunk_size;
-		if (trailsize != 0) {
-		    /* Trim trailing space. */
-		    assert(trailsize < alloc_size);
-		    chunk_dealloc((void *)((uintptr_t)ret + chunk_size),
-			trailsize, true);
-		}
-	}
-
 	/* Insert node into huge. */
 	node->addr = ret;
 	node->size = chunk_size;
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Tue Apr 10 10:54:27 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 10 Apr 2012 19:54:27 +0200
Subject: [PATCH] Add a chunk_aligned_alloc function handling alignment
	constraints on chunks
In-Reply-To: <1334080233-20646-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334080233-20646-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <20120410175427.GA20755@glandium.org>

On Tue, Apr 10, 2012 at 07:50:33PM +0200, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> ---
>  include/jemalloc/internal/chunk.h      |   15 ++++++++++-
>  include/jemalloc/internal/chunk_dss.h  |    2 +-
>  include/jemalloc/internal/chunk_mmap.h |    2 +-
>  src/chunk.c                            |    7 ++---
>  src/chunk_dss.c                        |   46 +++++++++++++++++++-------------
>  src/chunk_mmap.c                       |   28 +++++++++----------
>  src/huge.c                             |   33 ++---------------------
>  7 files changed, 63 insertions(+), 70 deletions(-)

The reason why I'm interested in this is that the way VirtualAlloc and
VirtualFree work on Windows makes it cumbersome to do "huge" alignment,
and would require going through hoops and repeating code between huge.c
and chunk_mmap.c. It gets simpler if everything is handled in one place.

I'm not sure how to best stress test the changes in chunk_dss.c, so I'm
not sure it doesn't break in subtle ways. The changes in chunk_mmap.c
are much more straightforward.

Mike


From jasone at canonware.com  Tue Apr 10 11:29:30 2012
From: jasone at canonware.com (Jason Evans)
Date: Tue, 10 Apr 2012 11:29:30 -0700
Subject: [PATCH] Avoid using "common" macro names as goto labels
In-Reply-To: <1334063512-5342-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334063512-5342-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <DC70B5F0-F065-4006-92ED-3DFBE54B2CFC@canonware.com>

On Apr 10, 2012, at 6:11 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> OUT and ERROR are defined under mingw.

This is a bit like treading a minefield.  I'm inclined to prefix all labels with JEMALLOC_LABEL_ to make sure the issue doesn't come up again.  What do you think?

Thanks,
Jason



From jasone at canonware.com  Tue Apr 10 12:01:57 2012
From: jasone at canonware.com (Jason Evans)
Date: Tue, 10 Apr 2012 12:01:57 -0700
Subject: [PATCH] Ignore whitespaces when comparing test results with
	expected output
In-Reply-To: <1334064558-5804-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334064558-5804-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <75094DB6-459B-4A77-AFE5-5E644FB006F6@canonware.com>

On Apr 10, 2012, at 6:29 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> In mingw, the test result may contain CRLF while the .exp files don't, or
> the other way around.

Applied; thanks.

Jason



From jasone at canonware.com  Tue Apr 10 12:07:44 2012
From: jasone at canonware.com (Jason Evans)
Date: Tue, 10 Apr 2012 12:07:44 -0700
Subject: [PATCH] Remove MAP_NORESERVE support
In-Reply-To: <1334074785-8519-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334074785-8519-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <74EF62E3-1F0B-4C8B-8EB5-9CE131C974F4@canonware.com>

On Apr 10, 2012, at 9:19 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> It was only used by the swap feature, and that is gone.

Applied; thanks.  I had this in my todo list at one point, but apparently lost track of it.

Jason



From mh+jemalloc at glandium.org  Tue Apr 10 12:47:09 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 10 Apr 2012 21:47:09 +0200
Subject: [PATCH] Avoid using "common" macro names as goto labels
In-Reply-To: <DC70B5F0-F065-4006-92ED-3DFBE54B2CFC@canonware.com>
References: <1334063512-5342-1-git-send-email-mh+jemalloc@glandium.org>
	<DC70B5F0-F065-4006-92ED-3DFBE54B2CFC@canonware.com>
Message-ID: <20120410194709.GA22580@glandium.org>

On Tue, Apr 10, 2012 at 11:29:30AM -0700, Jason Evans wrote:
> On Apr 10, 2012, at 6:11 AM, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > OUT and ERROR are defined under mingw.
> 
> This is a bit like treading a minefield.  I'm inclined to prefix all
> labels with JEMALLOC_LABEL_ to make sure the issue doesn't come up
> again.  What do you think?

Another approach would be to use lowercase names. They'd be less likely
to be defined as macros.

Mike


From jasone at canonware.com  Tue Apr 10 14:59:03 2012
From: jasone at canonware.com (Jason Evans)
Date: Tue, 10 Apr 2012 14:59:03 -0700
Subject: [PATCH] Add a chunk_aligned_alloc function handling alignment
	constraints on chunks
In-Reply-To: <20120410175427.GA20755@glandium.org>
References: <1334080233-20646-1-git-send-email-mh+jemalloc@glandium.org>
	<20120410175427.GA20755@glandium.org>
Message-ID: <66661490-9D63-433D-9686-BED5F7E72FBA@canonware.com>

On Apr 10, 2012, at 10:54 AM, Mike Hommey wrote:
> On Tue, Apr 10, 2012 at 07:50:33PM +0200, Mike Hommey wrote:
>> From: Mike Hommey <mh at glandium.org>
>> 
>> ---
>> include/jemalloc/internal/chunk.h      |   15 ++++++++++-
>> include/jemalloc/internal/chunk_dss.h  |    2 +-
>> include/jemalloc/internal/chunk_mmap.h |    2 +-
>> src/chunk.c                            |    7 ++---
>> src/chunk_dss.c                        |   46 +++++++++++++++++++-------------
>> src/chunk_mmap.c                       |   28 +++++++++----------
>> src/huge.c                             |   33 ++---------------------
>> 7 files changed, 63 insertions(+), 70 deletions(-)
> 
> The reason why I'm interested in this is that the way VirtualAlloc and
> VirtualFree work on Windows makes it cumbersome to do "huge" alignment,
> and would require going through hoops and repeating code between huge.c
> and chunk_mmap.c. It gets simpler if everything is handled in one place.
> 
> I'm not sure how to best stress test the changes in chunk_dss.c, so I'm
> not sure it doesn't break in subtle ways. The changes in chunk_mmap.c
> are much more straightforward.

There were problems in the dss code that I had to fix, and I did some other refactoring that this change allowed (e.g. huge_malloc() now just calls huge_palloc()).  The result is committed now; please let me know if you encounter any problems with the changes I made.

By the way, I'm excited to see hints of Windows support in the works. =)

Thanks,
Jason

From jasone at canonware.com  Tue Apr 10 15:09:55 2012
From: jasone at canonware.com (Jason Evans)
Date: Tue, 10 Apr 2012 15:09:55 -0700
Subject: [PATCH] Avoid using "common" macro names as goto labels
In-Reply-To: <20120410194709.GA22580@glandium.org>
References: <1334063512-5342-1-git-send-email-mh+jemalloc@glandium.org>
	<DC70B5F0-F065-4006-92ED-3DFBE54B2CFC@canonware.com>
	<20120410194709.GA22580@glandium.org>
Message-ID: <E9117169-C484-4E91-A019-C7A54947B713@canonware.com>

On Apr 10, 2012, at 12:47 PM, Mike Hommey wrote:
> On Tue, Apr 10, 2012 at 11:29:30AM -0700, Jason Evans wrote:
>> On Apr 10, 2012, at 6:11 AM, Mike Hommey wrote:
>>> From: Mike Hommey <mh at glandium.org>
>>> 
>>> OUT and ERROR are defined under mingw.
>> 
>> This is a bit like treading a minefield.  I'm inclined to prefix all
>> labels with JEMALLOC_LABEL_ to make sure the issue doesn't come up
>> again.  What do you think?
> 
> Another approach would be to use lowercase names. They'd be less likely
> to be defined as macros.

Good idea.  I just committed a change from FOO to label_foo.  Plain foo wouldn't have worked for RETURN.

Thanks,
Jason

From amolpise15 at gmail.com  Wed Apr 11 02:32:07 2012
From: amolpise15 at gmail.com (amol pise)
Date: Wed, 11 Apr 2012 15:02:07 +0530
Subject: standalone jemalloc is slower than glibc's malloc (ptmalloc)
Message-ID: <CANUf=CD6XnRxiydSqCP1-pUCzB_jGJDp4dCmC9iBxnFjPuWNQA@mail.gmail.com>

Dear All,

I have check the performance of the jemalloc vs glibc's malloc
(ptmalloc) using complex test in libxml2 package
i.e. "runtest". This program allocate many memory of different size
and supported multi-thread.

The results are seen as below:


With glibc's malloc (ptmalloc):
--------------------------------------------

# LD_LIBRARY_PATH=.libs time .libs/runtest
{{{
## XML regression tests
## XML regression tests on memory
:
<snip>
Total 2820 tests, no errors
67.68user 54.96system 2:02.89elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
}}}


With jemalloc:
------------------
# LD_LIBRARY_PATH=.libs LD_PRELOAD=/devel/usr/lib/libjemalloc.so time
.libs/runtest
{{{
## XML regression tests

## XML regression tests on memory

:
<snip>
Total 2820 tests, no errors
76.89user 55.70system 2:12.72elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (0major+0minor)pagefaults 0swaps
}}}

Here it is observed jemalloc seems slowers than glibc malloc (ptmalloc)


I used jemalloc-2.2.5 from http://www.canonware.com/download/jemalloc/

Is it mean jemalloc() is slower than glibc's malloc ?
Is there any way to improve the speed performance of jemalloc in this regard?

I am waiting for the reply.

Thank You,
Amol Pise


From amolpise15 at gmail.com  Wed Apr 11 04:31:40 2012
From: amolpise15 at gmail.com (amol pise)
Date: Wed, 11 Apr 2012 17:01:40 +0530
Subject: standalone jemalloc is slower than glibc's malloc (ptmalloc)
Message-ID: <CANUf=CBh-9Odtx50G-mrP0rgnsEo7S_BeaYT80k85EyH2L+k1w@mail.gmail.com>

Dear All,

I have check the performance of the jemalloc vs glibc's malloc
(ptmalloc) using complex test in libxml2 package
i.e. "runtest". This program allocate many memory of different size
and supported multi-thread.

The results are seen as below:


With glibc's malloc (ptmalloc):
--------------------------------------------

# LD_LIBRARY_PATH=.libs time .libs/runtest
{{{
## XML regression tests
## XML regression tests on memory
:
<snip>
Total 2820 tests, no errors
67.68user 54.96system 2:02.89elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
}}}


With jemalloc:
------------------
# LD_LIBRARY_PATH=.libs LD_PRELOAD=/devel/usr/lib/libjemalloc.so time
.libs/runtest
{{{
## XML regression tests

## XML regression tests on memory

:
<snip>
Total 2820 tests, no errors
76.89user 55.70system 2:12.72elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (0major+0minor)pagefaults 0swaps
}}}

Here it is observed jemalloc seems slowers than glibc malloc (ptmalloc)


I used jemalloc-2.2.5 from http://www.canonware.com/download/jemalloc/

Is it mean jemalloc() is slower than glibc's malloc ?
Is there any way to improve the speed performance of jemalloc in this regard?

I am waiting for the reply.

Thank You,
Amol Pise


From mh+jemalloc at glandium.org  Wed Apr 11 05:24:16 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 14:24:16 +0200
Subject: [PATCH] Add a chunk_aligned_alloc function handling alignment
	constraints on chunks
In-Reply-To: <66661490-9D63-433D-9686-BED5F7E72FBA@canonware.com>
References: <1334080233-20646-1-git-send-email-mh+jemalloc@glandium.org>
	<20120410175427.GA20755@glandium.org>
	<66661490-9D63-433D-9686-BED5F7E72FBA@canonware.com>
Message-ID: <20120411122416.GA6315@glandium.org>

On Tue, Apr 10, 2012 at 02:59:03PM -0700, Jason Evans wrote:
> On Apr 10, 2012, at 10:54 AM, Mike Hommey wrote:
> > On Tue, Apr 10, 2012 at 07:50:33PM +0200, Mike Hommey wrote:
> >> From: Mike Hommey <mh at glandium.org>
> >> 
> >> ---
> >> include/jemalloc/internal/chunk.h      |   15 ++++++++++-
> >> include/jemalloc/internal/chunk_dss.h  |    2 +-
> >> include/jemalloc/internal/chunk_mmap.h |    2 +-
> >> src/chunk.c                            |    7 ++---
> >> src/chunk_dss.c                        |   46 +++++++++++++++++++-------------
> >> src/chunk_mmap.c                       |   28 +++++++++----------
> >> src/huge.c                             |   33 ++---------------------
> >> 7 files changed, 63 insertions(+), 70 deletions(-)
> > 
> > The reason why I'm interested in this is that the way VirtualAlloc and
> > VirtualFree work on Windows makes it cumbersome to do "huge" alignment,
> > and would require going through hoops and repeating code between huge.c
> > and chunk_mmap.c. It gets simpler if everything is handled in one place.
> > 
> > I'm not sure how to best stress test the changes in chunk_dss.c, so I'm
> > not sure it doesn't break in subtle ways. The changes in chunk_mmap.c
> > are much more straightforward.
> 
> There were problems in the dss code that I had to fix, and I did some
> other refactoring that this change allowed (e.g. huge_malloc() now
> just calls huge_palloc()).  The result is committed now; please let me
> know if you encounter any problems with the changes I made.

It looks good, although I didn't test dss since Windows doesn't have
sbrk. Since I don't think it makes sense to emulate sbrk in jemalloc,
chunk_dss should be completely disabled there. How would you feel about
a patch that doesn't build chunk_dss.c and sets all functions declared in
chunk_dss.h to be dummy inline functions when dss is not enabled? That
would allow to keep the if (config_dss) parts and avoid replacing them
with #ifdefs. Or are you just fine with replacing them with #ifdefs?

> By the way, I'm excited to see hints of Windows support in the works. =)

At this point, I have jemalloc working single-threaded with mingw and
mingw64: the test suite pass, but I have random asserts in the threaded
tests. I haven't implemented tsd and proper mutexes yet.

Mike


From mh+jemalloc at glandium.org  Wed Apr 11 05:27:27 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 14:27:27 +0200
Subject: [PATCH] Replace %z in format strings with configure-time determined
	printf length modifier
Message-ID: <1334147247-10553-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 configure.ac                        |   14 +++++++++
 include/jemalloc/jemalloc_defs.h.in |    8 ++++++
 src/prof.c                          |    2 +-
 src/stats.c                         |   54 +++++++++++++++++------------------
 test/aligned_alloc.c                |   14 ++++-----
 test/allocm.c                       |   22 +++++++-------
 test/mremap.c                       |    6 ++--
 test/posix_memalign.c               |   14 ++++-----
 test/rallocm.c                      |   16 +++++------
 9 files changed, 86 insertions(+), 64 deletions(-)

diff --git a/configure.ac b/configure.ac
index 8e94b5c..d6fa40b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -168,6 +168,20 @@ else
 fi
 AC_DEFINE_UNQUOTED([LG_SIZEOF_INTMAX_T], [$LG_SIZEOF_INTMAX_T])
 
+AC_CHECK_SIZEOF([size_t])
+if test "x${ac_cv_sizeof_size_t}" = "x4" ; then
+  PRI_z=""
+elif test "x${ac_cv_sizeof_size_t}" = "x8" ; then
+  if test "x${ac_cv_sizeof_long}" = "x4" ; then
+    PRI_z="ll"
+  else
+    PRI_z="l"
+  fi
+else
+  AC_MSG_ERROR([Unsupported size_t size: ${ac_cv_sizeof_size_t}])
+fi
+AC_DEFINE_UNQUOTED([PRI_z], ["$PRI_z"])
+
 AC_CANONICAL_HOST
 dnl CPU-specific settings.
 CPU_SPINWAIT=""
diff --git a/include/jemalloc/jemalloc_defs.h.in b/include/jemalloc/jemalloc_defs.h.in
index 8e7442d..5bfd7fa 100644
--- a/include/jemalloc/jemalloc_defs.h.in
+++ b/include/jemalloc/jemalloc_defs.h.in
@@ -215,3 +215,11 @@
 
 /* sizeof(intmax_t) == 2^LG_SIZEOF_INTMAX_T. */
 #undef LG_SIZEOF_INTMAX_T
+
+/* Length modifier to use in printf for size_t */
+#undef PRI_z
+
+/* Macros similar to inttypes.h's PRI* macros, for size_t */
+#define PRIuz PRI_z "u"
+#define PRIdz PRI_z "d"
+#define PRIxz PRI_z "x"
diff --git a/src/prof.c b/src/prof.c
index b509aae..7fa228e 100644
--- a/src/prof.c
+++ b/src/prof.c
@@ -899,7 +899,7 @@ prof_dump(bool propagate_err, const char *filename, bool leakcheck)
 
 	if (leakcheck && cnt_all.curbytes != 0) {
 		malloc_printf("<jemalloc>: Leak summary: %"PRId64" byte%s, %"
-		    PRId64" object%s, %zu context%s\n",
+		    PRId64" object%s, %"PRIuz" context%s\n",
 		    cnt_all.curbytes, (cnt_all.curbytes != 1) ? "s" : "",
 		    cnt_all.curobjs, (cnt_all.curobjs != 1) ? "s" : "",
 		    leak_nctx, (leak_nctx != 1) ? "s" : "");
diff --git a/src/stats.c b/src/stats.c
index 0cd70b0..1e73b16 100644
--- a/src/stats.c
+++ b/src/stats.c
@@ -125,18 +125,18 @@ stats_arena_bins_print(void (*write_cb)(void *, const char *), void *cbopaque,
 			    size_t);
 			if (config_tcache) {
 				malloc_cprintf(write_cb, cbopaque,
-				    "%13u %5zu %4u %3zu %12zu %12"PRIu64
+				    "%13u %5"PRIuz" %4u %3"PRIuz" %12"PRIuz" %12"PRIu64
 				    " %12"PRIu64" %12"PRIu64" %12"PRIu64
 				    " %12"PRIu64" %12"PRIu64" %12"PRIu64
-				    " %12zu\n",
+				    " %12"PRIuz"\n",
 				    j, reg_size, nregs, run_size / page,
 				    allocated, nmalloc, ndalloc, nrequests,
 				    nfills, nflushes, nruns, reruns, curruns);
 			} else {
 				malloc_cprintf(write_cb, cbopaque,
-				    "%13u %5zu %4u %3zu %12zu %12"PRIu64
+				    "%13u %5"PRIuz" %4u %3"PRIuz" %12"PRIuz" %12"PRIu64
 				    " %12"PRIu64" %12"PRIu64" %12"PRIu64
-				    " %12zu\n",
+				    " %12"PRIuz"\n",
 				    j, reg_size, nregs, run_size / page,
 				    allocated, nmalloc, ndalloc, nruns, reruns,
 				    curruns);
@@ -186,19 +186,19 @@ stats_arena_lruns_print(void (*write_cb)(void *, const char *), void *cbopaque,
 			CTL_IJ_GET("stats.arenas.0.lruns.0.curruns", &curruns,
 			    size_t);
 			if (gap_start != -1) {
-				malloc_cprintf(write_cb, cbopaque, "[%zu]\n",
+				malloc_cprintf(write_cb, cbopaque, "[%"PRIuz"]\n",
 				    j - gap_start);
 				gap_start = -1;
 			}
 			malloc_cprintf(write_cb, cbopaque,
-			    "%13zu %5zu %12"PRIu64" %12"PRIu64" %12"PRIu64
-			    " %12zu\n",
+			    "%13"PRIuz" %5"PRIuz" %12"PRIu64" %12"PRIu64" %12"PRIu64
+			    " %12"PRIuz"\n",
 			    run_size, run_size / page, nmalloc, ndalloc,
 			    nrequests, curruns);
 		}
 	}
 	if (gap_start != -1)
-		malloc_cprintf(write_cb, cbopaque, "[%zu]\n", j - gap_start);
+		malloc_cprintf(write_cb, cbopaque, "[%"PRIuz"]\n", j - gap_start);
 }
 
 static void
@@ -224,7 +224,7 @@ stats_arena_print(void (*write_cb)(void *, const char *), void *cbopaque,
 	CTL_I_GET("stats.arenas.0.nmadvise", &nmadvise, uint64_t);
 	CTL_I_GET("stats.arenas.0.purged", &purged, uint64_t);
 	malloc_cprintf(write_cb, cbopaque,
-	    "dirty pages: %zu:%zu active:dirty, %"PRIu64" sweep%s,"
+	    "dirty pages: %"PRIuz":%"PRIuz" active:dirty, %"PRIu64" sweep%s,"
 	    " %"PRIu64" madvise%s, %"PRIu64" purged\n",
 	    pactive, pdirty, npurge, npurge == 1 ? "" : "s",
 	    nmadvise, nmadvise == 1 ? "" : "s", purged);
@@ -236,24 +236,24 @@ stats_arena_print(void (*write_cb)(void *, const char *), void *cbopaque,
 	CTL_I_GET("stats.arenas.0.small.ndalloc", &small_ndalloc, uint64_t);
 	CTL_I_GET("stats.arenas.0.small.nrequests", &small_nrequests, uint64_t);
 	malloc_cprintf(write_cb, cbopaque,
-	    "small:   %12zu %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
+	    "small:   %12"PRIuz" %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
 	    small_allocated, small_nmalloc, small_ndalloc, small_nrequests);
 	CTL_I_GET("stats.arenas.0.large.allocated", &large_allocated, size_t);
 	CTL_I_GET("stats.arenas.0.large.nmalloc", &large_nmalloc, uint64_t);
 	CTL_I_GET("stats.arenas.0.large.ndalloc", &large_ndalloc, uint64_t);
 	CTL_I_GET("stats.arenas.0.large.nrequests", &large_nrequests, uint64_t);
 	malloc_cprintf(write_cb, cbopaque,
-	    "large:   %12zu %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
+	    "large:   %12"PRIuz" %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
 	    large_allocated, large_nmalloc, large_ndalloc, large_nrequests);
 	malloc_cprintf(write_cb, cbopaque,
-	    "total:   %12zu %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
+	    "total:   %12"PRIuz" %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
 	    small_allocated + large_allocated,
 	    small_nmalloc + large_nmalloc,
 	    small_ndalloc + large_ndalloc,
 	    small_nrequests + large_nrequests);
-	malloc_cprintf(write_cb, cbopaque, "active:  %12zu\n", pactive * page);
+	malloc_cprintf(write_cb, cbopaque, "active:  %12"PRIuz"\n", pactive * page);
 	CTL_I_GET("stats.arenas.0.mapped", &mapped, size_t);
-	malloc_cprintf(write_cb, cbopaque, "mapped:  %12zu\n", mapped);
+	malloc_cprintf(write_cb, cbopaque, "mapped:  %12"PRIuz"\n", mapped);
 
 	if (bins)
 		stats_arena_bins_print(write_cb, cbopaque, i);
@@ -360,13 +360,13 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 		if ((err = je_mallctl("opt."#n, &sv, &ssz, NULL, 0))	\
 		    == 0) {						\
 			malloc_cprintf(write_cb, cbopaque,		\
-			"  opt."#n": %zu\n", sv);			\
+			"  opt."#n": %"PRIuz"\n", sv);			\
 		}
 #define OPT_WRITE_SSIZE_T(n)						\
 		if ((err = je_mallctl("opt."#n, &ssv, &sssz, NULL, 0))	\
 		    == 0) {						\
 			malloc_cprintf(write_cb, cbopaque,		\
-			    "  opt."#n": %zd\n", ssv);			\
+			    "  opt."#n": %"PRIdz"\n", ssv);			\
 		}
 #define OPT_WRITE_CHAR_P(n)						\
 		if ((err = je_mallctl("opt."#n, &cpv, &cpsz, NULL, 0))	\
@@ -406,14 +406,14 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 		CTL_GET("arenas.narenas", &uv, unsigned);
 		malloc_cprintf(write_cb, cbopaque, "Max arenas: %u\n", uv);
 
-		malloc_cprintf(write_cb, cbopaque, "Pointer size: %zu\n",
+		malloc_cprintf(write_cb, cbopaque, "Pointer size: %"PRIuz"\n",
 		    sizeof(void *));
 
 		CTL_GET("arenas.quantum", &sv, size_t);
-		malloc_cprintf(write_cb, cbopaque, "Quantum size: %zu\n", sv);
+		malloc_cprintf(write_cb, cbopaque, "Quantum size: %"PRIuz"\n", sv);
 
 		CTL_GET("arenas.page", &sv, size_t);
-		malloc_cprintf(write_cb, cbopaque, "Page size: %zu\n", sv);
+		malloc_cprintf(write_cb, cbopaque, "Page size: %"PRIuz"\n", sv);
 
 		CTL_GET("opt.lg_dirty_mult", &ssv, ssize_t);
 		if (ssv >= 0) {
@@ -427,20 +427,20 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 		if ((err = je_mallctl("arenas.tcache_max", &sv, &ssz, NULL, 0))
 		    == 0) {
 			malloc_cprintf(write_cb, cbopaque,
-			    "Maximum thread-cached size class: %zu\n", sv);
+			    "Maximum thread-cached size class: %"PRIuz"\n", sv);
 		}
 		if ((err = je_mallctl("opt.prof", &bv, &bsz, NULL, 0)) == 0 &&
 		    bv) {
 			CTL_GET("opt.lg_prof_sample", &sv, size_t);
 			malloc_cprintf(write_cb, cbopaque,
 			    "Average profile sample interval: %"PRIu64
-			    " (2^%zu)\n", (((uint64_t)1U) << sv), sv);
+			    " (2^%"PRIuz")\n", (((uint64_t)1U) << sv), sv);
 
 			CTL_GET("opt.lg_prof_interval", &ssv, ssize_t);
 			if (ssv >= 0) {
 				malloc_cprintf(write_cb, cbopaque,
 				    "Average profile dump interval: %"PRIu64
-				    " (2^%zd)\n",
+				    " (2^%"PRIdz")\n",
 				    (((uint64_t)1U) << ssv), ssv);
 			} else {
 				write_cb(cbopaque,
@@ -448,7 +448,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 			}
 		}
 		CTL_GET("opt.lg_chunk", &sv, size_t);
-		malloc_cprintf(write_cb, cbopaque, "Chunk size: %zu (2^%zu)\n",
+		malloc_cprintf(write_cb, cbopaque, "Chunk size: %"PRIuz" (2^%"PRIuz")\n",
 		    (ZU(1) << sv), sv);
 	}
 
@@ -465,10 +465,10 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 		CTL_GET("stats.active", &active, size_t);
 		CTL_GET("stats.mapped", &mapped, size_t);
 		malloc_cprintf(write_cb, cbopaque,
-		    "Allocated: %zu, active: %zu, mapped: %zu\n",
+		    "Allocated: %"PRIuz", active: %"PRIuz", mapped: %"PRIuz"\n",
 		    allocated, active, mapped);
 		malloc_cprintf(write_cb, cbopaque,
-		    "Current active ceiling: %zu\n", atomic_read_z(cactive));
+		    "Current active ceiling: %"PRIuz"\n", atomic_read_z(cactive));
 
 		/* Print chunk stats. */
 		CTL_GET("stats.chunks.total", &chunks_total, uint64_t);
@@ -476,7 +476,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 		CTL_GET("stats.chunks.current", &chunks_current, size_t);
 		malloc_cprintf(write_cb, cbopaque, "chunks: nchunks   "
 		    "highchunks    curchunks\n");
-		malloc_cprintf(write_cb, cbopaque, "  %13"PRIu64"%13zu%13zu\n",
+		malloc_cprintf(write_cb, cbopaque, "  %13"PRIu64"%13"PRIuz"%13"PRIuz"\n",
 		    chunks_total, chunks_high, chunks_current);
 
 		/* Print huge stats. */
@@ -486,7 +486,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 		malloc_cprintf(write_cb, cbopaque,
 		    "huge: nmalloc      ndalloc    allocated\n");
 		malloc_cprintf(write_cb, cbopaque,
-		    " %12"PRIu64" %12"PRIu64" %12zu\n",
+		    " %12"PRIu64" %12"PRIu64" %12"PRIuz"\n",
 		    huge_nmalloc, huge_ndalloc, huge_allocated);
 
 		if (merged) {
diff --git a/test/aligned_alloc.c b/test/aligned_alloc.c
index 2a95604..8aa87ca 100644
--- a/test/aligned_alloc.c
+++ b/test/aligned_alloc.c
@@ -28,7 +28,7 @@ main(void)
 	p = aligned_alloc(alignment, 1);
 	if (p != NULL || errno != EINVAL) {
 		fprintf(stderr,
-		    "Expected error for invalid alignment %zu\n", alignment);
+		    "Expected error for invalid alignment %"PRIuz"\n", alignment);
 	}
 
 	for (alignment = sizeof(size_t); alignment < MAXALIGN;
@@ -37,7 +37,7 @@ main(void)
 		p = aligned_alloc(alignment + 1, 1);
 		if (p != NULL || errno != EINVAL) {
 			fprintf(stderr,
-			    "Expected error for invalid alignment %zu\n",
+			    "Expected error for invalid alignment %"PRIuz"\n",
 			    alignment + 1);
 		}
 	}
@@ -53,7 +53,7 @@ main(void)
 	p = aligned_alloc(alignment, size);
 	if (p != NULL || errno != ENOMEM) {
 		fprintf(stderr,
-		    "Expected error for aligned_alloc(%zu, %zu)\n",
+		    "Expected error for aligned_alloc(%"PRIuz", %"PRIuz")\n",
 		    alignment, size);
 	}
 
@@ -68,7 +68,7 @@ main(void)
 	p = aligned_alloc(alignment, size);
 	if (p != NULL || errno != ENOMEM) {
 		fprintf(stderr,
-		    "Expected error for aligned_alloc(%zu, %zu)\n",
+		    "Expected error for aligned_alloc(%"PRIuz", %"PRIuz")\n",
 		    alignment, size);
 	}
 
@@ -82,7 +82,7 @@ main(void)
 	p = aligned_alloc(alignment, size);
 	if (p != NULL || errno != ENOMEM) {
 		fprintf(stderr,
-		    "Expected error for aligned_alloc(&p, %zu, %zu)\n",
+		    "Expected error for aligned_alloc(&p, %"PRIuz", %"PRIuz")\n",
 		    alignment, size);
 	}
 
@@ -93,7 +93,7 @@ main(void)
 	    alignment <= MAXALIGN;
 	    alignment <<= 1) {
 		total = 0;
-		fprintf(stderr, "Alignment: %zu\n", alignment);
+		fprintf(stderr, "Alignment: %"PRIuz"\n", alignment);
 		for (size = 1;
 		    size < 3 * alignment && size < (1U << 31);
 		    size += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
@@ -101,7 +101,7 @@ main(void)
 				ps[i] = aligned_alloc(alignment, size);
 				if (ps[i] == NULL) {
 					fprintf(stderr,
-					    "Error for size %zu (%#zx): %s\n",
+					    "Error for size %"PRIuz" (%#"PRIxz"): %s\n",
 					    size, size, strerror(errno));
 					exit(1);
 				}
diff --git a/test/allocm.c b/test/allocm.c
index 3aa0fd2..4f8b908 100644
--- a/test/allocm.c
+++ b/test/allocm.c
@@ -77,14 +77,14 @@ main(void)
 	r = nallocm(&nsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
 		fprintf(stderr,
-		    "Expected error for nallocm(&nsz, %zu, %#x)\n",
+		    "Expected error for nallocm(&nsz, %"PRIuz", %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	rsz = 0;
 	r = allocm(&p, &rsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
 		fprintf(stderr,
-		    "Expected error for allocm(&p, %zu, %#x)\n",
+		    "Expected error for allocm(&p, %"PRIuz", %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	if (nsz != rsz)
@@ -105,7 +105,7 @@ main(void)
 	r = allocm(&p, &rsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
 		fprintf(stderr,
-		    "Expected error for allocm(&p, %zu, %#x)\n",
+		    "Expected error for allocm(&p, %"PRIuz", %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 
@@ -119,14 +119,14 @@ main(void)
 	r = nallocm(&nsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
 		fprintf(stderr,
-		    "Expected error for nallocm(&nsz, %zu, %#x)\n",
+		    "Expected error for nallocm(&nsz, %"PRIuz", %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	rsz = 0;
 	r = allocm(&p, &rsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
 		fprintf(stderr,
-		    "Expected error for allocm(&p, %zu, %#x)\n",
+		    "Expected error for allocm(&p, %"PRIuz", %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	if (nsz != rsz)
@@ -139,7 +139,7 @@ main(void)
 	    alignment <= MAXALIGN;
 	    alignment <<= 1) {
 		total = 0;
-		fprintf(stderr, "Alignment: %zu\n", alignment);
+		fprintf(stderr, "Alignment: %"PRIuz"\n", alignment);
 		for (sz = 1;
 		    sz < 3 * alignment && sz < (1U << 31);
 		    sz += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
@@ -149,8 +149,8 @@ main(void)
 				    ALLOCM_ALIGN(alignment) | ALLOCM_ZERO);
 				if (r != ALLOCM_SUCCESS) {
 					fprintf(stderr,
-					    "nallocm() error for size %zu"
-					    " (%#zx): %d\n",
+					    "nallocm() error for size %"PRIuz""
+					    " (%#"PRIxz"): %d\n",
 					    sz, sz, r);
 					exit(1);
 				}
@@ -159,8 +159,8 @@ main(void)
 				    ALLOCM_ALIGN(alignment) | ALLOCM_ZERO);
 				if (r != ALLOCM_SUCCESS) {
 					fprintf(stderr,
-					    "allocm() error for size %zu"
-					    " (%#zx): %d\n",
+					    "allocm() error for size %"PRIuz""
+					    " (%#"PRIxz"): %d\n",
 					    sz, sz, r);
 					exit(1);
 				}
@@ -177,7 +177,7 @@ main(void)
 				if ((uintptr_t)p & (alignment-1)) {
 					fprintf(stderr,
 					    "%p inadequately aligned for"
-					    " alignment: %zu\n", p, alignment);
+					    " alignment: %"PRIuz"\n", p, alignment);
 				}
 				sallocm(ps[i], &rsz, 0);
 				total += rsz;
diff --git a/test/mremap.c b/test/mremap.c
index cac3bd8..969fc77 100644
--- a/test/mremap.c
+++ b/test/mremap.c
@@ -28,7 +28,7 @@ main(void)
 
 	p = (char *)malloc(chunksize);
 	if (p == NULL) {
-		fprintf(stderr, "malloc(%zu) --> %p\n", chunksize, p);
+		fprintf(stderr, "malloc(%"PRIuz") --> %p\n", chunksize, p);
 		ret = 1;
 		goto label_return;
 	}
@@ -36,7 +36,7 @@ main(void)
 
 	q = (char *)realloc(p, chunksize * 2);
 	if (q == NULL) {
-		fprintf(stderr, "realloc(%p, %zu) --> %p\n", p, chunksize * 2,
+		fprintf(stderr, "realloc(%p, %"PRIuz") --> %p\n", p, chunksize * 2,
 		    q);
 		ret = 1;
 		goto label_return;
@@ -49,7 +49,7 @@ main(void)
 
 	q = (char *)realloc(p, chunksize);
 	if (q == NULL) {
-		fprintf(stderr, "realloc(%p, %zu) --> %p\n", p, chunksize, q);
+		fprintf(stderr, "realloc(%p, %"PRIuz") --> %p\n", p, chunksize, q);
 		ret = 1;
 		goto label_return;
 	}
diff --git a/test/posix_memalign.c b/test/posix_memalign.c
index 0ea35c8..f096fd2 100644
--- a/test/posix_memalign.c
+++ b/test/posix_memalign.c
@@ -28,7 +28,7 @@ main(void)
 		err = posix_memalign(&p, alignment, 1);
 		if (err != EINVAL) {
 			fprintf(stderr,
-			    "Expected error for invalid alignment %zu\n",
+			    "Expected error for invalid alignment %"PRIuz"\n",
 			    alignment);
 		}
 	}
@@ -38,7 +38,7 @@ main(void)
 		err = posix_memalign(&p, alignment + 1, 1);
 		if (err == 0) {
 			fprintf(stderr,
-			    "Expected error for invalid alignment %zu\n",
+			    "Expected error for invalid alignment %"PRIuz"\n",
 			    alignment + 1);
 		}
 	}
@@ -53,7 +53,7 @@ main(void)
 	err = posix_memalign(&p, alignment, size);
 	if (err == 0) {
 		fprintf(stderr,
-		    "Expected error for posix_memalign(&p, %zu, %zu)\n",
+		    "Expected error for posix_memalign(&p, %"PRIuz", %"PRIuz")\n",
 		    alignment, size);
 	}
 
@@ -67,7 +67,7 @@ main(void)
 	err = posix_memalign(&p, alignment, size);
 	if (err == 0) {
 		fprintf(stderr,
-		    "Expected error for posix_memalign(&p, %zu, %zu)\n",
+		    "Expected error for posix_memalign(&p, %"PRIuz", %"PRIuz")\n",
 		    alignment, size);
 	}
 
@@ -80,7 +80,7 @@ main(void)
 	err = posix_memalign(&p, alignment, size);
 	if (err == 0) {
 		fprintf(stderr,
-		    "Expected error for posix_memalign(&p, %zu, %zu)\n",
+		    "Expected error for posix_memalign(&p, %"PRIuz", %"PRIuz")\n",
 		    alignment, size);
 	}
 
@@ -91,7 +91,7 @@ main(void)
 	    alignment <= MAXALIGN;
 	    alignment <<= 1) {
 		total = 0;
-		fprintf(stderr, "Alignment: %zu\n", alignment);
+		fprintf(stderr, "Alignment: %"PRIuz"\n", alignment);
 		for (size = 1;
 		    size < 3 * alignment && size < (1U << 31);
 		    size += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
@@ -100,7 +100,7 @@ main(void)
 				    alignment, size);
 				if (err) {
 					fprintf(stderr,
-					    "Error for size %zu (%#zx): %s\n",
+					    "Error for size %"PRIuz" (%#"PRIxz"): %s\n",
 					    size, size, strerror(err));
 					exit(1);
 				}
diff --git a/test/rallocm.c b/test/rallocm.c
index 9c0df40..6d5a939 100644
--- a/test/rallocm.c
+++ b/test/rallocm.c
@@ -37,7 +37,7 @@ main(void)
 	if (q != p)
 		fprintf(stderr, "Unexpected object move\n");
 	if (tsz != sz) {
-		fprintf(stderr, "Unexpected size change: %zu --> %zu\n",
+		fprintf(stderr, "Unexpected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 
@@ -48,7 +48,7 @@ main(void)
 	if (q != p)
 		fprintf(stderr, "Unexpected object move\n");
 	if (tsz != sz) {
-		fprintf(stderr, "Unexpected size change: %zu --> %zu\n",
+		fprintf(stderr, "Unexpected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 
@@ -59,7 +59,7 @@ main(void)
 	if (q != p)
 		fprintf(stderr, "Unexpected object move\n");
 	if (tsz != sz) {
-		fprintf(stderr, "Unexpected size change: %zu --> %zu\n",
+		fprintf(stderr, "Unexpected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 
@@ -70,7 +70,7 @@ main(void)
 	if (q == p)
 		fprintf(stderr, "Expected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		fprintf(stderr, "Expected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 	p = q;
@@ -82,7 +82,7 @@ main(void)
 	if (q == p)
 		fprintf(stderr, "Expected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		fprintf(stderr, "Expected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 	p = q;
@@ -92,7 +92,7 @@ main(void)
 	if (r != ALLOCM_SUCCESS)
 		fprintf(stderr, "Unexpected rallocm() error\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		fprintf(stderr, "Expected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 	p = q;
@@ -104,7 +104,7 @@ main(void)
 	if (q != p)
 		fprintf(stderr, "Unexpected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		fprintf(stderr, "Expected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 	sz = tsz;
@@ -115,7 +115,7 @@ main(void)
 	if (q != p)
 		fprintf(stderr, "Unexpected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		fprintf(stderr, "Expected size change: %"PRIuz" --> %"PRIuz"\n",
 		    sz, tsz);
 	}
 	sz = tsz;
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Wed Apr 11 05:33:24 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 14:33:24 +0200
Subject: [PATCH] Replace %z in format strings with configure-time
	determined printf length modifier
In-Reply-To: <1334147247-10553-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334147247-10553-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <20120411123324.GA10626@glandium.org>

On Wed, Apr 11, 2012 at 02:27:27PM +0200, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> ---
>  configure.ac                        |   14 +++++++++
>  include/jemalloc/jemalloc_defs.h.in |    8 ++++++
>  src/prof.c                          |    2 +-
>  src/stats.c                         |   54 +++++++++++++++++------------------
>  test/aligned_alloc.c                |   14 ++++-----
>  test/allocm.c                       |   22 +++++++-------
>  test/mremap.c                       |    6 ++--
>  test/posix_memalign.c               |   14 ++++-----
>  test/rallocm.c                      |   16 +++++------
>  9 files changed, 86 insertions(+), 64 deletions(-)

Disclaimer: no effort has been made to wrap strings. It's merely the
result of a big sed (plus configure and preprocessed header glue).

Note that this leads to compiler warnings with mingw64 (warning: unknown
conversion type character 'l' in format [-Wformat]), but I suspect this
is a bug in mingw64 (and as a matter of fact, the resulting printfs do
the right thing ; fwiw, I sent a message on the mingw64 list, but it's
awaiting moderation). MSVC is happy with %llu, too.

The defines in jemalloc_defs.h mimic inttypes.h PRI* macros.

Mike


From jasone at canonware.com  Wed Apr 11 09:42:33 2012
From: jasone at canonware.com (Jason Evans)
Date: Wed, 11 Apr 2012 09:42:33 -0700
Subject: [PATCH] Replace %z in format strings with configure-time
	determined printf length modifier
In-Reply-To: <20120411123324.GA10626@glandium.org>
References: <1334147247-10553-1-git-send-email-mh+jemalloc@glandium.org>
	<20120411123324.GA10626@glandium.org>
Message-ID: <F7497FD0-754A-47EB-BBF6-3FD7DDA9EC9C@canonware.com>

On Apr 11, 2012, at 5:33 AM, Mike Hommey wrote:
> On Wed, Apr 11, 2012 at 02:27:27PM +0200, Mike Hommey wrote:
>> From: Mike Hommey <mh at glandium.org>
>> 
>> ---
>> configure.ac                        |   14 +++++++++
>> include/jemalloc/jemalloc_defs.h.in |    8 ++++++
>> src/prof.c                          |    2 +-
>> src/stats.c                         |   54 +++++++++++++++++------------------
>> test/aligned_alloc.c                |   14 ++++-----
>> test/allocm.c                       |   22 +++++++-------
>> test/mremap.c                       |    6 ++--
>> test/posix_memalign.c               |   14 ++++-----
>> test/rallocm.c                      |   16 +++++------
>> 9 files changed, 86 insertions(+), 64 deletions(-)
> 
> Disclaimer: no effort has been made to wrap strings. It's merely the
> result of a big sed (plus configure and preprocessed header glue).
> 
> Note that this leads to compiler warnings with mingw64 (warning: unknown
> conversion type character 'l' in format [-Wformat]), but I suspect this
> is a bug in mingw64 (and as a matter of fact, the resulting printfs do
> the right thing ; fwiw, I sent a message on the mingw64 list, but it's
> awaiting moderation). MSVC is happy with %llu, too.
> 
> The defines in jemalloc_defs.h mimic inttypes.h PRI* macros.

What problem is this trying to solve?  Is it purely a matter of compiler warnings due to lack of the 'z' modifier on Windows?  If so, how about we just conditionally remove the format attributes on malloc_{sn,c,}printf() to silence the warnings?

Thanks,
Jason

From mh+jemalloc at glandium.org  Wed Apr 11 09:57:42 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 18:57:42 +0200
Subject: [PATCH] Replace %z in format strings with configure-time
	determined printf length modifier
In-Reply-To: <F7497FD0-754A-47EB-BBF6-3FD7DDA9EC9C@canonware.com>
References: <1334147247-10553-1-git-send-email-mh+jemalloc@glandium.org>
	<20120411123324.GA10626@glandium.org>
	<F7497FD0-754A-47EB-BBF6-3FD7DDA9EC9C@canonware.com>
Message-ID: <20120411165742.GA4583@glandium.org>

On Wed, Apr 11, 2012 at 09:42:33AM -0700, Jason Evans wrote:
> On Apr 11, 2012, at 5:33 AM, Mike Hommey wrote:
> > On Wed, Apr 11, 2012 at 02:27:27PM +0200, Mike Hommey wrote:
> >> From: Mike Hommey <mh at glandium.org>
> >> 
> >> ---
> >> configure.ac                        |   14 +++++++++
> >> include/jemalloc/jemalloc_defs.h.in |    8 ++++++
> >> src/prof.c                          |    2 +-
> >> src/stats.c                         |   54 +++++++++++++++++------------------
> >> test/aligned_alloc.c                |   14 ++++-----
> >> test/allocm.c                       |   22 +++++++-------
> >> test/mremap.c                       |    6 ++--
> >> test/posix_memalign.c               |   14 ++++-----
> >> test/rallocm.c                      |   16 +++++------
> >> 9 files changed, 86 insertions(+), 64 deletions(-)
> > 
> > Disclaimer: no effort has been made to wrap strings. It's merely the
> > result of a big sed (plus configure and preprocessed header glue).
> > 
> > Note that this leads to compiler warnings with mingw64 (warning: unknown
> > conversion type character 'l' in format [-Wformat]), but I suspect this
> > is a bug in mingw64 (and as a matter of fact, the resulting printfs do
> > the right thing ; fwiw, I sent a message on the mingw64 list, but it's
> > awaiting moderation). MSVC is happy with %llu, too.
> > 
> > The defines in jemalloc_defs.h mimic inttypes.h PRI* macros.
> 
> What problem is this trying to solve?  Is it purely a matter of
> compiler warnings due to lack of the 'z' modifier on Windows?  If so,
> how about we just conditionally remove the format attributes on
> malloc_{sn,c,}printf() to silence the warnings?

I guess that would work for malloc_{sn,c,}printf(), but not for the
plain fprintfs in tests...

Mike


From mh+jemalloc at glandium.org  Wed Apr 11 10:22:56 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 19:22:56 +0200
Subject: Making sense of TSD
Message-ID: <20120411172256.GB4583@glandium.org>

Hi,

I'm trying to make sense of the tsd implementation without __thread,
which would seem to fit the tls model on windows. But I don't see why
the wrapper struct is needed at all. The first thing that bothers me is
that the isstatic == true case is set to abort on opt_abort, yet is
supported. And it doesn't seem very obvious why initialized is needed.

Jason, could you enlighten me? :)

Mike


From jasone at canonware.com  Wed Apr 11 12:05:05 2012
From: jasone at canonware.com (Jason Evans)
Date: Wed, 11 Apr 2012 12:05:05 -0700
Subject: Making sense of TSD
In-Reply-To: <20120411172256.GB4583@glandium.org>
References: <20120411172256.GB4583@glandium.org>
Message-ID: <385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>

On Apr 11, 2012, at 10:22 AM, Mike Hommey wrote:
> I'm trying to make sense of the tsd implementation without __thread,
> which would seem to fit the tls model on windows. But I don't see why
> the wrapper struct is needed at all. The first thing that bothers me is
> that the isstatic == true case is set to abort on opt_abort, yet is
> supported. And it doesn't seem very obvious why initialized is needed.

The wrapper struct is needed with pthreads TSD because pthread_[gs]etspecific() only operate on (void *) pointers.  Thus it's impossible to store more than a pointer-sized item with pthreads TSD unless that pointer refers to an allocated structure.  I don't remember the details of Windows's TLS/TSD API; if it can store any type/structure, then no wrapper struct is needed.

Jason

From mh+jemalloc at glandium.org  Wed Apr 11 12:08:42 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 21:08:42 +0200
Subject: Making sense of TSD
In-Reply-To: <385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>
References: <20120411172256.GB4583@glandium.org>
	<385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>
Message-ID: <20120411190842.GA8404@glandium.org>

On Wed, Apr 11, 2012 at 12:05:05PM -0700, Jason Evans wrote:
> On Apr 11, 2012, at 10:22 AM, Mike Hommey wrote:
> > I'm trying to make sense of the tsd implementation without __thread,
> > which would seem to fit the tls model on windows. But I don't see
> > why the wrapper struct is needed at all. The first thing that
> > bothers me is that the isstatic == true case is set to abort on
> > opt_abort, yet is supported. And it doesn't seem very obvious why
> > initialized is needed.
> 
> The wrapper struct is needed with pthreads TSD because
> pthread_[gs]etspecific() only operate on (void *) pointers.  Thus it's
> impossible to store more than a pointer-sized item with pthreads TSD
> unless that pointer refers to an allocated structure.  I don't
> remember the details of Windows's TLS/TSD API; if it can store any
> type/structure, then no wrapper struct is needed.

Well, the void* pointer could just point to whatever structure you want
to store, instead of having a struct containing two bools which
usefulness I'm doubtful about, and a pointer to that allocated structure.
At least it seems so. That was my question.

Mike


From mh+jemalloc at glandium.org  Wed Apr 11 12:12:29 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 21:12:29 +0200
Subject: Making sense of TSD
In-Reply-To: <20120411190842.GA8404@glandium.org>
References: <20120411172256.GB4583@glandium.org>
	<385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>
	<20120411190842.GA8404@glandium.org>
Message-ID: <20120411191229.GA8502@glandium.org>

On Wed, Apr 11, 2012 at 09:08:42PM +0200, Mike Hommey wrote:
> On Wed, Apr 11, 2012 at 12:05:05PM -0700, Jason Evans wrote:
> > On Apr 11, 2012, at 10:22 AM, Mike Hommey wrote:
> > > I'm trying to make sense of the tsd implementation without __thread,
> > > which would seem to fit the tls model on windows. But I don't see
> > > why the wrapper struct is needed at all. The first thing that
> > > bothers me is that the isstatic == true case is set to abort on
> > > opt_abort, yet is supported. And it doesn't seem very obvious why
> > > initialized is needed.
> > 
> > The wrapper struct is needed with pthreads TSD because
> > pthread_[gs]etspecific() only operate on (void *) pointers.  Thus it's
> > impossible to store more than a pointer-sized item with pthreads TSD
> > unless that pointer refers to an allocated structure.  I don't
> > remember the details of Windows's TLS/TSD API; if it can store any
> > type/structure, then no wrapper struct is needed.
> 
> Well, the void* pointer could just point to whatever structure you want
> to store, instead of having a struct containing two bools which
> usefulness I'm doubtful about, and a pointer to that allocated structure.
> At least it seems so. That was my question.

In fact, I don't see why it needs to be so different from the
JEMALLOC_TLS implementation, in which the tls variable is just a
shortcut to avoid using pthread_getspecific for each tsd_get. But maybe
I'm missing something.

Mike


From mh+jemalloc at glandium.org  Wed Apr 11 12:15:33 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 21:15:33 +0200
Subject: Making sense of TSD
In-Reply-To: <20120411191229.GA8502@glandium.org>
References: <20120411172256.GB4583@glandium.org>
	<385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>
	<20120411190842.GA8404@glandium.org>
	<20120411191229.GA8502@glandium.org>
Message-ID: <20120411191533.GA8620@glandium.org>

On Wed, Apr 11, 2012 at 09:12:29PM +0200, Mike Hommey wrote:
> On Wed, Apr 11, 2012 at 09:08:42PM +0200, Mike Hommey wrote:
> > On Wed, Apr 11, 2012 at 12:05:05PM -0700, Jason Evans wrote:
> > > On Apr 11, 2012, at 10:22 AM, Mike Hommey wrote:
> > > > I'm trying to make sense of the tsd implementation without __thread,
> > > > which would seem to fit the tls model on windows. But I don't see
> > > > why the wrapper struct is needed at all. The first thing that
> > > > bothers me is that the isstatic == true case is set to abort on
> > > > opt_abort, yet is supported. And it doesn't seem very obvious why
> > > > initialized is needed.
> > > 
> > > The wrapper struct is needed with pthreads TSD because
> > > pthread_[gs]etspecific() only operate on (void *) pointers.  Thus it's
> > > impossible to store more than a pointer-sized item with pthreads TSD
> > > unless that pointer refers to an allocated structure.  I don't
> > > remember the details of Windows's TLS/TSD API; if it can store any
> > > type/structure, then no wrapper struct is needed.
> > 
> > Well, the void* pointer could just point to whatever structure you want
> > to store, instead of having a struct containing two bools which
> > usefulness I'm doubtful about, and a pointer to that allocated structure.
> > At least it seems so. That was my question.
> 
> In fact, I don't see why it needs to be so different from the
> JEMALLOC_TLS implementation, in which the tls variable is just a
> shortcut to avoid using pthread_getspecific for each tsd_get. But maybe
> I'm missing something.

(and allocated at thread creation, but that's not really a problem)

Mike

PS: Sorry for the mail flood.


From jasone at canonware.com  Wed Apr 11 12:15:37 2012
From: jasone at canonware.com (Jason Evans)
Date: Wed, 11 Apr 2012 12:15:37 -0700
Subject: Making sense of TSD
In-Reply-To: <20120411190842.GA8404@glandium.org>
References: <20120411172256.GB4583@glandium.org>
	<385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>
	<20120411190842.GA8404@glandium.org>
Message-ID: <6FA18E5F-CB34-4EA6-8268-E318F2CF4336@canonware.com>


On Apr 11, 2012, at 12:08 PM, Mike Hommey wrote:

> On Wed, Apr 11, 2012 at 12:05:05PM -0700, Jason Evans wrote:
>> On Apr 11, 2012, at 10:22 AM, Mike Hommey wrote:
>>> I'm trying to make sense of the tsd implementation without __thread,
>>> which would seem to fit the tls model on windows. But I don't see
>>> why the wrapper struct is needed at all. The first thing that
>>> bothers me is that the isstatic == true case is set to abort on
>>> opt_abort, yet is supported. And it doesn't seem very obvious why
>>> initialized is needed.
>> 
>> The wrapper struct is needed with pthreads TSD because
>> pthread_[gs]etspecific() only operate on (void *) pointers.  Thus it's
>> impossible to store more than a pointer-sized item with pthreads TSD
>> unless that pointer refers to an allocated structure.  I don't
>> remember the details of Windows's TLS/TSD API; if it can store any
>> type/structure, then no wrapper struct is needed.
> 
> Well, the void* pointer could just point to whatever structure you want
> to store, instead of having a struct containing two bools which
> usefulness I'm doubtful about, and a pointer to that allocated structure.
> At least it seems so. That was my question.

The utility of isstatic could be argued, but the initialized flag is critical to how cleanup handlers work.  Yes, these two flags could be separate TSD keys (with all the requisite bool<-->(void *) casting), but the actual data being stored has to be allocated anyway, so this is IMO a cleaner solution.  If Windows supports arbitrary types in a similar fashion to __thread, then the wrapper structure certainly isn't needed, since the flags can be separate keys.

Jason

From mh+jemalloc at glandium.org  Wed Apr 11 12:22:47 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 11 Apr 2012 21:22:47 +0200
Subject: Making sense of TSD
In-Reply-To: <6FA18E5F-CB34-4EA6-8268-E318F2CF4336@canonware.com>
References: <20120411172256.GB4583@glandium.org>
	<385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>
	<20120411190842.GA8404@glandium.org>
	<6FA18E5F-CB34-4EA6-8268-E318F2CF4336@canonware.com>
Message-ID: <20120411192247.GA8718@glandium.org>

On Wed, Apr 11, 2012 at 12:15:37PM -0700, Jason Evans wrote:
> 
> On Apr 11, 2012, at 12:08 PM, Mike Hommey wrote:
> 
> > On Wed, Apr 11, 2012 at 12:05:05PM -0700, Jason Evans wrote:
> >> On Apr 11, 2012, at 10:22 AM, Mike Hommey wrote:
> >>> I'm trying to make sense of the tsd implementation without
> >>> __thread, which would seem to fit the tls model on windows. But I
> >>> don't see why the wrapper struct is needed at all. The first thing
> >>> that bothers me is that the isstatic == true case is set to abort
> >>> on opt_abort, yet is supported. And it doesn't seem very obvious
> >>> why initialized is needed.
> >> 
> >> The wrapper struct is needed with pthreads TSD because
> >> pthread_[gs]etspecific() only operate on (void *) pointers.  Thus
> >> it's impossible to store more than a pointer-sized item with
> >> pthreads TSD unless that pointer refers to an allocated structure.
> >> I don't remember the details of Windows's TLS/TSD API; if it can
> >> store any type/structure, then no wrapper struct is needed.
> > 
> > Well, the void* pointer could just point to whatever structure you
> > want to store, instead of having a struct containing two bools which
> > usefulness I'm doubtful about, and a pointer to that allocated
> > structure.  At least it seems so. That was my question.
> 
> The utility of isstatic could be argued, but the initialized flag is
> critical to how cleanup handlers work.  Yes, these two flags could be
> separate TSD keys (with all the requisite bool<-->(void *) casting),
> but the actual data being stored has to be allocated anyway, so this
> is IMO a cleaner solution.  If Windows supports arbitrary types in a
> similar fashion to __thread, then the wrapper structure certainly
> isn't needed, since the flags can be separate keys.

I must be missing something, because I still don't see how initialized
is any useful. When a thread is created, the specific data value
associated with the key is null and the destructor/cleanup is not
called. Until a value is actually set with setspecific.

Also, come to think of it, I don't even see how that static business
works: while the wrapper data is allocated on heap, the actual type data
is allocated statically, and that will be shared across threads. So in
practice, this means all threads are going to share the same data, and
cross-overwrite it.

Mike


From jasone at canonware.com  Wed Apr 11 20:20:11 2012
From: jasone at canonware.com (Jason Evans)
Date: Wed, 11 Apr 2012 20:20:11 -0700
Subject: [PATCH] Add a chunk_aligned_alloc function handling alignment
	constraints on chunks
In-Reply-To: <20120411122416.GA6315@glandium.org>
References: <1334080233-20646-1-git-send-email-mh+jemalloc@glandium.org>
	<20120410175427.GA20755@glandium.org>
	<66661490-9D63-433D-9686-BED5F7E72FBA@canonware.com>
	<20120411122416.GA6315@glandium.org>
Message-ID: <BCDBFDDA-7BF1-48E5-96D6-72FDB4110610@canonware.com>

On Apr 11, 2012, at 5:24 AM, Mike Hommey wrote:
> Since I don't think it makes sense to emulate sbrk in jemalloc,
> chunk_dss should be completely disabled there. How would you feel about
> a patch that doesn't build chunk_dss.c and sets all functions declared in
> chunk_dss.h to be dummy inline functions when dss is not enabled? That
> would allow to keep the if (config_dss) parts and avoid replacing them
> with #ifdefs. Or are you just fine with replacing them with #ifdefs?

I'd like to avoid conditional compilation as much as possible, in order to reduce the frequency of regressions that break compilation for an obscure combination of configuration options.  One way of minimizing the impact might be to detect the presence of sbrk(), create a stub replacement (with a not_implemented() body)  if it's missing, and force config_dss to false.

Jason

From mh+jemalloc at glandium.org  Thu Apr 12 00:44:09 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 09:44:09 +0200
Subject: Making sense of TSD
In-Reply-To: <20120411192247.GA8718@glandium.org>
References: <20120411172256.GB4583@glandium.org>
	<385CC8F2-24DC-4C95-B097-1C6744755792@canonware.com>
	<20120411190842.GA8404@glandium.org>
	<6FA18E5F-CB34-4EA6-8268-E318F2CF4336@canonware.com>
	<20120411192247.GA8718@glandium.org>
Message-ID: <20120412074409.GA18120@glandium.org>

On Wed, Apr 11, 2012 at 09:22:47PM +0200, Mike Hommey wrote:
> On Wed, Apr 11, 2012 at 12:15:37PM -0700, Jason Evans wrote:
> > 
> > On Apr 11, 2012, at 12:08 PM, Mike Hommey wrote:
> > 
> > > On Wed, Apr 11, 2012 at 12:05:05PM -0700, Jason Evans wrote:
> > >> On Apr 11, 2012, at 10:22 AM, Mike Hommey wrote:
> > >>> I'm trying to make sense of the tsd implementation without
> > >>> __thread, which would seem to fit the tls model on windows. But I
> > >>> don't see why the wrapper struct is needed at all. The first thing
> > >>> that bothers me is that the isstatic == true case is set to abort
> > >>> on opt_abort, yet is supported. And it doesn't seem very obvious
> > >>> why initialized is needed.
> > >> 
> > >> The wrapper struct is needed with pthreads TSD because
> > >> pthread_[gs]etspecific() only operate on (void *) pointers.  Thus
> > >> it's impossible to store more than a pointer-sized item with
> > >> pthreads TSD unless that pointer refers to an allocated structure.
> > >> I don't remember the details of Windows's TLS/TSD API; if it can
> > >> store any type/structure, then no wrapper struct is needed.
> > > 
> > > Well, the void* pointer could just point to whatever structure you
> > > want to store, instead of having a struct containing two bools which
> > > usefulness I'm doubtful about, and a pointer to that allocated
> > > structure.  At least it seems so. That was my question.
> > 
> > The utility of isstatic could be argued, but the initialized flag is
> > critical to how cleanup handlers work.  Yes, these two flags could be
> > separate TSD keys (with all the requisite bool<-->(void *) casting),
> > but the actual data being stored has to be allocated anyway, so this
> > is IMO a cleaner solution.  If Windows supports arbitrary types in a
> > similar fashion to __thread, then the wrapper structure certainly
> > isn't needed, since the flags can be separate keys.
> 
> I must be missing something, because I still don't see how initialized
> is any useful. When a thread is created, the specific data value
> associated with the key is null and the destructor/cleanup is not
> called. Until a value is actually set with setspecific.
> 
> Also, come to think of it, I don't even see how that static business
> works: while the wrapper data is allocated on heap, the actual type data
> is allocated statically, and that will be shared across threads. So in
> practice, this means all threads are going to share the same data, and
> cross-overwrite it.

Reading preprocessed code makes it clearer: the "static" is mostly useless
in that branch, and can be removed without any change in functionality.
Doing so also saves some bss space.

I also tested modifying the code as follows (getting completely rid of the
wrappers), and it seems to work (although it's missing failure paths):

a_name##_tsd_boot(void)							\
{									\
	if (pthread_key_create(&a_name##_tsd,				\
	    a_cleanup) != 0)						\
		return (true);						\
	a_name##_booted = true;						\
	return (false);							\
}									\
									\
a_attr a_type *								\
a_name##_tsd_get(void)							\
{									\
	a_type *value = (a_type *) pthread_getspecific(a_name##_tsd);	\
	if (value == NULL) {						\
		a_type tsd_init_data = a_initializer;			\
		value = (a_type *) malloc_tsd_malloc(sizeof(a_type));	\
		*value = tsd_init_data;					\
		pthread_setspecific(a_name##_tsd, (void *)value);	\
	}								\
	return value;							\
}									\
a_attr void								\
a_name##_tsd_set(a_type *val)						\
{									\
	a_type *value = a_name##_tsd_get();				\
	*value = *(val);						\
}

FWIW, Win32's TlsAlloc and TlsGetValue/TlsSetValue basically work as
respectively pthread_key_create, pthread_getspecific and
pthread_setspecific, except there is no destructor function.
function. This means we need some way to enumerate the tsd values and
cleanup functions to run them. Any preference on how to do that? I'm
thinking about using a separate section to store pointers to the tsd
variables, so that the linker would do the work, instead of having to
create a list somewhere in the source. Another possibility I can see
is to group all tsd definitions.

Cheers,

Mike


From mh+jemalloc at glandium.org  Thu Apr 12 01:13:03 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 10:13:03 +0200
Subject: [PATCH] Use a stub replacement and disable dss when sbrk is not
	supported
In-Reply-To: <BCDBFDDA-7BF1-48E5-96D6-72FDB4110610@canonware.com>
References: <BCDBFDDA-7BF1-48E5-96D6-72FDB4110610@canonware.com>
Message-ID: <1334218383-21037-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 configure.ac                        |    8 ++++++++
 include/jemalloc/jemalloc_defs.h.in |    3 +++
 src/chunk_dss.c                     |    7 +++++++
 3 files changed, 18 insertions(+)

diff --git a/configure.ac b/configure.ac
index 15a3f06..204e6e5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -692,6 +692,14 @@ fi
 ],
 [enable_dss="0"]
 )
+dnl Check whether the BSD/SUSv1 sbrk() exists. If not, disable DSS support.
+AC_CHECK_FUNC([sbrk], [have_sbrk="1"], [have_sbrk="0"])
+if test "x$have_sbrk" = "x1" ; then
+  AC_DEFINE([JEMALLOC_HAVE_SBRK], [ ])
+else
+  enable_dss="0"
+fi
+
 if test "x$enable_dss" = "x1" ; then
   AC_DEFINE([JEMALLOC_DSS], [ ])
 fi
diff --git a/include/jemalloc/jemalloc_defs.h.in b/include/jemalloc/jemalloc_defs.h.in
index 32efedb..0a0a60c 100644
--- a/include/jemalloc/jemalloc_defs.h.in
+++ b/include/jemalloc/jemalloc_defs.h.in
@@ -108,6 +108,9 @@
 #  define JEMALLOC_ATTR(s) JEMALLOC_CATTR(s,)
 #endif
 
+/* Defined if sbrk() is supported. */
+#undef JEMALLOC_HAVE_SBRK
+
 /* Non-empty if the tls_model attribute is supported. */
 #undef JEMALLOC_TLS_MODEL
 
diff --git a/src/chunk_dss.c b/src/chunk_dss.c
index 7c03409..c718e4c 100644
--- a/src/chunk_dss.c
+++ b/src/chunk_dss.c
@@ -3,6 +3,13 @@
 /******************************************************************************/
 /* Data. */
 
+#ifndef JEMALLOC_HAVE_SBRK
+void *sbrk(intptr_t increment)
+{
+  not_implemented();
+  return NULL;
+}
+#endif
 /*
  * Protects sbrk() calls.  This avoids malloc races among threads, though it
  * does not protect against races with threads that call sbrk() directly.
-- 
1.7.9.5



From amolpise15 at gmail.com  Thu Apr 12 05:32:39 2012
From: amolpise15 at gmail.com (amol pise)
Date: Thu, 12 Apr 2012 18:02:39 +0530
Subject: standalone jemalloc is slower than glibc's malloc (ptmalloc)
In-Reply-To: <CANUf=CBh-9Odtx50G-mrP0rgnsEo7S_BeaYT80k85EyH2L+k1w@mail.gmail.com>
References: <CANUf=CBh-9Odtx50G-mrP0rgnsEo7S_BeaYT80k85EyH2L+k1w@mail.gmail.com>
Message-ID: <CANUf=CBBXYGTmFbpUgk2EJ-Zgpd0f2rJ-7F1tag_DdSaVT3xyg@mail.gmail.com>

Dear Jasone,

With respect to my previous mail, I have performed few benchmark
testing mentioned in the
http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf on
MIPS target

The results are as below:

Benchmark Test:   CCA
-----------------------------------
 With glibc malloc (ptmalloc):
{{{
 # time ./bin/cca -f sample.c
 real    0m12.668s
user    0m12.172s
sys     0m0.276s
 }}}
	
With jemalloc:
{{{
# time LD_PRELOAD=/devel/usr/lib/jemalloc.so ./bin/cca -f sample.c
real    0m13.451s
user    0m12.948s
sys     0m0.252s
 }}}

Here sample.c is the file of lines 17364.

Benchmark Test:  sh6bench
-----------------------------------------
 With glibc malloc (ptmalloc):
{{{
#./sh6bench
 Total elapsed time: 94.00 (94.6600 CPU)
}}}

With jemalloc:
{{{	
# LD_PRELOAD=/devel/usr/lib/libjemalloc.so ./sh6bench
 Total elapsed time: 119.00 (119.4100 CPU)
}}}

Here, I build standalone jemalloc-2.2.5 library for MIPS architecture and used.

The both the benchmark result shows "jemalloc is slower than glibc's malloc".

I wanted to use jemalloc library but these results disappointed me.

Please let me know is there are any way to improve the performace of
jemalloc in this regards.

Please help me. Waiting for the reply.

Thank You,
Amol Pise




On 4/11/12, amol pise <amolpise15 at gmail.com> wrote:
> Dear All,
>
> I have check the performance of the jemalloc vs glibc's malloc
> (ptmalloc) using complex test in libxml2 package
> i.e. "runtest". This program allocate many memory of different size
> and supported multi-thread.
>
> The results are seen as below:
>
>
> With glibc's malloc (ptmalloc):
> --------------------------------------------
>
> # LD_LIBRARY_PATH=.libs time .libs/runtest
> {{{
> ## XML regression tests
> ## XML regression tests on memory
> :
> <snip>
> Total 2820 tests, no errors
> 67.68user 54.96system 2:02.89elapsed 99%CPU (0avgtext+0avgdata
> 0maxresident)k
> }}}
>
>
> With jemalloc:
> ------------------
> # LD_LIBRARY_PATH=.libs LD_PRELOAD=/devel/usr/lib/libjemalloc.so time
> .libs/runtest
> {{{
> ## XML regression tests
>
> ## XML regression tests on memory
>
> :
> <snip>
> Total 2820 tests, no errors
> 76.89user 55.70system 2:12.72elapsed 99%CPU (0avgtext+0avgdata
> 0maxresident)k
> 0inputs+0outputs (0major+0minor)pagefaults 0swaps
> }}}
>
> Here it is observed jemalloc seems slowers than glibc malloc (ptmalloc)
>
>
> I used jemalloc-2.2.5 from http://www.canonware.com/download/jemalloc/
>
> Is it mean jemalloc() is slower than glibc's malloc ?
> Is there any way to improve the speed performance of jemalloc in this
> regard?
>
> I am waiting for the reply.
>
> Thank You,
> Amol Pise
>


From justin.lebar at gmail.com  Thu Apr 12 05:43:23 2012
From: justin.lebar at gmail.com (Justin Lebar)
Date: Thu, 12 Apr 2012 08:43:23 -0400
Subject: standalone jemalloc is slower than glibc's malloc (ptmalloc)
In-Reply-To: <CANUf=CBBXYGTmFbpUgk2EJ-Zgpd0f2rJ-7F1tag_DdSaVT3xyg@mail.gmail.com>
References: <CANUf=CBh-9Odtx50G-mrP0rgnsEo7S_BeaYT80k85EyH2L+k1w@mail.gmail.com>
	<CANUf=CBBXYGTmFbpUgk2EJ-Zgpd0f2rJ-7F1tag_DdSaVT3xyg@mail.gmail.com>
Message-ID: <CAFWcpZ5dFLmtwRO=L_ZWA_kGM0rKB8PyvrCDtdiqAnxrN73yhQ@mail.gmail.com>

> Here, I build standalone jemalloc-2.2.5 library for MIPS architecture and used.

I don't think anyone (or at least, anyone else) is testing jemalloc on
MIPS.  So it's not entirely surprising that jemalloc would be slow
there.

On Thu, Apr 12, 2012 at 8:32 AM, amol pise <amolpise15 at gmail.com> wrote:
> Dear Jasone,
>
> With respect to my previous mail, I have performed few benchmark
> testing mentioned in the
> http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf on
> MIPS target
>
> The results are as below:
>
> Benchmark Test: ? CCA
> -----------------------------------
> ?With glibc malloc (ptmalloc):
> {{{
> ?# time ./bin/cca -f sample.c
> ?real ? ?0m12.668s
> user ? ?0m12.172s
> sys ? ? 0m0.276s
> ?}}}
>
> With jemalloc:
> {{{
> # time LD_PRELOAD=/devel/usr/lib/jemalloc.so ./bin/cca -f sample.c
> real ? ?0m13.451s
> user ? ?0m12.948s
> sys ? ? 0m0.252s
> ?}}}
>
> Here sample.c is the file of lines 17364.
>
> Benchmark Test: ?sh6bench
> -----------------------------------------
> ?With glibc malloc (ptmalloc):
> {{{
> #./sh6bench
> ?Total elapsed time: 94.00 (94.6600 CPU)
> }}}
>
> With jemalloc:
> {{{
> # LD_PRELOAD=/devel/usr/lib/libjemalloc.so ./sh6bench
> ?Total elapsed time: 119.00 (119.4100 CPU)
> }}}
>
> Here, I build standalone jemalloc-2.2.5 library for MIPS architecture and used.
>
> The both the benchmark result shows "jemalloc is slower than glibc's malloc".
>
> I wanted to use jemalloc library but these results disappointed me.
>
> Please let me know is there are any way to improve the performace of
> jemalloc in this regards.
>
> Please help me. Waiting for the reply.
>
> Thank You,
> Amol Pise
>
>
>
>
> On 4/11/12, amol pise <amolpise15 at gmail.com> wrote:
>> Dear All,
>>
>> I have check the performance of the jemalloc vs glibc's malloc
>> (ptmalloc) using complex test in libxml2 package
>> i.e. "runtest". This program allocate many memory of different size
>> and supported multi-thread.
>>
>> The results are seen as below:
>>
>>
>> With glibc's malloc (ptmalloc):
>> --------------------------------------------
>>
>> # LD_LIBRARY_PATH=.libs time .libs/runtest
>> {{{
>> ## XML regression tests
>> ## XML regression tests on memory
>> :
>> <snip>
>> Total 2820 tests, no errors
>> 67.68user 54.96system 2:02.89elapsed 99%CPU (0avgtext+0avgdata
>> 0maxresident)k
>> }}}
>>
>>
>> With jemalloc:
>> ------------------
>> # LD_LIBRARY_PATH=.libs LD_PRELOAD=/devel/usr/lib/libjemalloc.so time
>> .libs/runtest
>> {{{
>> ## XML regression tests
>>
>> ## XML regression tests on memory
>>
>> :
>> <snip>
>> Total 2820 tests, no errors
>> 76.89user 55.70system 2:12.72elapsed 99%CPU (0avgtext+0avgdata
>> 0maxresident)k
>> 0inputs+0outputs (0major+0minor)pagefaults 0swaps
>> }}}
>>
>> Here it is observed jemalloc seems slowers than glibc malloc (ptmalloc)
>>
>>
>> I used jemalloc-2.2.5 from http://www.canonware.com/download/jemalloc/
>>
>> Is it mean jemalloc() is slower than glibc's malloc ?
>> Is there any way to improve the speed performance of jemalloc in this
>> regard?
>>
>> I am waiting for the reply.
>>
>> Thank You,
>> Amol Pise
>>
> _______________________________________________
> jemalloc-discuss mailing list
> jemalloc-discuss at canonware.com
> http://www.canonware.com/mailman/listinfo/jemalloc-discuss


From rnsanchez at wait4.org  Thu Apr 12 06:04:02 2012
From: rnsanchez at wait4.org (Ricardo Nabinger Sanchez)
Date: Thu, 12 Apr 2012 10:04:02 -0300
Subject: standalone jemalloc is slower than glibc's malloc (ptmalloc)
In-Reply-To: <CANUf=CBh-9Odtx50G-mrP0rgnsEo7S_BeaYT80k85EyH2L+k1w@mail.gmail.com>
References: <CANUf=CBh-9Odtx50G-mrP0rgnsEo7S_BeaYT80k85EyH2L+k1w@mail.gmail.com>
Message-ID: <20120412100402.2dafe875@darkbook.lan.box>

Hello Amol,

On Wed, 11 Apr 2012 17:01:40 +0530
amol pise <amolpise15 at gmail.com> wrote:

> I have check the performance of the jemalloc vs glibc's malloc
> (ptmalloc) using complex test in libxml2 package
> i.e. "runtest". This program allocate many memory of different size
> and supported multi-thread.
> 
> ...
> 
> Is it mean jemalloc() is slower than glibc's malloc ?
> Is there any way to improve the speed performance of jemalloc in this regard?

A few questions:

1- Is jemalloc hot?  Glibc should be.  First iteration for jemalloc
   will be cold, hitting startup latencies.  If that is the case, the
   measurement was not fair.

2- Do the results hold?  Ie, repeat 10 ~ 30 times each of them,
   check min/avg/max and stdev, while ensuring fair testing conditions.

3- Do those tests (as performed in libxml2) match whatever scenario you
   expect to hit when using jemalloc?  If they don't match or are too
   far apart, libxml2 will tell you nothing.

Cheers


-- 
Ricardo Nabinger Sanchez           http://rnsanchez.wait4.org/
  "Left to themselves, things tend to go from bad to worse."


From mh+jemalloc at glandium.org  Thu Apr 12 06:15:35 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 15:15:35 +0200
Subject: [PATCH] Call base_boot before chunk_boot0
Message-ID: <1334236535-5009-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Chunk_boot0 calls rtree_new, which calls base_alloc, which locks the
base_mtx mutex. That mutex is initialized in base_boot.
---
 src/jemalloc.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/jemalloc.c b/src/jemalloc.c
index 8e10c55..1622937 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -626,12 +626,12 @@ malloc_init_hard(void)
 		}
 	}
 
-	if (chunk_boot0()) {
+	if (base_boot()) {
 		malloc_mutex_unlock(&init_lock);
 		return (true);
 	}
 
-	if (base_boot()) {
+	if (chunk_boot0()) {
 		malloc_mutex_unlock(&init_lock);
 		return (true);
 	}
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Thu Apr 12 06:47:53 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 15:47:53 +0200
Subject: Mingw port, status update
Message-ID: <20120412134753.GA5199@glandium.org>

Hi,

Here's where I am standing with the mingw port: it passes the test
suite, and repeated running of test/thread_arena (which, until mutexes
were actually implemented, randomly failed :) )

The patches I'm currently using on top of current dev branch (5ff709c)
are:
- Replace %z in format strings with configure-time determined printf
  length modifier.
- Use a stub replacement and disable dss when sbrk is not supported.
- Call base_boot before chunk_boot0.

On top of these, I have a patch adding win32 support:
 configure.ac                                     |   25 ++++++-
 include/jemalloc/internal/jemalloc_internal.h.in |   11 ++-
 include/jemalloc/internal/mutex.h                |   16 +++-
 include/jemalloc/internal/tsd.h                  |   44 +++++++++++
 src/arena.c                                      |    2 +
 src/chunk_dss.c                                  |    5 +-
 src/chunk_mmap.c                                 |   87 +++++++++++++++++-----
 src/jemalloc.c                                   |   30 +++++++-
 src/mutex.c                                      |   10 ++-
 src/util.c                                       |    5 +-
 test/rallocm.c                                   |    9 +++
 11 files changed, 210 insertions(+), 34 deletions(-)

The remaining things to do:
- Build with the right extensions, the right flags, etc.
- Replace the madvise calls instead of removing them.
- Handle thread creation (equivalent to pthread_atfork)
- Call cleanup functions for tsd.

As mentioned in another message, the latter is tricky, as it basically
requires that all cleanup functions are called from a single point, so
we need to decide how to group them.

Equivalent to pthread_atfork is not a given, because while it is "easy"
to be notified of the creation of a thread through the dllmain entry
point (which means jemalloc needs to be a shared library, btw, because
executables don't have that), that only gives one half of the equation:
in the child, after thread creation. I haven't found a way to run
something in the parent before thread creation (at least yet).

For the madvise calls, I'm considering writing a "generic" function to
be used from both places madvise is called, I just need to know where to
put that (it would kind of make sense in chunk_mmap.h or chunk.h), and
what to name it.

This will only bring mingw support. MSVC will probably require more
tweaking, especially in the build system.

Cheers,

Mike


From mh+jemalloc at glandium.org  Thu Apr 12 07:15:42 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 16:15:42 +0200
Subject: Mingw port, status update
In-Reply-To: <20120412134753.GA5199@glandium.org>
References: <20120412134753.GA5199@glandium.org>
Message-ID: <20120412141542.GA6458@glandium.org>

On Thu, Apr 12, 2012 at 03:47:53PM +0200, Mike Hommey wrote:
> Hi,
> 
> Here's where I am standing with the mingw port: it passes the test
> suite, and repeated running of test/thread_arena (which, until mutexes
> were actually implemented, randomly failed :) )
> 
> The patches I'm currently using on top of current dev branch (5ff709c)
> are:
> - Replace %z in format strings with configure-time determined printf
>   length modifier.
> - Use a stub replacement and disable dss when sbrk is not supported.
> - Call base_boot before chunk_boot0.
> 
> On top of these, I have a patch adding win32 support:
>  configure.ac                                     |   25 ++++++-
>  include/jemalloc/internal/jemalloc_internal.h.in |   11 ++-
>  include/jemalloc/internal/mutex.h                |   16 +++-
>  include/jemalloc/internal/tsd.h                  |   44 +++++++++++
>  src/arena.c                                      |    2 +
>  src/chunk_dss.c                                  |    5 +-
>  src/chunk_mmap.c                                 |   87 +++++++++++++++++-----
>  src/jemalloc.c                                   |   30 +++++++-
>  src/mutex.c                                      |   10 ++-
>  src/util.c                                       |    5 +-
>  test/rallocm.c                                   |    9 +++
>  11 files changed, 210 insertions(+), 34 deletions(-)
> 
> The remaining things to do:
> - Build with the right extensions, the right flags, etc.
> - Replace the madvise calls instead of removing them.
> - Handle thread creation (equivalent to pthread_atfork)
> - Call cleanup functions for tsd.
> 
> As mentioned in another message, the latter is tricky, as it basically
> requires that all cleanup functions are called from a single point, so
> we need to decide how to group them.
> 
> Equivalent to pthread_atfork is not a given, because while it is "easy"
> to be notified of the creation of a thread through the dllmain entry
> point (which means jemalloc needs to be a shared library, btw, because
> executables don't have that), that only gives one half of the equation:
> in the child, after thread creation. I haven't found a way to run
> something in the parent before thread creation (at least yet).
> 
> For the madvise calls, I'm considering writing a "generic" function to
> be used from both places madvise is called, I just need to know where to
> put that (it would kind of make sense in chunk_mmap.h or chunk.h), and
> what to name it.
> 
> This will only bring mingw support. MSVC will probably require more
> tweaking, especially in the build system.

Something else I wanted to mention. The init_lock has to be initialized
with malloc_mutex_init. It doesn't seem safe to call it from
malloc_init_hard, so it would be  necessary to use a constructor
function. While this is easy to do with mingw
(__attribute__((constructor))), there is no equivalent in MSVC besides,
apparently, hacks with sections or C++ static initializers. Or, using
DllMain, which mandates that jemalloc is a shared library.

Mike


From mh+jemalloc at glandium.org  Thu Apr 12 07:42:20 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 16:42:20 +0200
Subject: [PATCH] Remove the objroot variable from the build system
Message-ID: <1334241740-9838-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

It is of no use, and is always "".
---
 Makefile.in  |  120 +++++++++++++++++++++++++++++-----------------------------
 configure.ac |    5 +--
 2 files changed, 61 insertions(+), 64 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 8aa9425..da07db4 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -19,7 +19,7 @@ DATADIR := $(DESTDIR)@DATADIR@
 MANDIR := $(DESTDIR)@MANDIR@
 
 # Build parameters.
-CPPFLAGS := @CPPFLAGS@ -I at srcroot@include -I at objroot@include
+CPPFLAGS := @CPPFLAGS@ -I at srcroot@include -Iinclude
 CFLAGS := @CFLAGS@
 ifeq (macho, @abi@)
 CFLAGS += -dynamic
@@ -35,15 +35,15 @@ WL_SONAME := soname
 endif
 REV := @rev@
 ifeq (macho, @abi@)
-TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=@objroot at lib
+TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=lib
 else
 TEST_LIBRARY_PATH :=
 endif
 
 # Lists of files.
-BINS := @srcroot at bin/pprof @objroot at bin/jemalloc.sh
-CHDRS := @objroot at include/jemalloc/jemalloc at install_suffix@.h \
-	@objroot at include/jemalloc/jemalloc_defs at install_suffix@.h
+BINS := @srcroot at bin/pprof bin/jemalloc.sh
+CHDRS := include/jemalloc/jemalloc at install_suffix@.h \
+	include/jemalloc/jemalloc_defs at install_suffix@.h
 CSRCS := @srcroot at src/jemalloc.c @srcroot at src/arena.c @srcroot at src/atomic.c \
 	@srcroot at src/base.c @srcroot at src/bitmap.c @srcroot at src/chunk.c \
 	@srcroot at src/chunk_dss.c @srcroot at src/chunk_mmap.c \
@@ -55,14 +55,14 @@ CSRCS := @srcroot at src/jemalloc.c @srcroot at src/arena.c @srcroot at src/atomic.c \
 ifeq (macho, @abi@)
 CSRCS += @srcroot at src/zone.c
 endif
-STATIC_LIBS := @objroot at lib/libjemalloc at install_suffix@.a
-DSOS := @objroot at lib/libjemalloc at install_suffix@.$(SO).$(REV) \
-	@objroot at lib/libjemalloc at install_suffix@.$(SO) \
-	@objroot at lib/libjemalloc at install_suffix@_pic.a
-MAN3 := @objroot at doc/jemalloc at install_suffix@.3
-DOCS_XML := @objroot at doc/jemalloc at install_suffix@.xml
-DOCS_HTML := $(DOCS_XML:@objroot@%.xml=@srcroot@%.html)
-DOCS_MAN3 := $(DOCS_XML:@objroot@%.xml=@srcroot@%.3)
+STATIC_LIBS := lib/libjemalloc at install_suffix@.a
+DSOS := lib/libjemalloc at install_suffix@.$(SO).$(REV) \
+	lib/libjemalloc at install_suffix@.$(SO) \
+	lib/libjemalloc at install_suffix@_pic.a
+MAN3 := doc/jemalloc at install_suffix@.3
+DOCS_XML := doc/jemalloc at install_suffix@.xml
+DOCS_HTML := $(DOCS_XML:%.xml=@srcroot@%.html)
+DOCS_MAN3 := $(DOCS_XML:%.xml=@srcroot@%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
 CTESTS := @srcroot at test/aligned_alloc.c @srcroot at test/allocated.c \
 	@srcroot at test/bitmap.c @srcroot at test/mremap.c \
@@ -77,18 +77,18 @@ endif
 .PHONY: install_html install_man install_doc install
 .PHONY: tests check clean distclean relclean
 
-.SECONDARY : $(CTESTS:@srcroot@%.c=@objroot@%.o)
+.SECONDARY : $(CTESTS:@srcroot@%.c=%.o)
 
 # Default target.
 all: build
 
 dist: build_doc
 
- at srcroot@doc/%.html : @objroot at doc/%.xml @srcroot at doc/stylesheet.xsl @objroot at doc/html.xsl
-	@XSLTPROC@ -o $@ @objroot at doc/html.xsl $<
+ at srcroot@doc/%.html : doc/%.xml @srcroot at doc/stylesheet.xsl doc/html.xsl
+	@XSLTPROC@ -o $@ doc/html.xsl $<
 
- at srcroot@doc/%.3 : @objroot at doc/%.xml @srcroot at doc/stylesheet.xsl @objroot at doc/manpages.xsl
-	@XSLTPROC@ -o $@ @objroot at doc/manpages.xsl $<
+ at srcroot@doc/%.3 : doc/%.xml @srcroot at doc/stylesheet.xsl doc/manpages.xsl
+	@XSLTPROC@ -o $@ doc/manpages.xsl $<
 
 build_doc_html: $(DOCS_HTML)
 build_doc_man: $(DOCS_MAN3)
@@ -97,16 +97,16 @@ build_doc: $(DOCS)
 #
 # Include generated dependency files.
 #
--include $(CSRCS:@srcroot@%.c=@objroot@%.d)
--include $(CSRCS:@srcroot@%.c=@objroot@%.pic.d)
--include $(CTESTS:@srcroot@%.c=@objroot@%.d)
+-include $(CSRCS:@srcroot@%.c=%.d)
+-include $(CSRCS:@srcroot@%.c=%.pic.d)
+-include $(CTESTS:@srcroot@%.c=%.d)
 
- at objroot@src/%.o: @srcroot at src/%.c
+src/%.o: @srcroot at src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
 
- at objroot@src/%.pic.o: @srcroot at src/%.c
+src/%.pic.o: @srcroot at src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $(basename $@))))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.pic.o \2/g\" > $(@:%.o=%.d)"
@@ -115,33 +115,33 @@ build_doc: $(DOCS)
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
 
- at objroot@lib/libjemalloc at install_suffix@.$(SO).$(REV) : $(CSRCS:@srcroot@%.c=@objroot@%.pic.o)
+lib/libjemalloc at install_suffix@.$(SO).$(REV) : $(CSRCS:@srcroot@%.c=%.pic.o)
 	@mkdir -p $(@D)
 	$(CC) -shared -Wl,-$(WL_SONAME),$(@F) $(RPATH_EXTRA:%=@RPATH@%) -o $@ $+ $(LDFLAGS) $(LIBS)
 
- at objroot@lib/libjemalloc at install_suffix@_pic.a : $(CSRCS:@srcroot@%.c=@objroot@%.pic.o)
+lib/libjemalloc at install_suffix@_pic.a : $(CSRCS:@srcroot@%.c=%.pic.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
- at objroot@lib/libjemalloc at install_suffix@.a : $(CSRCS:@srcroot@%.c=@objroot@%.o)
+lib/libjemalloc at install_suffix@.a : $(CSRCS:@srcroot@%.c=%.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
- at objroot@test/%.o: @srcroot at test/%.c
+test/%.o: @srcroot at test/%.c
 	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -c $(CPPFLAGS) -I at objroot@test -o $@ $<
-	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) -I at objroot@test $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
+	$(CC) $(CFLAGS) -c $(CPPFLAGS) -Itest -o $@ $<
+	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) -Itest $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
 
 # Automatic dependency generation misses #include "*.c".
- at objroot@test/bitmap.o : @objroot at src/bitmap.o
+test/bitmap.o : src/bitmap.o
 
- at objroot@test/%: @objroot at test/%.o \
-		 @objroot at lib/libjemalloc at install_suffix@.$(SO)
+test/%: test/%.o \
+		 lib/libjemalloc at install_suffix@.$(SO)
 	@mkdir -p $(@D)
 ifneq (@RPATH@, )
-	$(CC) -o $@ $< @RPATH@@objroot at lib -L at objroot@lib -ljemalloc at install_suffix@ -lpthread
+	$(CC) -o $@ $< @RPATH at lib -Llib -ljemalloc at install_suffix@ -lpthread
 else
-	$(CC) -o $@ $< -L at objroot@lib -ljemalloc at install_suffix@ -lpthread
+	$(CC) -o $@ $< -Llib -ljemalloc at install_suffix@ -lpthread
 endif
 
 build_lib_shared: $(DSOS)
@@ -164,13 +164,13 @@ done
 
 install_lib_shared: $(DSOS)
 	install -d $(LIBDIR)
-	install -m 755 @objroot at lib/libjemalloc at install_suffix@.$(SO).$(REV) $(LIBDIR)
+	install -m 755 lib/libjemalloc at install_suffix@.$(SO).$(REV) $(LIBDIR)
 	ln -sf libjemalloc at install_suffix@.$(SO).$(REV) $(LIBDIR)/libjemalloc at install_suffix@.$(SO)
 
 install_lib_static: $(DSOS) $(STATIC_LIBS)
 	install -d $(LIBDIR)
-	install -m 755 @objroot at lib/libjemalloc at install_suffix@_pic.a $(LIBDIR)
-	install -m 755 @objroot at lib/libjemalloc at install_suffix@.a $(LIBDIR)
+	install -m 755 lib/libjemalloc at install_suffix@_pic.a $(LIBDIR)
+	install -m 755 lib/libjemalloc at install_suffix@.a $(LIBDIR)
 
 install_lib: install_lib_shared install_lib_static
 
@@ -192,21 +192,21 @@ install_doc: install_doc_html install_doc_man
 
 install: install_bin install_include install_lib install_doc
 
-tests: $(CTESTS:@srcroot@%.c=@objroot@%)
+tests: $(CTESTS:@srcroot@%.c=%)
 
 check: tests
-	@mkdir -p @objroot at test
+	@mkdir -p test
 	@$(SHELL) -c 'total=0; \
 		failures=0; \
 		echo "========================================="; \
-		for t in $(CTESTS:@srcroot@%.c=@objroot@%); do \
+		for t in $(CTESTS:@srcroot@%.c=%); do \
 			total=`expr $$total + 1`; \
 			/bin/echo -n "$${t} ... "; \
 			$(TEST_LIBRARY_PATH) $${t} @abs_srcroot@ @abs_objroot@ \
-			  > @objroot@$${t}.out 2>&1; \
+			  > $${t}.out 2>&1; \
 			if test -e "@srcroot@$${t}.exp"; then \
 				diff -w -u @srcroot@$${t}.exp \
-				  @objroot@$${t}.out >/dev/null 2>&1; \
+				  $${t}.out >/dev/null 2>&1; \
 				fail=$$?; \
 				if test "$${fail}" -eq "1" ; then \
 					failures=`expr $${failures} + 1`; \
@@ -223,26 +223,26 @@ check: tests
 		echo "Failures: $${failures}/$${total}"'
 
 clean:
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.o)
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.pic.o)
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.d)
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.pic.d)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%.o)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%.d)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%.out)
+	rm -f $(CSRCS:@srcroot@%.c=%.o)
+	rm -f $(CSRCS:@srcroot@%.c=%.pic.o)
+	rm -f $(CSRCS:@srcroot@%.c=%.d)
+	rm -f $(CSRCS:@srcroot@%.c=%.pic.d)
+	rm -f $(CTESTS:@srcroot@%.c=%)
+	rm -f $(CTESTS:@srcroot@%.c=%.o)
+	rm -f $(CTESTS:@srcroot@%.c=%.d)
+	rm -f $(CTESTS:@srcroot@%.c=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 
 distclean: clean
-	rm -rf @objroot at autom4te.cache
-	rm -f @objroot at config.log
-	rm -f @objroot at config.status
-	rm -f @objroot at config.stamp
+	rm -rf autom4te.cache
+	rm -f config.log
+	rm -f config.status
+	rm -f config.stamp
 	rm -f @cfghdrs_out@
 	rm -f @cfgoutputs_out@
 
 relclean: distclean
-	rm -f @objroot at configure
+	rm -f configure
 	rm -f @srcroot at VERSION
 	rm -f $(DOCS_HTML)
 	rm -f $(DOCS_MAN3)
@@ -254,18 +254,18 @@ ifeq (@enable_autogen@, 1)
 @srcroot at configure : @srcroot at configure.ac
 	cd ./@srcroot@ && @AUTOCONF@
 
- at objroot@config.status : @srcroot at configure
-	./@objroot at config.status --recheck
+config.status : @srcroot at configure
+	./config.status --recheck
 
 @srcroot at config.stamp.in : @srcroot at configure.ac
 	echo stamp > @srcroot at config.stamp.in
 
- at objroot@config.stamp : @cfgoutputs_in@ @cfghdrs_in@ @srcroot at configure
-	./@objroot at config.status
+config.stamp : @cfgoutputs_in@ @cfghdrs_in@ @srcroot at configure
+	./config.status
 	@touch $@
 
 # There must be some action in order for make to re-read Makefile when it is
 # out of date.
- at cfgoutputs_out@ @cfghdrs_out@ : @objroot at config.stamp
+ at cfgoutputs_out@ @cfghdrs_out@ : config.stamp
 	@true
 endif
diff --git a/configure.ac b/configure.ac
index 204e6e5..27a9f73 100644
--- a/configure.ac
+++ b/configure.ac
@@ -55,8 +55,6 @@ AC_SUBST([srcroot])
 abs_srcroot="`cd \"${srcdir}\"; pwd`/"
 AC_SUBST([abs_srcroot])
 
-objroot=""
-AC_SUBST([objroot])
 abs_objroot="`pwd`/"
 AC_SUBST([abs_objroot])
 
@@ -1085,7 +1083,7 @@ AC_HEADER_STDBOOL
 
 AC_CONFIG_COMMANDS([include/jemalloc/internal/size_classes.h], [
   mkdir -p "include/jemalloc/internal"
-  "${srcdir}/include/jemalloc/internal/size_classes.sh" > "${objroot}include/jemalloc/internal/size_classes.h"
+  "${srcdir}/include/jemalloc/internal/size_classes.sh" > "include/jemalloc/internal/size_classes.h"
 ])
 
 dnl Process .in files.
@@ -1125,7 +1123,6 @@ AC_MSG_RESULT([MANDIR             : ${MANDIR}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([srcroot            : ${srcroot}])
 AC_MSG_RESULT([abs_srcroot        : ${abs_srcroot}])
-AC_MSG_RESULT([objroot            : ${objroot}])
 AC_MSG_RESULT([abs_objroot        : ${abs_objroot}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([JEMALLOC_PREFIX    : ${JEMALLOC_PREFIX}])
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Thu Apr 12 07:50:35 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 16:50:35 +0200
Subject: Mingw port, status update
In-Reply-To: <20120412141542.GA6458@glandium.org>
References: <20120412134753.GA5199@glandium.org>
	<20120412141542.GA6458@glandium.org>
Message-ID: <20120412145035.GA12597@glandium.org>

Also, a small note: include/jemalloc/internal/size_classes.sh is awfully
slow on Windows.

Mike


From mh+jemalloc at glandium.org  Thu Apr 12 08:13:26 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 17:13:26 +0200
Subject: [PATCH] Use a make variable instead of preprocessing for srcroot,
	and simplify source files handling
Message-ID: <1334243606-20354-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in |   99 ++++++++++++++++++++++++++++++-----------------------------
 1 file changed, 50 insertions(+), 49 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index da07db4..f623d47 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -17,9 +17,10 @@ INCLUDEDIR := $(DESTDIR)@INCLUDEDIR@
 LIBDIR := $(DESTDIR)@LIBDIR@
 DATADIR := $(DESTDIR)@DATADIR@
 MANDIR := $(DESTDIR)@MANDIR@
+srcroot := @srcroot@
 
 # Build parameters.
-CPPFLAGS := @CPPFLAGS@ -I at srcroot@include -Iinclude
+CPPFLAGS := @CPPFLAGS@ -I$(srcroot)include -Iinclude
 CFLAGS := @CFLAGS@
 ifeq (macho, @abi@)
 CFLAGS += -dynamic
@@ -41,19 +42,19 @@ TEST_LIBRARY_PATH :=
 endif
 
 # Lists of files.
-BINS := @srcroot at bin/pprof bin/jemalloc.sh
+BINS := $(srcroot)bin/pprof bin/jemalloc.sh
 CHDRS := include/jemalloc/jemalloc at install_suffix@.h \
 	include/jemalloc/jemalloc_defs at install_suffix@.h
-CSRCS := @srcroot at src/jemalloc.c @srcroot at src/arena.c @srcroot at src/atomic.c \
-	@srcroot at src/base.c @srcroot at src/bitmap.c @srcroot at src/chunk.c \
-	@srcroot at src/chunk_dss.c @srcroot at src/chunk_mmap.c \
-	@srcroot at src/ckh.c @srcroot at src/ctl.c @srcroot at src/extent.c \
-	@srcroot at src/hash.c @srcroot at src/huge.c @srcroot at src/mb.c \
-	@srcroot at src/mutex.c @srcroot at src/prof.c @srcroot at src/quarantine.c \
-	@srcroot at src/rtree.c @srcroot at src/stats.c @srcroot at src/tcache.c \
-	@srcroot at src/util.c @srcroot at src/tsd.c
+CSRCS := src/jemalloc.c src/arena.c src/atomic.c \
+	src/base.c src/bitmap.c src/chunk.c \
+	src/chunk_dss.c src/chunk_mmap.c \
+	src/ckh.c src/ctl.c src/extent.c \
+	src/hash.c src/huge.c src/mb.c \
+	src/mutex.c src/prof.c src/quarantine.c \
+	src/rtree.c src/stats.c src/tcache.c \
+	src/util.c src/tsd.c
 ifeq (macho, @abi@)
-CSRCS += @srcroot at src/zone.c
+CSRCS += src/zone.c
 endif
 STATIC_LIBS := lib/libjemalloc at install_suffix@.a
 DSOS := lib/libjemalloc at install_suffix@.$(SO).$(REV) \
@@ -61,15 +62,15 @@ DSOS := lib/libjemalloc at install_suffix@.$(SO).$(REV) \
 	lib/libjemalloc at install_suffix@_pic.a
 MAN3 := doc/jemalloc at install_suffix@.3
 DOCS_XML := doc/jemalloc at install_suffix@.xml
-DOCS_HTML := $(DOCS_XML:%.xml=@srcroot@%.html)
-DOCS_MAN3 := $(DOCS_XML:%.xml=@srcroot@%.3)
+DOCS_HTML := $(DOCS_XML:%.xml=$(srcroot)%.html)
+DOCS_MAN3 := $(DOCS_XML:%.xml=$(srcroot)%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
-CTESTS := @srcroot at test/aligned_alloc.c @srcroot at test/allocated.c \
-	@srcroot at test/bitmap.c @srcroot at test/mremap.c \
-	@srcroot at test/posix_memalign.c @srcroot at test/thread_arena.c \
-	@srcroot at test/thread_tcache_enabled.c
+CTESTS := test/aligned_alloc.c test/allocated.c \
+	test/bitmap.c test/mremap.c \
+	test/posix_memalign.c test/thread_arena.c \
+	test/thread_tcache_enabled.c
 ifeq (@enable_experimental@, 1)
-CTESTS += @srcroot at test/allocm.c @srcroot at test/rallocm.c
+CTESTS += test/allocm.c test/rallocm.c
 endif
 
 .PHONY: all dist doc_html doc_man doc
@@ -77,17 +78,17 @@ endif
 .PHONY: install_html install_man install_doc install
 .PHONY: tests check clean distclean relclean
 
-.SECONDARY : $(CTESTS:@srcroot@%.c=%.o)
+.SECONDARY : $(CTESTS:%.c=%.o)
 
 # Default target.
 all: build
 
 dist: build_doc
 
- at srcroot@doc/%.html : doc/%.xml @srcroot at doc/stylesheet.xsl doc/html.xsl
+$(srcroot)doc/%.html : doc/%.xml $(srcroot)doc/stylesheet.xsl doc/html.xsl
 	@XSLTPROC@ -o $@ doc/html.xsl $<
 
- at srcroot@doc/%.3 : doc/%.xml @srcroot at doc/stylesheet.xsl doc/manpages.xsl
+$(srcroot)doc/%.3 : doc/%.xml $(srcroot)doc/stylesheet.xsl doc/manpages.xsl
 	@XSLTPROC@ -o $@ doc/manpages.xsl $<
 
 build_doc_html: $(DOCS_HTML)
@@ -97,16 +98,16 @@ build_doc: $(DOCS)
 #
 # Include generated dependency files.
 #
--include $(CSRCS:@srcroot@%.c=%.d)
--include $(CSRCS:@srcroot@%.c=%.pic.d)
--include $(CTESTS:@srcroot@%.c=%.d)
+-include $(CSRCS:$(srcroot)%.c=%.d)
+-include $(CSRCS:$(srcroot)%.c=%.pic.d)
+-include $(CTESTS:$(srcroot)%.c=%.d)
 
-src/%.o: @srcroot at src/%.c
+src/%.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
 
-src/%.pic.o: @srcroot at src/%.c
+src/%.pic.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $(basename $@))))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.pic.o \2/g\" > $(@:%.o=%.d)"
@@ -115,19 +116,19 @@ src/%.pic.o: @srcroot at src/%.c
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
 
-lib/libjemalloc at install_suffix@.$(SO).$(REV) : $(CSRCS:@srcroot@%.c=%.pic.o)
+lib/libjemalloc at install_suffix@.$(SO).$(REV) : $(CSRCS:%.c=%.pic.o)
 	@mkdir -p $(@D)
 	$(CC) -shared -Wl,-$(WL_SONAME),$(@F) $(RPATH_EXTRA:%=@RPATH@%) -o $@ $+ $(LDFLAGS) $(LIBS)
 
-lib/libjemalloc at install_suffix@_pic.a : $(CSRCS:@srcroot@%.c=%.pic.o)
+lib/libjemalloc at install_suffix@_pic.a : $(CSRCS:%.c=%.pic.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-lib/libjemalloc at install_suffix@.a : $(CSRCS:@srcroot@%.c=%.o)
+lib/libjemalloc at install_suffix@.a : $(CSRCS:%.c=%.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-test/%.o: @srcroot at test/%.c
+test/%.o: $(srcroot)test/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -Itest -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) -Itest $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
@@ -192,20 +193,20 @@ install_doc: install_doc_html install_doc_man
 
 install: install_bin install_include install_lib install_doc
 
-tests: $(CTESTS:@srcroot@%.c=%)
+tests: $(CTESTS:%.c=%)
 
 check: tests
 	@mkdir -p test
 	@$(SHELL) -c 'total=0; \
 		failures=0; \
 		echo "========================================="; \
-		for t in $(CTESTS:@srcroot@%.c=%); do \
+		for t in $(CTESTS:%.c=%); do \
 			total=`expr $$total + 1`; \
 			/bin/echo -n "$${t} ... "; \
 			$(TEST_LIBRARY_PATH) $${t} @abs_srcroot@ @abs_objroot@ \
 			  > $${t}.out 2>&1; \
-			if test -e "@srcroot@$${t}.exp"; then \
-				diff -w -u @srcroot@$${t}.exp \
+			if test -e "$(srcroot)$${t}.exp"; then \
+				diff -w -u $(srcroot)$${t}.exp \
 				  $${t}.out >/dev/null 2>&1; \
 				fail=$$?; \
 				if test "$${fail}" -eq "1" ; then \
@@ -223,14 +224,14 @@ check: tests
 		echo "Failures: $${failures}/$${total}"'
 
 clean:
-	rm -f $(CSRCS:@srcroot@%.c=%.o)
-	rm -f $(CSRCS:@srcroot@%.c=%.pic.o)
-	rm -f $(CSRCS:@srcroot@%.c=%.d)
-	rm -f $(CSRCS:@srcroot@%.c=%.pic.d)
-	rm -f $(CTESTS:@srcroot@%.c=%)
-	rm -f $(CTESTS:@srcroot@%.c=%.o)
-	rm -f $(CTESTS:@srcroot@%.c=%.d)
-	rm -f $(CTESTS:@srcroot@%.c=%.out)
+	rm -f $(CSRCS:%.c=%.o)
+	rm -f $(CSRCS:%.c=%.pic.o)
+	rm -f $(CSRCS:%.c=%.d)
+	rm -f $(CSRCS:%.c=%.pic.d)
+	rm -f $(CTESTS:%.c=%)
+	rm -f $(CTESTS:%.c=%.o)
+	rm -f $(CTESTS:%.c=%.d)
+	rm -f $(CTESTS:%.c=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 
 distclean: clean
@@ -243,7 +244,7 @@ distclean: clean
 
 relclean: distclean
 	rm -f configure
-	rm -f @srcroot at VERSION
+	rm -f $(srcroot)VERSION
 	rm -f $(DOCS_HTML)
 	rm -f $(DOCS_MAN3)
 
@@ -251,16 +252,16 @@ relclean: distclean
 # Re-configuration rules.
 
 ifeq (@enable_autogen@, 1)
- at srcroot@configure : @srcroot at configure.ac
-	cd ./@srcroot@ && @AUTOCONF@
+$(srcroot)configure : $(srcroot)configure.ac
+	cd ./$(srcroot) && @AUTOCONF@
 
-config.status : @srcroot at configure
+config.status : $(srcroot)configure
 	./config.status --recheck
 
- at srcroot@config.stamp.in : @srcroot at configure.ac
-	echo stamp > @srcroot at config.stamp.in
+$(srcroot)config.stamp.in : $(srcroot)configure.ac
+	echo stamp > $@
 
-config.stamp : @cfgoutputs_in@ @cfghdrs_in@ @srcroot at configure
+config.stamp : @cfgoutputs_in@ @cfghdrs_in@ $(srcroot)configure
 	./config.status
 	@touch $@
 
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Thu Apr 12 08:14:36 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 17:14:36 +0200
Subject: [PATCH] Use a make variable instead of preprocessing for srcroot,
	and simplify source files handling
In-Reply-To: <1334243606-20354-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334243606-20354-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334243676-20455-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in |   99 ++++++++++++++++++++++++++++++-----------------------------
 1 file changed, 50 insertions(+), 49 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index da07db4..b879807 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -17,9 +17,10 @@ INCLUDEDIR := $(DESTDIR)@INCLUDEDIR@
 LIBDIR := $(DESTDIR)@LIBDIR@
 DATADIR := $(DESTDIR)@DATADIR@
 MANDIR := $(DESTDIR)@MANDIR@
+srcroot := @srcroot@
 
 # Build parameters.
-CPPFLAGS := @CPPFLAGS@ -I at srcroot@include -Iinclude
+CPPFLAGS := @CPPFLAGS@ -I$(srcroot)include -Iinclude
 CFLAGS := @CFLAGS@
 ifeq (macho, @abi@)
 CFLAGS += -dynamic
@@ -41,19 +42,19 @@ TEST_LIBRARY_PATH :=
 endif
 
 # Lists of files.
-BINS := @srcroot at bin/pprof bin/jemalloc.sh
+BINS := $(srcroot)bin/pprof bin/jemalloc.sh
 CHDRS := include/jemalloc/jemalloc at install_suffix@.h \
 	include/jemalloc/jemalloc_defs at install_suffix@.h
-CSRCS := @srcroot at src/jemalloc.c @srcroot at src/arena.c @srcroot at src/atomic.c \
-	@srcroot at src/base.c @srcroot at src/bitmap.c @srcroot at src/chunk.c \
-	@srcroot at src/chunk_dss.c @srcroot at src/chunk_mmap.c \
-	@srcroot at src/ckh.c @srcroot at src/ctl.c @srcroot at src/extent.c \
-	@srcroot at src/hash.c @srcroot at src/huge.c @srcroot at src/mb.c \
-	@srcroot at src/mutex.c @srcroot at src/prof.c @srcroot at src/quarantine.c \
-	@srcroot at src/rtree.c @srcroot at src/stats.c @srcroot at src/tcache.c \
-	@srcroot at src/util.c @srcroot at src/tsd.c
+CSRCS := src/jemalloc.c src/arena.c src/atomic.c \
+	src/base.c src/bitmap.c src/chunk.c \
+	src/chunk_dss.c src/chunk_mmap.c \
+	src/ckh.c src/ctl.c src/extent.c \
+	src/hash.c src/huge.c src/mb.c \
+	src/mutex.c src/prof.c src/quarantine.c \
+	src/rtree.c src/stats.c src/tcache.c \
+	src/util.c src/tsd.c
 ifeq (macho, @abi@)
-CSRCS += @srcroot at src/zone.c
+CSRCS += src/zone.c
 endif
 STATIC_LIBS := lib/libjemalloc at install_suffix@.a
 DSOS := lib/libjemalloc at install_suffix@.$(SO).$(REV) \
@@ -61,15 +62,15 @@ DSOS := lib/libjemalloc at install_suffix@.$(SO).$(REV) \
 	lib/libjemalloc at install_suffix@_pic.a
 MAN3 := doc/jemalloc at install_suffix@.3
 DOCS_XML := doc/jemalloc at install_suffix@.xml
-DOCS_HTML := $(DOCS_XML:%.xml=@srcroot@%.html)
-DOCS_MAN3 := $(DOCS_XML:%.xml=@srcroot@%.3)
+DOCS_HTML := $(DOCS_XML:%.xml=$(srcroot)%.html)
+DOCS_MAN3 := $(DOCS_XML:%.xml=$(srcroot)%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
-CTESTS := @srcroot at test/aligned_alloc.c @srcroot at test/allocated.c \
-	@srcroot at test/bitmap.c @srcroot at test/mremap.c \
-	@srcroot at test/posix_memalign.c @srcroot at test/thread_arena.c \
-	@srcroot at test/thread_tcache_enabled.c
+CTESTS := test/aligned_alloc.c test/allocated.c \
+	test/bitmap.c test/mremap.c \
+	test/posix_memalign.c test/thread_arena.c \
+	test/thread_tcache_enabled.c
 ifeq (@enable_experimental@, 1)
-CTESTS += @srcroot at test/allocm.c @srcroot at test/rallocm.c
+CTESTS += test/allocm.c test/rallocm.c
 endif
 
 .PHONY: all dist doc_html doc_man doc
@@ -77,17 +78,17 @@ endif
 .PHONY: install_html install_man install_doc install
 .PHONY: tests check clean distclean relclean
 
-.SECONDARY : $(CTESTS:@srcroot@%.c=%.o)
+.SECONDARY : $(CTESTS:%.c=%.o)
 
 # Default target.
 all: build
 
 dist: build_doc
 
- at srcroot@doc/%.html : doc/%.xml @srcroot at doc/stylesheet.xsl doc/html.xsl
+$(srcroot)doc/%.html : doc/%.xml $(srcroot)doc/stylesheet.xsl doc/html.xsl
 	@XSLTPROC@ -o $@ doc/html.xsl $<
 
- at srcroot@doc/%.3 : doc/%.xml @srcroot at doc/stylesheet.xsl doc/manpages.xsl
+$(srcroot)doc/%.3 : doc/%.xml $(srcroot)doc/stylesheet.xsl doc/manpages.xsl
 	@XSLTPROC@ -o $@ doc/manpages.xsl $<
 
 build_doc_html: $(DOCS_HTML)
@@ -97,16 +98,16 @@ build_doc: $(DOCS)
 #
 # Include generated dependency files.
 #
--include $(CSRCS:@srcroot@%.c=%.d)
--include $(CSRCS:@srcroot@%.c=%.pic.d)
--include $(CTESTS:@srcroot@%.c=%.d)
+-include $(CSRCS:%.c=%.d)
+-include $(CSRCS:%.c=%.pic.d)
+-include $(CTESTS:%.c=%.d)
 
-src/%.o: @srcroot at src/%.c
+src/%.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
 
-src/%.pic.o: @srcroot at src/%.c
+src/%.pic.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $(basename $@))))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.pic.o \2/g\" > $(@:%.o=%.d)"
@@ -115,19 +116,19 @@ src/%.pic.o: @srcroot at src/%.c
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
 
-lib/libjemalloc at install_suffix@.$(SO).$(REV) : $(CSRCS:@srcroot@%.c=%.pic.o)
+lib/libjemalloc at install_suffix@.$(SO).$(REV) : $(CSRCS:%.c=%.pic.o)
 	@mkdir -p $(@D)
 	$(CC) -shared -Wl,-$(WL_SONAME),$(@F) $(RPATH_EXTRA:%=@RPATH@%) -o $@ $+ $(LDFLAGS) $(LIBS)
 
-lib/libjemalloc at install_suffix@_pic.a : $(CSRCS:@srcroot@%.c=%.pic.o)
+lib/libjemalloc at install_suffix@_pic.a : $(CSRCS:%.c=%.pic.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-lib/libjemalloc at install_suffix@.a : $(CSRCS:@srcroot@%.c=%.o)
+lib/libjemalloc at install_suffix@.a : $(CSRCS:%.c=%.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-test/%.o: @srcroot at test/%.c
+test/%.o: $(srcroot)test/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -Itest -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) -Itest $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
@@ -192,20 +193,20 @@ install_doc: install_doc_html install_doc_man
 
 install: install_bin install_include install_lib install_doc
 
-tests: $(CTESTS:@srcroot@%.c=%)
+tests: $(CTESTS:%.c=%)
 
 check: tests
 	@mkdir -p test
 	@$(SHELL) -c 'total=0; \
 		failures=0; \
 		echo "========================================="; \
-		for t in $(CTESTS:@srcroot@%.c=%); do \
+		for t in $(CTESTS:%.c=%); do \
 			total=`expr $$total + 1`; \
 			/bin/echo -n "$${t} ... "; \
 			$(TEST_LIBRARY_PATH) $${t} @abs_srcroot@ @abs_objroot@ \
 			  > $${t}.out 2>&1; \
-			if test -e "@srcroot@$${t}.exp"; then \
-				diff -w -u @srcroot@$${t}.exp \
+			if test -e "$(srcroot)$${t}.exp"; then \
+				diff -w -u $(srcroot)$${t}.exp \
 				  $${t}.out >/dev/null 2>&1; \
 				fail=$$?; \
 				if test "$${fail}" -eq "1" ; then \
@@ -223,14 +224,14 @@ check: tests
 		echo "Failures: $${failures}/$${total}"'
 
 clean:
-	rm -f $(CSRCS:@srcroot@%.c=%.o)
-	rm -f $(CSRCS:@srcroot@%.c=%.pic.o)
-	rm -f $(CSRCS:@srcroot@%.c=%.d)
-	rm -f $(CSRCS:@srcroot@%.c=%.pic.d)
-	rm -f $(CTESTS:@srcroot@%.c=%)
-	rm -f $(CTESTS:@srcroot@%.c=%.o)
-	rm -f $(CTESTS:@srcroot@%.c=%.d)
-	rm -f $(CTESTS:@srcroot@%.c=%.out)
+	rm -f $(CSRCS:%.c=%.o)
+	rm -f $(CSRCS:%.c=%.pic.o)
+	rm -f $(CSRCS:%.c=%.d)
+	rm -f $(CSRCS:%.c=%.pic.d)
+	rm -f $(CTESTS:%.c=%)
+	rm -f $(CTESTS:%.c=%.o)
+	rm -f $(CTESTS:%.c=%.d)
+	rm -f $(CTESTS:%.c=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 
 distclean: clean
@@ -243,7 +244,7 @@ distclean: clean
 
 relclean: distclean
 	rm -f configure
-	rm -f @srcroot at VERSION
+	rm -f $(srcroot)VERSION
 	rm -f $(DOCS_HTML)
 	rm -f $(DOCS_MAN3)
 
@@ -251,16 +252,16 @@ relclean: distclean
 # Re-configuration rules.
 
 ifeq (@enable_autogen@, 1)
- at srcroot@configure : @srcroot at configure.ac
-	cd ./@srcroot@ && @AUTOCONF@
+$(srcroot)configure : $(srcroot)configure.ac
+	cd ./$(srcroot) && @AUTOCONF@
 
-config.status : @srcroot at configure
+config.status : $(srcroot)configure
 	./config.status --recheck
 
- at srcroot@config.stamp.in : @srcroot at configure.ac
-	echo stamp > @srcroot at config.stamp.in
+$(srcroot)config.stamp.in : $(srcroot)configure.ac
+	echo stamp > $@
 
-config.stamp : @cfgoutputs_in@ @cfghdrs_in@ @srcroot at configure
+config.stamp : @cfgoutputs_in@ @cfghdrs_in@ $(srcroot)configure
 	./config.status
 	@touch $@
 
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Thu Apr 12 08:19:20 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 17:19:20 +0200
Subject: [PATCH] Use -MT options to build dependency files
Message-ID: <1334243960-21311-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index b879807..a01e5e9 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -105,12 +105,12 @@ build_doc: $(DOCS)
 src/%.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
-	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
+	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.o=%.d) $<
 
 src/%.pic.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
-	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) $< | sed \"s/\($(subst /,\/,$(notdir $(basename $(basename $@))))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.pic.o \2/g\" > $(@:%.o=%.d)"
+	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.o=%.d) $<
 
 %.$(SO) : %.$(SO).$(REV)
 	@mkdir -p $(@D)
-- 
1.7.9.5



From mh+jemalloc at glandium.org  Thu Apr 12 08:21:58 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 17:21:58 +0200
Subject: [PATCH] Remove bogus dependency
Message-ID: <1334244118-21444-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

test/bitmap.c #includes src/bitmap.c, which is correctly detected by gcc -MM,
but building test/bitmap.o doesn't require src/bitmap.o.
---
 Makefile.in |    3 ---
 1 file changed, 3 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index a01e5e9..1f33b19 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -133,9 +133,6 @@ test/%.o: $(srcroot)test/%.c
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -Itest -o $@ $<
 	@$(SHELL) -ec "$(CC) -MM $(CPPFLAGS) -Itest $< | sed \"s/\($(subst /,\/,$(notdir $(basename $@)))\)\.o\([ :]*\)/$(subst /,\/,$(strip $(dir $@)))\1.o \2/g\" > $(@:%.o=%.d)"
 
-# Automatic dependency generation misses #include "*.c".
-test/bitmap.o : src/bitmap.o
-
 test/%: test/%.o \
 		 lib/libjemalloc at install_suffix@.$(SO)
 	@mkdir -p $(@D)
-- 
1.7.9.5



From jasone at canonware.com  Thu Apr 12 08:43:48 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 12 Apr 2012 08:43:48 -0700
Subject: [PATCH] Use a stub replacement and disable dss when sbrk is not
	supported
In-Reply-To: <1334218383-21037-1-git-send-email-mh+jemalloc@glandium.org>
References: <BCDBFDDA-7BF1-48E5-96D6-72FDB4110610@canonware.com>
	<1334218383-21037-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <79636B6D-255C-4E41-9A4E-0DB10B426050@canonware.com>

On Apr 12, 2012, at 1:13 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> ---
> configure.ac                        |    8 ++++++++
> include/jemalloc/jemalloc_defs.h.in |    3 +++
> src/chunk_dss.c                     |    7 +++++++
> 3 files changed, 18 insertions(+)

Applied; thanks.

Jason


From jasone at canonware.com  Thu Apr 12 11:45:31 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 12 Apr 2012 11:45:31 -0700
Subject: [PATCH] Call base_boot before chunk_boot0
In-Reply-To: <1334236535-5009-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334236535-5009-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <462580FB-3ABA-470A-8F89-790FF5A77088@canonware.com>

On Apr 12, 2012, at 6:15 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> Chunk_boot0 calls rtree_new, which calls base_alloc, which locks the
> base_mtx mutex. That mutex is initialized in base_boot.
> ---
> src/jemalloc.c |    4 ++--
> 1 file changed, 2 insertions(+), 2 deletions(-)

Applied; thanks.

Jason


From jasone at canonware.com  Thu Apr 12 11:56:47 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 12 Apr 2012 11:56:47 -0700
Subject: [PATCH] Remove the objroot variable from the build system
In-Reply-To: <1334241740-9838-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334241740-9838-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <5A2D3EE5-325C-4426-AE26-B301040A2937@canonware.com>

On Apr 12, 2012, at 7:42 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> It is of no use, and is always "".

The presence of objroot is meant to introduce symmetry in the various pattern rules, and to act as explicit documentation that a path is intended to be relative to objroot.  Is it causing some sort of trouble for you?

Thanks,
Jason

From jasone at canonware.com  Thu Apr 12 12:32:57 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 12 Apr 2012 12:32:57 -0700
Subject: [PATCH] Remove bogus dependency
In-Reply-To: <1334244118-21444-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334244118-21444-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <0045C3AD-AA1E-4F19-8A86-1F883FDCF2AB@canonware.com>

On Apr 12, 2012, at 8:21 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> test/bitmap.c #includes src/bitmap.c, which is correctly detected by gcc -MM,
> but building test/bitmap.o doesn't require src/bitmap.o.
> ---
> Makefile.in |    3 ---
> 1 file changed, 3 deletions(-)

Applied; thanks.

Jason

From jasone at canonware.com  Thu Apr 12 12:54:32 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 12 Apr 2012 12:54:32 -0700
Subject: [PATCH] Use -MT options to build dependency files
In-Reply-To: <1334243960-21311-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334243960-21311-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <A92D2B71-611F-4BC5-93E3-EC3E229FEA80@canonware.com>

On Apr 12, 2012, at 8:19 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> ---
> Makefile.in |    4 ++--
> 1 file changed, 2 insertions(+), 2 deletions(-)

Applied, with the same change made for the test build rule as well; thanks.

Jason


From mh+jemalloc at glandium.org  Thu Apr 12 13:56:53 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 12 Apr 2012 22:56:53 +0200
Subject: [PATCH] Remove the objroot variable from the build system
In-Reply-To: <5A2D3EE5-325C-4426-AE26-B301040A2937@canonware.com>
References: <1334241740-9838-1-git-send-email-mh+jemalloc@glandium.org>
	<5A2D3EE5-325C-4426-AE26-B301040A2937@canonware.com>
Message-ID: <20120412205653.GA26682@glandium.org>

On Thu, Apr 12, 2012 at 11:56:47AM -0700, Jason Evans wrote:
> On Apr 12, 2012, at 7:42 AM, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > It is of no use, and is always "".
> 
> The presence of objroot is meant to introduce symmetry in the various
> pattern rules, and to act as explicit documentation that a path is
> intended to be relative to objroot.  Is it causing some sort of
> trouble for you?

Besides being too verbose for literally no value, no.

Mike


From mh+jemalloc at glandium.org  Mon Apr 16 07:30:23 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 16:30:23 +0200
Subject: [PATCH 4/7] Use echo instead of cat in loops in size_classes.sh
In-Reply-To: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334586626-2008-4-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

This avoids fork/exec()ing in loops, as echo is a builtin, and makes
size_classes.sh much faster (from > 10s to < 0.2s on mingw on my machine).
---
 include/jemalloc/internal/size_classes.sh |   32 ++++++++++-------------------
 1 file changed, 11 insertions(+), 21 deletions(-)

diff --git a/include/jemalloc/internal/size_classes.sh b/include/jemalloc/internal/size_classes.sh
index 3d23613..29c80c1 100755
--- a/include/jemalloc/internal/size_classes.sh
+++ b/include/jemalloc/internal/size_classes.sh
@@ -35,10 +35,8 @@ while [ ${lg_q} -le ${lg_qmax} ] ; do
   while [ ${lg_t} -le ${lg_q} ] ; do
     lg_p=${lg_pmin}
     while [ ${lg_p} -le ${lg_pmax} ] ; do
-      cat <<EOF
-#if (LG_TINY_MIN == ${lg_t} && LG_QUANTUM == ${lg_q} && LG_PAGE == ${lg_p})
-#define	SIZE_CLASSES_DEFINED
-EOF
+      echo "#if (LG_TINY_MIN == ${lg_t} && LG_QUANTUM == ${lg_q} && LG_PAGE == ${lg_p})"
+      echo "#define	SIZE_CLASSES_DEFINED"
       pow2 ${lg_q}; q=${pow2_result}
       pow2 ${lg_t}; t=${pow2_result}
       pow2 ${lg_p}; p=${pow2_result}
@@ -46,16 +44,12 @@ EOF
       psz=0
       sz=${t}
       delta=$((${sz} - ${psz}))
-cat <<EOF
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\\
-EOF
+      echo "/*  SIZE_CLASS(bin,	delta,	sz) */"
+      echo "#define	SIZE_CLASSES							\\"
 
       # Tiny size classes.
       while [ ${sz} -lt ${q} ] ; do
-        cat <<EOF
-    SIZE_CLASS(${bin},	${delta},	${sz})					\\
-EOF
+        echo "    SIZE_CLASS(${bin},	${delta},	${sz})					\\"
         bin=$((${bin} + 1))
         psz=${sz}
         sz=$((${sz} + ${sz}))
@@ -73,22 +67,18 @@ EOF
         fi
         next_2pow=$((${sz} * 2))
         while [ ${sz} -lt $next_2pow ] ; do
-          cat <<EOF
-    SIZE_CLASS(${bin},	${delta},	${sz})					\\
-EOF
+          echo "    SIZE_CLASS(${bin},	${delta},	${sz})					\\"
           bin=$((${bin} + 1))
           psz=${sz}
           sz=$((${sz} + ${i}))
           delta=$((${sz} - ${psz}))
         done
       done
-      cat <<EOF
-
-#define	NBINS		${bin}
-#define	SMALL_MAXCLASS	${psz}
-#endif
-
-EOF
+      echo
+      echo "#define	NBINS		${bin}"
+      echo "#define	SMALL_MAXCLASS	${psz}"
+      echo "#endif"
+      echo
       lg_p=$((${lg_p} + 1))
     done
     lg_t=$((${lg_t} + 1))
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 07:30:22 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 16:30:22 +0200
Subject: [PATCH 3/7] Use make variables instead of preprocessing
In-Reply-To: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334586626-2008-3-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in |  202 ++++++++++++++++++++++++++++++++---------------------------
 1 file changed, 109 insertions(+), 93 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 8cd0418..1c30f32 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -17,9 +17,13 @@ INCLUDEDIR := $(DESTDIR)@INCLUDEDIR@
 LIBDIR := $(DESTDIR)@LIBDIR@
 DATADIR := $(DESTDIR)@DATADIR@
 MANDIR := $(DESTDIR)@MANDIR@
+srcroot := @srcroot@
+objroot := @objroot@
+abs_srcroot := @abs_srcroot@
+abs_objroot := @abs_objroot@
 
 # Build parameters.
-CPPFLAGS := @CPPFLAGS@ -I at srcroot@include -I at objroot@include
+CPPFLAGS := @CPPFLAGS@ -I$(srcroot)include -I$(objroot)include
 CFLAGS := @CFLAGS@
 LDFLAGS := @LDFLAGS@
 LIBS := @LIBS@
@@ -31,42 +35,54 @@ else
 WL_SONAME := soname
 endif
 REV := @rev@
-ifeq (macho, @abi@)
-TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=@objroot at lib
+install_suffix := @install_suffix@
+ABI := @abi@
+XSLTPROC := @XSLTPROC@
+AUTOCONF := @AUTOCONF@
+RPATH := @RPATH@
+cfghdrs_in := @cfghdrs_in@
+cfghdrs_out := @cfghdrs_out@
+cfgoutputs_in := @cfgoutputs_in@
+cfgoutputs_out := @cfgoutputs_out@
+enable_autogen := @enable_autogen@
+enable_experimental := @enable_experimental@
+
+ifeq (macho, $(ABI))
+TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
 else
 TEST_LIBRARY_PATH :=
 endif
 
 # Lists of files.
-BINS := @srcroot at bin/pprof @objroot at bin/jemalloc.sh
-CHDRS := @objroot at include/jemalloc/jemalloc at install_suffix@.h \
-	@objroot at include/jemalloc/jemalloc_defs at install_suffix@.h
-CSRCS := @srcroot at src/jemalloc.c @srcroot at src/arena.c @srcroot at src/atomic.c \
-	@srcroot at src/base.c @srcroot at src/bitmap.c @srcroot at src/chunk.c \
-	@srcroot at src/chunk_dss.c @srcroot at src/chunk_mmap.c \
-	@srcroot at src/ckh.c @srcroot at src/ctl.c @srcroot at src/extent.c \
-	@srcroot at src/hash.c @srcroot at src/huge.c @srcroot at src/mb.c \
-	@srcroot at src/mutex.c @srcroot at src/prof.c @srcroot at src/quarantine.c \
-	@srcroot at src/rtree.c @srcroot at src/stats.c @srcroot at src/tcache.c \
-	@srcroot at src/util.c @srcroot at src/tsd.c
-ifeq (macho, @abi@)
-CSRCS += @srcroot at src/zone.c
+BINS := $(srcroot)bin/pprof $(objroot)bin/jemalloc.sh
+CHDRS := $(objroot)include/jemalloc/jemalloc$(install_suffix).h \
+	$(objroot)include/jemalloc/jemalloc_defs$(install_suffix).h
+CSRCS := $(srcroot)src/jemalloc.c $(srcroot)src/arena.c $(srcroot)src/atomic.c \
+	$(srcroot)src/base.c $(srcroot)src/bitmap.c $(srcroot)src/chunk.c \
+	$(srcroot)src/chunk_dss.c $(srcroot)src/chunk_mmap.c \
+	$(srcroot)src/ckh.c $(srcroot)src/ctl.c $(srcroot)src/extent.c \
+	$(srcroot)src/hash.c $(srcroot)src/huge.c $(srcroot)src/mb.c \
+	$(srcroot)src/mutex.c $(srcroot)src/prof.c $(srcroot)src/quarantine.c \
+	$(srcroot)src/rtree.c $(srcroot)src/stats.c $(srcroot)src/tcache.c \
+	$(srcroot)src/util.c $(srcroot)src/tsd.c
+ifeq (macho, $(ABI))
+CSRCS += $(srcroot)src/zone.c
 endif
-STATIC_LIBS := @objroot at lib/libjemalloc at install_suffix@.a
-DSOS := @objroot at lib/libjemalloc at install_suffix@.$(SO).$(REV) \
-	@objroot at lib/libjemalloc at install_suffix@.$(SO) \
-	@objroot at lib/libjemalloc at install_suffix@_pic.a
-MAN3 := @objroot at doc/jemalloc at install_suffix@.3
-DOCS_XML := @objroot at doc/jemalloc at install_suffix@.xml
-DOCS_HTML := $(DOCS_XML:@objroot@%.xml=@srcroot@%.html)
-DOCS_MAN3 := $(DOCS_XML:@objroot@%.xml=@srcroot@%.3)
+STATIC_LIBS := $(objroot)lib/libjemalloc$(install_suffix).a
+DSOS := $(objroot)lib/libjemalloc$(install_suffix).$(SO).$(REV) \
+	$(objroot)lib/libjemalloc$(install_suffix).$(SO) \
+	$(objroot)lib/libjemalloc$(install_suffix)_pic.a
+MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
+DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
+DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.html)
+DOCS_MAN3 := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
-CTESTS := @srcroot at test/aligned_alloc.c @srcroot at test/allocated.c \
-	@srcroot at test/bitmap.c @srcroot at test/mremap.c \
-	@srcroot at test/posix_memalign.c @srcroot at test/thread_arena.c \
-	@srcroot at test/thread_tcache_enabled.c
-ifeq (@enable_experimental@, 1)
-CTESTS += @srcroot at test/allocm.c @srcroot at test/rallocm.c
+CTESTS := $(srcroot)test/aligned_alloc.c $(srcroot)test/allocated.c \
+	$(srcroot)test/bitmap.c $(srcroot)test/mremap.c \
+	$(srcroot)test/posix_memalign.c $(srcroot)test/thread_arena.c \
+	$(srcroot)test/thread_tcache_enabled.c
+ifeq ($(enable_experimental), 1)
+CTESTS += $(srcroot)test/allocm.c $(srcroot)test/rallocm.c
 endif
 
 .PHONY: all dist doc_html doc_man doc
@@ -74,18 +90,18 @@ endif
 .PHONY: install_html install_man install_doc install
 .PHONY: tests check clean distclean relclean
 
-.SECONDARY : $(CTESTS:@srcroot@%.c=@objroot@%.o)
+.SECONDARY : $(CTESTS:$(srcroot)%.c=$(objroot)%.o)
 
 # Default target.
 all: build
 
 dist: build_doc
 
- at srcroot@doc/%.html : @objroot at doc/%.xml @srcroot at doc/stylesheet.xsl @objroot at doc/html.xsl
-	@XSLTPROC@ -o $@ @objroot at doc/html.xsl $<
+$(srcroot)doc/%.html : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/html.xsl
+	$(XSLTPROC) -o $@ $(objroot)doc/html.xsl $<
 
- at srcroot@doc/%.3 : @objroot at doc/%.xml @srcroot at doc/stylesheet.xsl @objroot at doc/manpages.xsl
-	@XSLTPROC@ -o $@ @objroot at doc/manpages.xsl $<
+$(srcroot)doc/%.3 : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/manpages.xsl
+	$(XSLTPROC) -o $@ $(objroot)doc/manpages.xsl $<
 
 build_doc_html: $(DOCS_HTML)
 build_doc_man: $(DOCS_MAN3)
@@ -94,16 +110,16 @@ build_doc: $(DOCS)
 #
 # Include generated dependency files.
 #
--include $(CSRCS:@srcroot@%.c=@objroot@%.d)
--include $(CSRCS:@srcroot@%.c=@objroot@%.pic.d)
--include $(CTESTS:@srcroot@%.c=@objroot@%.d)
+-include $(CSRCS:$(srcroot)%.c=$(objroot)%.d)
+-include $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
+-include $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
 
- at objroot@src/%.o: @srcroot at src/%.c
+$(objroot)src/%.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.o=%.d) $<
 
- at objroot@src/%.pic.o: @srcroot at src/%.c
+$(objroot)src/%.pic.o: $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.o=%.d) $<
@@ -112,30 +128,30 @@ build_doc: $(DOCS)
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
 
- at objroot@lib/libjemalloc at install_suffix@.$(SO).$(REV) : $(CSRCS:@srcroot@%.c=@objroot@%.pic.o)
+$(objroot)lib/libjemalloc$(install_suffix).$(SO).$(REV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.o)
 	@mkdir -p $(@D)
-	$(CC) -shared -Wl,-$(WL_SONAME),$(@F) $(RPATH_EXTRA:%=@RPATH@%) -o $@ $+ $(LDFLAGS) $(LIBS)
+	$(CC) -shared -Wl,-$(WL_SONAME),$(@F) $(RPATH_EXTRA:%=$(RPATH)%) -o $@ $+ $(LDFLAGS) $(LIBS)
 
- at objroot@lib/libjemalloc at install_suffix@_pic.a : $(CSRCS:@srcroot@%.c=@objroot@%.pic.o)
+$(objroot)lib/libjemalloc$(install_suffix)_pic.a : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
- at objroot@lib/libjemalloc at install_suffix@.a : $(CSRCS:@srcroot@%.c=@objroot@%.o)
+$(objroot)lib/libjemalloc$(install_suffix).a : $(CSRCS:$(srcroot)%.c=$(objroot)%.o)
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
- at objroot@test/%.o: @srcroot at test/%.c
+$(objroot)test/%.o: $(srcroot)test/%.c
 	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -c $(CPPFLAGS) -I at objroot@test -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -I at objroot@test -MT $@ -o $(@:%.o=%.d) $<
+	$(CC) $(CFLAGS) -c $(CPPFLAGS) -I$(objroot)test -o $@ $<
+	@$(CC) -MM $(CPPFLAGS) -I$(objroot)test -MT $@ -o $(@:%.o=%.d) $<
 
- at objroot@test/%: @objroot at test/%.o \
-		 @objroot at lib/libjemalloc at install_suffix@.$(SO)
+$(objroot)test/%: $(objroot)test/%.o \
+		 $(objroot)lib/libjemalloc$(install_suffix).$(SO)
 	@mkdir -p $(@D)
-ifneq (@RPATH@, )
-	$(CC) -o $@ $< @RPATH@@objroot at lib -L at objroot@lib -ljemalloc at install_suffix@ $(LIBS)
+ifneq ($(RPATH), )
+	$(CC) -o $@ $< $(RPATH)$(objroot)lib -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
 else
-	$(CC) -o $@ $< -L at objroot@lib -ljemalloc at install_suffix@ $(LIBS)
+	$(CC) -o $@ $< -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
 endif
 
 build_lib_shared: $(DSOS)
@@ -158,21 +174,21 @@ done
 
 install_lib_shared: $(DSOS)
 	install -d $(LIBDIR)
-	install -m 755 @objroot at lib/libjemalloc at install_suffix@.$(SO).$(REV) $(LIBDIR)
-	ln -sf libjemalloc at install_suffix@.$(SO).$(REV) $(LIBDIR)/libjemalloc at install_suffix@.$(SO)
+	install -m 755 $(objroot)lib/libjemalloc$(install_suffix).$(SO).$(REV) $(LIBDIR)
+	ln -sf libjemalloc$(install_suffix).$(SO).$(REV) $(LIBDIR)/libjemalloc$(install_suffix).$(SO)
 
 install_lib_static: $(DSOS) $(STATIC_LIBS)
 	install -d $(LIBDIR)
-	install -m 755 @objroot at lib/libjemalloc at install_suffix@_pic.a $(LIBDIR)
-	install -m 755 @objroot at lib/libjemalloc at install_suffix@.a $(LIBDIR)
+	install -m 755 $(objroot)lib/libjemalloc$(install_suffix)_pic.a $(LIBDIR)
+	install -m 755 $(objroot)lib/libjemalloc$(install_suffix).a $(LIBDIR)
 
 install_lib: install_lib_shared install_lib_static
 
 install_doc_html:
-	install -d $(DATADIR)/doc/jemalloc at install_suffix@
+	install -d $(DATADIR)/doc/jemalloc$(install_suffix)
 	@for d in $(DOCS_HTML); do \
-	echo "install -m 644 $$d $(DATADIR)/doc/jemalloc at install_suffix@"; \
-	install -m 644 $$d $(DATADIR)/doc/jemalloc at install_suffix@; \
+	echo "install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix)"; \
+	install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix); \
 done
 
 install_doc_man:
@@ -186,21 +202,21 @@ install_doc: install_doc_html install_doc_man
 
 install: install_bin install_include install_lib install_doc
 
-tests: $(CTESTS:@srcroot@%.c=@objroot@%)
+tests: $(CTESTS:$(srcroot)%.c=$(objroot)%)
 
 check: tests
-	@mkdir -p @objroot at test
+	@mkdir -p $(objroot)test
 	@$(SHELL) -c 'total=0; \
 		failures=0; \
 		echo "========================================="; \
-		for t in $(CTESTS:@srcroot@%.c=@objroot@%); do \
+		for t in $(CTESTS:$(srcroot)%.c=$(objroot)%); do \
 			total=`expr $$total + 1`; \
 			/bin/echo -n "$${t} ... "; \
-			$(TEST_LIBRARY_PATH) $${t} @abs_srcroot@ @abs_objroot@ \
-			  > @objroot@$${t}.out 2>&1; \
-			if test -e "@srcroot@$${t}.exp"; then \
-				diff -w -u @srcroot@$${t}.exp \
-				  @objroot@$${t}.out >/dev/null 2>&1; \
+			$(TEST_LIBRARY_PATH) $${t} $(abs_srcroot) $(abs_objroot) \
+			  > $(objroot)$${t}.out 2>&1; \
+			if test -e "$(srcroot)$${t}.exp"; then \
+				diff -w -u $(srcroot)$${t}.exp \
+				  $(objroot)$${t}.out >/dev/null 2>&1; \
 				fail=$$?; \
 				if test "$${fail}" -eq "1" ; then \
 					failures=`expr $${failures} + 1`; \
@@ -217,49 +233,49 @@ check: tests
 		echo "Failures: $${failures}/$${total}"'
 
 clean:
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.o)
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.pic.o)
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.d)
-	rm -f $(CSRCS:@srcroot@%.c=@objroot@%.pic.d)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%.o)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%.d)
-	rm -f $(CTESTS:@srcroot@%.c=@objroot@%.out)
+	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.o)
+	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.o)
+	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.d)
+	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
+	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%)
+	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.o)
+	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
+	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 
 distclean: clean
-	rm -rf @objroot at autom4te.cache
-	rm -f @objroot at config.log
-	rm -f @objroot at config.status
-	rm -f @objroot at config.stamp
-	rm -f @cfghdrs_out@
-	rm -f @cfgoutputs_out@
+	rm -rf $(objroot)autom4te.cache
+	rm -f $(objroot)config.log
+	rm -f $(objroot)config.status
+	rm -f $(objroot)config.stamp
+	rm -f $(cfghdrs_out)
+	rm -f $(cfgoutputs_out)
 
 relclean: distclean
-	rm -f @objroot at configure
-	rm -f @srcroot at VERSION
+	rm -f $(objroot)configure
+	rm -f $(srcroot)VERSION
 	rm -f $(DOCS_HTML)
 	rm -f $(DOCS_MAN3)
 
 #===============================================================================
 # Re-configuration rules.
 
-ifeq (@enable_autogen@, 1)
- at srcroot@configure : @srcroot at configure.ac
-	cd ./@srcroot@ && @AUTOCONF@
+ifeq ($(enable_autogen), 1)
+$(srcroot)configure : $(srcroot)configure.ac
+	cd ./$(srcroot) && $(AUTOCONF)
 
- at objroot@config.status : @srcroot at configure
-	./@objroot at config.status --recheck
+$(objroot)config.status : $(srcroot)configure
+	./$(objroot)config.status --recheck
 
- at srcroot@config.stamp.in : @srcroot at configure.ac
-	echo stamp > @srcroot at config.stamp.in
+$(srcroot)config.stamp.in : $(srcroot)configure.ac
+	echo stamp > $(srcroot)config.stamp.in
 
- at objroot@config.stamp : @cfgoutputs_in@ @cfghdrs_in@ @srcroot at configure
-	./@objroot at config.status
+$(objroot)config.stamp : $(cfgoutputs_in) $(cfghdrs_in) $(srcroot)configure
+	./$(objroot)config.status
 	@touch $@
 
 # There must be some action in order for make to re-read Makefile when it is
 # out of date.
- at cfgoutputs_out@ @cfghdrs_out@ : @objroot at config.stamp
+$(cfgoutputs_out) $(cfghdrs_out) : $(objroot)config.stamp
 	@true
 endif
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 07:30:21 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 16:30:21 +0200
Subject: [PATCH 2/7] Use $(LIBS) instead of -lpthread when linking tests
In-Reply-To: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334586626-2008-2-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

This will allow linking for win32 without pthreads more easily
---
 Makefile.in |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 6479857..8cd0418 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -133,9 +133,9 @@ build_doc: $(DOCS)
 		 @objroot at lib/libjemalloc at install_suffix@.$(SO)
 	@mkdir -p $(@D)
 ifneq (@RPATH@, )
-	$(CC) -o $@ $< @RPATH@@objroot at lib -L at objroot@lib -ljemalloc at install_suffix@ -lpthread
+	$(CC) -o $@ $< @RPATH@@objroot at lib -L at objroot@lib -ljemalloc at install_suffix@ $(LIBS)
 else
-	$(CC) -o $@ $< -L at objroot@lib -ljemalloc at install_suffix@ -lpthread
+	$(CC) -o $@ $< -L at objroot@lib -ljemalloc at install_suffix@ $(LIBS)
 endif
 
 build_lib_shared: $(DSOS)
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 07:30:20 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 16:30:20 +0200
Subject: [PATCH 1/7] Remove -dynamic CFLAG on OSX
Message-ID: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

It is a linker flag, so it doesn't make sense in CFLAGS, and it's the
default when invoking the linker for shared libraries.
---
 Makefile.in |    3 ---
 1 file changed, 3 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 8828d7f..6479857 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -21,9 +21,6 @@ MANDIR := $(DESTDIR)@MANDIR@
 # Build parameters.
 CPPFLAGS := @CPPFLAGS@ -I at srcroot@include -I at objroot@include
 CFLAGS := @CFLAGS@
-ifeq (macho, @abi@)
-CFLAGS += -dynamic
-endif
 LDFLAGS := @LDFLAGS@
 LIBS := @LIBS@
 RPATH_EXTRA := @RPATH_EXTRA@
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 07:30:25 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 16:30:25 +0200
Subject: [PATCH 6/7] Limit the number of flags directly given to the linker,
	and refactor rpath
In-Reply-To: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334586626-2008-6-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

This will make things easier for MSVC support.
---
 Makefile.in  |   17 +++++------------
 configure.ac |   11 +++++------
 2 files changed, 10 insertions(+), 18 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 146f57f..ef8f717 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -33,23 +33,20 @@ O := @o@
 A := @a@
 EXE := @exe@
 LIB := @lib@
-ifeq (macho, @abi@)
-WL_SONAME := dylib_install_name
-else
-WL_SONAME := soname
-endif
 REV := @rev@
 install_suffix := @install_suffix@
 ABI := @abi@
 XSLTPROC := @XSLTPROC@
 AUTOCONF := @AUTOCONF@
-RPATH := @RPATH@
+_RPATH = @RPATH@
+RPATH = $(if $(1),$(call _RPATH,$(1)))
 cfghdrs_in := @cfghdrs_in@
 cfghdrs_out := @cfghdrs_out@
 cfgoutputs_in := @cfgoutputs_in@
 cfgoutputs_out := @cfgoutputs_out@
 enable_autogen := @enable_autogen@
 enable_experimental := @enable_experimental@
+DSO_LDFLAGS = @DSO_LDFLAGS@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
@@ -136,7 +133,7 @@ $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
 
 $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	@mkdir -p $(@D)
-	$(CC) -shared -Wl,-$(WL_SONAME),$(@F) $(RPATH_EXTRA:%=$(RPATH)%) -o $@ $+ $(LDFLAGS) $(LIBS)
+	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) -o $@ $+ $(LDFLAGS) $(LIBS)
 
 $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	@mkdir -p $(@D)
@@ -154,11 +151,7 @@ $(objroot)test/%.$(O): $(srcroot)test/%.c
 $(objroot)test/%$(EXE): $(objroot)test/%.$(O) \
 		 $(objroot)lib/$(LIBJEMALLOC).$(SO)
 	@mkdir -p $(@D)
-ifneq ($(RPATH), )
-	$(CC) -o $@ $< $(RPATH)$(objroot)lib -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
-else
-	$(CC) -o $@ $< -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
-endif
+	$(CC) -o $@ $< $(call RPATH,$(objroot)lib) -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
 
 build_lib_shared: $(DSOS)
 build_lib_static: $(STATIC_LIBS)
diff --git a/configure.ac b/configure.ac
index 11b09e8..8b9ba00 100644
--- a/configure.ac
+++ b/configure.ac
@@ -199,6 +199,8 @@ o="o"
 a="a"
 exe=
 lib="lib"
+DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
+RPATH='-Wl,-rpath,$(1)'
 
 dnl Heap profiling uses the log(3) function.
 LIBS="$LIBS -lm"
@@ -219,12 +221,12 @@ case "${host}" in
 	LD_PRELOAD_VAR="DYLD_INSERT_LIBRARIES"
 	so="dylib"
 	force_tls="0"
+	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
 	;;
   *-*-freebsd*)
 	CFLAGS="$CFLAGS"
 	abi="elf"
 	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
-	RPATH="-Wl,-rpath,"
 	force_lazy_lock="1"
 	;;
   *-*-linux*)
@@ -233,7 +235,6 @@ case "${host}" in
 	abi="elf"
 	AC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED], [ ])
 	AC_DEFINE([JEMALLOC_THREADED_INIT], [ ])
-	RPATH="-Wl,-rpath,"
 	;;
   *-*-netbsd*)
 	AC_MSG_CHECKING([ABI])
@@ -248,12 +249,11 @@ case "${host}" in
                           [abi="aout"])
 	AC_MSG_RESULT([$abi])
 	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
-	RPATH="-Wl,-rpath,"
 	;;
   *-*-solaris2*)
 	CFLAGS="$CFLAGS"
 	abi="elf"
-	RPATH="-Wl,-R,"
+	RPATH='-Wl,-R,$(1)'
 	dnl Solaris needs this for sigwait().
 	CPPFLAGS="$CPPFLAGS -D_POSIX_PTHREAD_SEMANTICS"
 	LIBS="$LIBS -lposix4 -lsocket -lnsl"
@@ -267,12 +267,10 @@ case "${host}" in
 	  LD_PRELOAD_VAR="LDR_PRELOAD"
 	fi
 	abi="xcoff"
-	RPATH="-Wl,-rpath,"
 	;;
   *)
 	AC_MSG_RESULT([Unsupported operating system: ${host}])
 	abi="elf"
-	RPATH="-Wl,-rpath,"
 	;;
 esac
 AC_SUBST([abi])
@@ -283,6 +281,7 @@ AC_SUBST([o])
 AC_SUBST([a])
 AC_SUBST([exe])
 AC_SUBST([lib])
+AC_SUBST([DSO_LDFLAGS])
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 07:30:24 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 16:30:24 +0200
Subject: [PATCH 5/7] Add variables for library prefix, and static library,
	object and executable suffixes
In-Reply-To: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334586626-2008-5-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

This makes hacking on Makefile easier.
---
 Makefile.in  |   58 ++++++++++++++++++++++++++++++++--------------------------
 configure.ac |    8 ++++++++
 2 files changed, 40 insertions(+), 26 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 1c30f32..146f57f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -29,6 +29,10 @@ LDFLAGS := @LDFLAGS@
 LIBS := @LIBS@
 RPATH_EXTRA := @RPATH_EXTRA@
 SO := @so@
+O := @o@
+A := @a@
+EXE := @exe@
+LIB := @lib@
 ifeq (macho, @abi@)
 WL_SONAME := dylib_install_name
 else
@@ -53,6 +57,8 @@ else
 TEST_LIBRARY_PATH :=
 endif
 
+LIBJEMALLOC := $(LIB)jemalloc$(install_suffix)
+
 # Lists of files.
 BINS := $(srcroot)bin/pprof $(objroot)bin/jemalloc.sh
 CHDRS := $(objroot)include/jemalloc/jemalloc$(install_suffix).h \
@@ -68,10 +74,10 @@ CSRCS := $(srcroot)src/jemalloc.c $(srcroot)src/arena.c $(srcroot)src/atomic.c \
 ifeq (macho, $(ABI))
 CSRCS += $(srcroot)src/zone.c
 endif
-STATIC_LIBS := $(objroot)lib/libjemalloc$(install_suffix).a
-DSOS := $(objroot)lib/libjemalloc$(install_suffix).$(SO).$(REV) \
-	$(objroot)lib/libjemalloc$(install_suffix).$(SO) \
-	$(objroot)lib/libjemalloc$(install_suffix)_pic.a
+STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
+DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) \
+	$(objroot)lib/$(LIBJEMALLOC).$(SO) \
+	$(objroot)lib/$(LIBJEMALLOC)_pic.$(A)
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
 DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.html)
@@ -90,7 +96,7 @@ endif
 .PHONY: install_html install_man install_doc install
 .PHONY: tests check clean distclean relclean
 
-.SECONDARY : $(CTESTS:$(srcroot)%.c=$(objroot)%.o)
+.SECONDARY : $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
 
 # Default target.
 all: build
@@ -114,39 +120,39 @@ build_doc: $(DOCS)
 -include $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
 -include $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
 
-$(objroot)src/%.o: $(srcroot)src/%.c
+$(objroot)src/%.$(O): $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.o=%.d) $<
+	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
-$(objroot)src/%.pic.o: $(srcroot)src/%.c
+$(objroot)src/%.pic.$(O): $(srcroot)src/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.o=%.d) $<
+	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
 %.$(SO) : %.$(SO).$(REV)
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
 
-$(objroot)lib/libjemalloc$(install_suffix).$(SO).$(REV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.o)
+$(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	@mkdir -p $(@D)
 	$(CC) -shared -Wl,-$(WL_SONAME),$(@F) $(RPATH_EXTRA:%=$(RPATH)%) -o $@ $+ $(LDFLAGS) $(LIBS)
 
-$(objroot)lib/libjemalloc$(install_suffix)_pic.a : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.o)
+$(objroot)lib/$(LIBJEMALLOC)_pic.$(A) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-$(objroot)lib/libjemalloc$(install_suffix).a : $(CSRCS:$(srcroot)%.c=$(objroot)%.o)
+$(objroot)lib/$(LIBJEMALLOC).$(A) : $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-$(objroot)test/%.o: $(srcroot)test/%.c
+$(objroot)test/%.$(O): $(srcroot)test/%.c
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -I$(objroot)test -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -I$(objroot)test -MT $@ -o $(@:%.o=%.d) $<
+	@$(CC) -MM $(CPPFLAGS) -I$(objroot)test -MT $@ -o $(@:%.$(O)=%.d) $<
 
-$(objroot)test/%: $(objroot)test/%.o \
-		 $(objroot)lib/libjemalloc$(install_suffix).$(SO)
+$(objroot)test/%$(EXE): $(objroot)test/%.$(O) \
+		 $(objroot)lib/$(LIBJEMALLOC).$(SO)
 	@mkdir -p $(@D)
 ifneq ($(RPATH), )
 	$(CC) -o $@ $< $(RPATH)$(objroot)lib -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
@@ -174,13 +180,13 @@ done
 
 install_lib_shared: $(DSOS)
 	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/libjemalloc$(install_suffix).$(SO).$(REV) $(LIBDIR)
-	ln -sf libjemalloc$(install_suffix).$(SO).$(REV) $(LIBDIR)/libjemalloc$(install_suffix).$(SO)
+	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)
+	ln -sf $(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
 
 install_lib_static: $(DSOS) $(STATIC_LIBS)
 	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/libjemalloc$(install_suffix)_pic.a $(LIBDIR)
-	install -m 755 $(objroot)lib/libjemalloc$(install_suffix).a $(LIBDIR)
+	install -m 755 $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) $(LIBDIR)
+	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(A) $(LIBDIR)
 
 install_lib: install_lib_shared install_lib_static
 
@@ -202,7 +208,7 @@ install_doc: install_doc_html install_doc_man
 
 install: install_bin install_include install_lib install_doc
 
-tests: $(CTESTS:$(srcroot)%.c=$(objroot)%)
+tests: $(CTESTS:$(srcroot)%.c=$(objroot)%$(EXE))
 
 check: tests
 	@mkdir -p $(objroot)test
@@ -212,7 +218,7 @@ check: tests
 		for t in $(CTESTS:$(srcroot)%.c=$(objroot)%); do \
 			total=`expr $$total + 1`; \
 			/bin/echo -n "$${t} ... "; \
-			$(TEST_LIBRARY_PATH) $${t} $(abs_srcroot) $(abs_objroot) \
+			$(TEST_LIBRARY_PATH) $${t}$(EXE) $(abs_srcroot) $(abs_objroot) \
 			  > $(objroot)$${t}.out 2>&1; \
 			if test -e "$(srcroot)$${t}.exp"; then \
 				diff -w -u $(srcroot)$${t}.exp \
@@ -233,12 +239,12 @@ check: tests
 		echo "Failures: $${failures}/$${total}"'
 
 clean:
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.o)
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.o)
+	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
+	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.d)
 	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%)
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.o)
+	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%$(EXE))
+	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
 	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
 	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
diff --git a/configure.ac b/configure.ac
index 8d20659..11b09e8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -195,6 +195,10 @@ AC_DEFINE_UNQUOTED([CPU_SPINWAIT], [$CPU_SPINWAIT])
 
 LD_PRELOAD_VAR="LD_PRELOAD"
 so="so"
+o="o"
+a="a"
+exe=
+lib="lib"
 
 dnl Heap profiling uses the log(3) function.
 LIBS="$LIBS -lm"
@@ -275,6 +279,10 @@ AC_SUBST([abi])
 AC_SUBST([RPATH])
 AC_SUBST([LD_PRELOAD_VAR])
 AC_SUBST([so])
+AC_SUBST([o])
+AC_SUBST([a])
+AC_SUBST([exe])
+AC_SUBST([lib])
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 07:30:26 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 16:30:26 +0200
Subject: [PATCH 7/7] Replace fprintf with malloc_printf in tests.
In-Reply-To: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334586626-2008-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334586626-2008-7-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in                                      |    6 ++-
 include/jemalloc/internal/jemalloc_internal.h.in |    3 ++
 test/aligned_alloc.c                             |   18 ++++----
 test/allocated.c                                 |   18 ++++----
 test/allocm.c                                    |   54 +++++++++++-----------
 test/bitmap.c                                    |   10 +---
 test/jemalloc_test.h.in                          |    1 +
 test/mremap.c                                    |   12 ++---
 test/posix_memalign.c                            |   18 ++++----
 test/rallocm.c                                   |   52 ++++++++++-----------
 test/thread_arena.c                              |   16 +++----
 test/thread_tcache_enabled.c                     |    8 ++--
 12 files changed, 108 insertions(+), 108 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index ef8f717..0dfddea 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -148,10 +148,12 @@ $(objroot)test/%.$(O): $(srcroot)test/%.c
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -I$(objroot)test -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -I$(objroot)test -MT $@ -o $(@:%.$(O)=%.d) $<
 
-$(objroot)test/%$(EXE): $(objroot)test/%.$(O) \
+$(objroot)test/bitmap$(EXE): $(objroot)src/bitmap.$(O)
+
+$(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) \
 		 $(objroot)lib/$(LIBJEMALLOC).$(SO)
 	@mkdir -p $(@D)
-	$(CC) -o $@ $< $(call RPATH,$(objroot)lib) -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
+	$(CC) -o $@ $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
 
 build_lib_shared: $(DSOS)
 build_lib_static: $(STATIC_LIBS)
diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index aa21aa5..7b16b6c 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -1,3 +1,5 @@
+#ifndef jemalloc_internal_h
+#define jemalloc_internal_h
 #include <sys/mman.h>
 #include <sys/param.h>
 #include <sys/syscall.h>
@@ -868,3 +870,4 @@ malloc_tsd_funcs(JEMALLOC_INLINE, thread_allocated, thread_allocated_t,
 
 #undef JEMALLOC_H_INLINES
 /******************************************************************************/
+#endif
diff --git a/test/aligned_alloc.c b/test/aligned_alloc.c
index 2a95604..81b8f93 100644
--- a/test/aligned_alloc.c
+++ b/test/aligned_alloc.c
@@ -20,14 +20,14 @@ main(void)
 	unsigned i;
 	void *p, *ps[NITER];
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	/* Test error conditions. */
 	alignment = 0;
 	errno = 0;
 	p = aligned_alloc(alignment, 1);
 	if (p != NULL || errno != EINVAL) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for invalid alignment %zu\n", alignment);
 	}
 
@@ -36,7 +36,7 @@ main(void)
 		errno = 0;
 		p = aligned_alloc(alignment + 1, 1);
 		if (p != NULL || errno != EINVAL) {
-			fprintf(stderr,
+			malloc_printf(
 			    "Expected error for invalid alignment %zu\n",
 			    alignment + 1);
 		}
@@ -52,7 +52,7 @@ main(void)
 	errno = 0;
 	p = aligned_alloc(alignment, size);
 	if (p != NULL || errno != ENOMEM) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for aligned_alloc(%zu, %zu)\n",
 		    alignment, size);
 	}
@@ -67,7 +67,7 @@ main(void)
 	errno = 0;
 	p = aligned_alloc(alignment, size);
 	if (p != NULL || errno != ENOMEM) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for aligned_alloc(%zu, %zu)\n",
 		    alignment, size);
 	}
@@ -81,7 +81,7 @@ main(void)
 	errno = 0;
 	p = aligned_alloc(alignment, size);
 	if (p != NULL || errno != ENOMEM) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for aligned_alloc(&p, %zu, %zu)\n",
 		    alignment, size);
 	}
@@ -93,14 +93,14 @@ main(void)
 	    alignment <= MAXALIGN;
 	    alignment <<= 1) {
 		total = 0;
-		fprintf(stderr, "Alignment: %zu\n", alignment);
+		malloc_printf("Alignment: %zu\n", alignment);
 		for (size = 1;
 		    size < 3 * alignment && size < (1U << 31);
 		    size += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
 			for (i = 0; i < NITER; i++) {
 				ps[i] = aligned_alloc(alignment, size);
 				if (ps[i] == NULL) {
-					fprintf(stderr,
+					malloc_printf(
 					    "Error for size %zu (%#zx): %s\n",
 					    size, size, strerror(errno));
 					exit(1);
@@ -118,6 +118,6 @@ main(void)
 		}
 	}
 
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (0);
 }
diff --git a/test/allocated.c b/test/allocated.c
index 921ab3a..81cd4ca 100644
--- a/test/allocated.c
+++ b/test/allocated.c
@@ -27,7 +27,7 @@ thread_start(void *arg)
 #endif
 			goto label_return;
 		}
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		exit(1);
 	}
@@ -39,7 +39,7 @@ thread_start(void *arg)
 #endif
 			goto label_return;
 		}
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		exit(1);
 	}
@@ -53,7 +53,7 @@ thread_start(void *arg)
 #endif
 			goto label_return;
 		}
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		exit(1);
 	}
@@ -65,7 +65,7 @@ thread_start(void *arg)
 #endif
 			goto label_return;
 		}
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		exit(1);
 	}
@@ -73,7 +73,7 @@ thread_start(void *arg)
 
 	p = malloc(1);
 	if (p == NULL) {
-		fprintf(stderr, "%s(): Error in malloc()\n", __func__);
+		malloc_printf("%s(): Error in malloc()\n", __func__);
 		exit(1);
 	}
 
@@ -108,13 +108,13 @@ main(void)
 	int ret = 0;
 	pthread_t thread;
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	thread_start(NULL);
 
 	if (pthread_create(&thread, NULL, thread_start, NULL)
 	    != 0) {
-		fprintf(stderr, "%s(): Error in pthread_create()\n", __func__);
+		malloc_printf("%s(): Error in pthread_create()\n", __func__);
 		ret = 1;
 		goto label_return;
 	}
@@ -124,7 +124,7 @@ main(void)
 
 	if (pthread_create(&thread, NULL, thread_start, NULL)
 	    != 0) {
-		fprintf(stderr, "%s(): Error in pthread_create()\n", __func__);
+		malloc_printf("%s(): Error in pthread_create()\n", __func__);
 		ret = 1;
 		goto label_return;
 	}
@@ -133,6 +133,6 @@ main(void)
 	thread_start(NULL);
 
 label_return:
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (ret);
 }
diff --git a/test/allocm.c b/test/allocm.c
index 3aa0fd2..c6bc6f8 100644
--- a/test/allocm.c
+++ b/test/allocm.c
@@ -19,52 +19,52 @@ main(void)
 	unsigned i;
 	void *ps[NITER];
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	sz = 42;
 	nsz = 0;
 	r = nallocm(&nsz, sz, 0);
 	if (r != ALLOCM_SUCCESS) {
-		fprintf(stderr, "Unexpected nallocm() error\n");
+		malloc_printf("Unexpected nallocm() error\n");
 		abort();
 	}
 	rsz = 0;
 	r = allocm(&p, &rsz, sz, 0);
 	if (r != ALLOCM_SUCCESS) {
-		fprintf(stderr, "Unexpected allocm() error\n");
+		malloc_printf("Unexpected allocm() error\n");
 		abort();
 	}
 	if (rsz < sz)
-		fprintf(stderr, "Real size smaller than expected\n");
+		malloc_printf("Real size smaller than expected\n");
 	if (nsz != rsz)
-		fprintf(stderr, "nallocm()/allocm() rsize mismatch\n");
+		malloc_printf("nallocm()/allocm() rsize mismatch\n");
 	if (dallocm(p, 0) != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected dallocm() error\n");
+		malloc_printf("Unexpected dallocm() error\n");
 
 	r = allocm(&p, NULL, sz, 0);
 	if (r != ALLOCM_SUCCESS) {
-		fprintf(stderr, "Unexpected allocm() error\n");
+		malloc_printf("Unexpected allocm() error\n");
 		abort();
 	}
 	if (dallocm(p, 0) != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected dallocm() error\n");
+		malloc_printf("Unexpected dallocm() error\n");
 
 	nsz = 0;
 	r = nallocm(&nsz, sz, ALLOCM_ZERO);
 	if (r != ALLOCM_SUCCESS) {
-		fprintf(stderr, "Unexpected nallocm() error\n");
+		malloc_printf("Unexpected nallocm() error\n");
 		abort();
 	}
 	rsz = 0;
 	r = allocm(&p, &rsz, sz, ALLOCM_ZERO);
 	if (r != ALLOCM_SUCCESS) {
-		fprintf(stderr, "Unexpected allocm() error\n");
+		malloc_printf("Unexpected allocm() error\n");
 		abort();
 	}
 	if (nsz != rsz)
-		fprintf(stderr, "nallocm()/allocm() rsize mismatch\n");
+		malloc_printf("nallocm()/allocm() rsize mismatch\n");
 	if (dallocm(p, 0) != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected dallocm() error\n");
+		malloc_printf("Unexpected dallocm() error\n");
 
 #if LG_SIZEOF_PTR == 3
 	alignment = UINT64_C(0x8000000000000000);
@@ -76,19 +76,19 @@ main(void)
 	nsz = 0;
 	r = nallocm(&nsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for nallocm(&nsz, %zu, %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	rsz = 0;
 	r = allocm(&p, &rsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for allocm(&p, %zu, %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	if (nsz != rsz)
-		fprintf(stderr, "nallocm()/allocm() rsize mismatch\n");
+		malloc_printf("nallocm()/allocm() rsize mismatch\n");
 
 #if LG_SIZEOF_PTR == 3
 	alignment = UINT64_C(0x4000000000000000);
@@ -100,11 +100,11 @@ main(void)
 	nsz = 0;
 	r = nallocm(&nsz, sz, ALLOCM_ALIGN(alignment));
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected nallocm() error\n");
+		malloc_printf("Unexpected nallocm() error\n");
 	rsz = 0;
 	r = allocm(&p, &rsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for allocm(&p, %zu, %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
@@ -118,19 +118,19 @@ main(void)
 	nsz = 0;
 	r = nallocm(&nsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for nallocm(&nsz, %zu, %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	rsz = 0;
 	r = allocm(&p, &rsz, sz, ALLOCM_ALIGN(alignment));
 	if (r == ALLOCM_SUCCESS) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for allocm(&p, %zu, %#x)\n",
 		    sz, ALLOCM_ALIGN(alignment));
 	}
 	if (nsz != rsz)
-		fprintf(stderr, "nallocm()/allocm() rsize mismatch\n");
+		malloc_printf("nallocm()/allocm() rsize mismatch\n");
 
 	for (i = 0; i < NITER; i++)
 		ps[i] = NULL;
@@ -139,7 +139,7 @@ main(void)
 	    alignment <= MAXALIGN;
 	    alignment <<= 1) {
 		total = 0;
-		fprintf(stderr, "Alignment: %zu\n", alignment);
+		malloc_printf("Alignment: %zu\n", alignment);
 		for (sz = 1;
 		    sz < 3 * alignment && sz < (1U << 31);
 		    sz += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
@@ -148,7 +148,7 @@ main(void)
 				r = nallocm(&nsz, sz,
 				    ALLOCM_ALIGN(alignment) | ALLOCM_ZERO);
 				if (r != ALLOCM_SUCCESS) {
-					fprintf(stderr,
+					malloc_printf(
 					    "nallocm() error for size %zu"
 					    " (%#zx): %d\n",
 					    sz, sz, r);
@@ -158,24 +158,24 @@ main(void)
 				r = allocm(&ps[i], &rsz, sz,
 				    ALLOCM_ALIGN(alignment) | ALLOCM_ZERO);
 				if (r != ALLOCM_SUCCESS) {
-					fprintf(stderr,
+					malloc_printf(
 					    "allocm() error for size %zu"
 					    " (%#zx): %d\n",
 					    sz, sz, r);
 					exit(1);
 				}
 				if (rsz < sz) {
-					fprintf(stderr,
+					malloc_printf(
 					    "Real size smaller than"
 					    " expected\n");
 				}
 				if (nsz != rsz) {
-					fprintf(stderr,
+					malloc_printf(
 					    "nallocm()/allocm() rsize"
 					    " mismatch\n");
 				}
 				if ((uintptr_t)p & (alignment-1)) {
-					fprintf(stderr,
+					malloc_printf(
 					    "%p inadequately aligned for"
 					    " alignment: %zu\n", p, alignment);
 				}
@@ -193,6 +193,6 @@ main(void)
 		}
 	}
 
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (0);
 }
diff --git a/test/bitmap.c b/test/bitmap.c
index adfaacf..ee9b1ec 100644
--- a/test/bitmap.c
+++ b/test/bitmap.c
@@ -7,12 +7,6 @@
  * */
 #include <assert.h>
 
-/*
- * Directly include the bitmap code, since it isn't exposed outside
- * libjemalloc.
- */
-#include "../src/bitmap.c"
-
 #if (LG_BITMAP_MAXBITS > 12)
 #  define MAXBITS	4500
 #else
@@ -144,7 +138,7 @@ test_bitmap_sfu(void)
 int
 main(void)
 {
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	test_bitmap_size();
 	test_bitmap_init();
@@ -152,6 +146,6 @@ main(void)
 	test_bitmap_unset();
 	test_bitmap_sfu();
 
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (0);
 }
diff --git a/test/jemalloc_test.h.in b/test/jemalloc_test.h.in
index 0c48895..58fa08e 100644
--- a/test/jemalloc_test.h.in
+++ b/test/jemalloc_test.h.in
@@ -4,3 +4,4 @@
  * have a different name.
  */
 #include "jemalloc/jemalloc at install_suffix@.h"
+#include "jemalloc/internal/jemalloc_internal.h"
diff --git a/test/mremap.c b/test/mremap.c
index cac3bd8..84c0349 100644
--- a/test/mremap.c
+++ b/test/mremap.c
@@ -14,12 +14,12 @@ main(void)
 	size_t sz, lg_chunk, chunksize, i;
 	char *p, *q;
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	sz = sizeof(lg_chunk);
 	if ((err = mallctl("opt.lg_chunk", &lg_chunk, &sz, NULL, 0))) {
 		assert(err != ENOENT);
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		ret = 1;
 		goto label_return;
@@ -28,7 +28,7 @@ main(void)
 
 	p = (char *)malloc(chunksize);
 	if (p == NULL) {
-		fprintf(stderr, "malloc(%zu) --> %p\n", chunksize, p);
+		malloc_printf("malloc(%zu) --> %p\n", chunksize, p);
 		ret = 1;
 		goto label_return;
 	}
@@ -36,7 +36,7 @@ main(void)
 
 	q = (char *)realloc(p, chunksize * 2);
 	if (q == NULL) {
-		fprintf(stderr, "realloc(%p, %zu) --> %p\n", p, chunksize * 2,
+		malloc_printf("realloc(%p, %zu) --> %p\n", p, chunksize * 2,
 		    q);
 		ret = 1;
 		goto label_return;
@@ -49,7 +49,7 @@ main(void)
 
 	q = (char *)realloc(p, chunksize);
 	if (q == NULL) {
-		fprintf(stderr, "realloc(%p, %zu) --> %p\n", p, chunksize, q);
+		malloc_printf("realloc(%p, %zu) --> %p\n", p, chunksize, q);
 		ret = 1;
 		goto label_return;
 	}
@@ -61,6 +61,6 @@ main(void)
 
 	ret = 0;
 label_return:
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (ret);
 }
diff --git a/test/posix_memalign.c b/test/posix_memalign.c
index 0ea35c8..e1302df 100644
--- a/test/posix_memalign.c
+++ b/test/posix_memalign.c
@@ -21,13 +21,13 @@ main(void)
 	int err;
 	void *p, *ps[NITER];
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	/* Test error conditions. */
 	for (alignment = 0; alignment < sizeof(void *); alignment++) {
 		err = posix_memalign(&p, alignment, 1);
 		if (err != EINVAL) {
-			fprintf(stderr,
+			malloc_printf(
 			    "Expected error for invalid alignment %zu\n",
 			    alignment);
 		}
@@ -37,7 +37,7 @@ main(void)
 	    alignment <<= 1) {
 		err = posix_memalign(&p, alignment + 1, 1);
 		if (err == 0) {
-			fprintf(stderr,
+			malloc_printf(
 			    "Expected error for invalid alignment %zu\n",
 			    alignment + 1);
 		}
@@ -52,7 +52,7 @@ main(void)
 #endif
 	err = posix_memalign(&p, alignment, size);
 	if (err == 0) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for posix_memalign(&p, %zu, %zu)\n",
 		    alignment, size);
 	}
@@ -66,7 +66,7 @@ main(void)
 #endif
 	err = posix_memalign(&p, alignment, size);
 	if (err == 0) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for posix_memalign(&p, %zu, %zu)\n",
 		    alignment, size);
 	}
@@ -79,7 +79,7 @@ main(void)
 #endif
 	err = posix_memalign(&p, alignment, size);
 	if (err == 0) {
-		fprintf(stderr,
+		malloc_printf(
 		    "Expected error for posix_memalign(&p, %zu, %zu)\n",
 		    alignment, size);
 	}
@@ -91,7 +91,7 @@ main(void)
 	    alignment <= MAXALIGN;
 	    alignment <<= 1) {
 		total = 0;
-		fprintf(stderr, "Alignment: %zu\n", alignment);
+		malloc_printf("Alignment: %zu\n", alignment);
 		for (size = 1;
 		    size < 3 * alignment && size < (1U << 31);
 		    size += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
@@ -99,7 +99,7 @@ main(void)
 				err = posix_memalign(&ps[i],
 				    alignment, size);
 				if (err) {
-					fprintf(stderr,
+					malloc_printf(
 					    "Error for size %zu (%#zx): %s\n",
 					    size, size, strerror(err));
 					exit(1);
@@ -117,6 +117,6 @@ main(void)
 		}
 	}
 
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (0);
 }
diff --git a/test/rallocm.c b/test/rallocm.c
index 9c0df40..18db5ee 100644
--- a/test/rallocm.c
+++ b/test/rallocm.c
@@ -15,7 +15,7 @@ main(void)
 	size_t sz, tsz;
 	int r;
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	/* Get page size. */
 	{
@@ -26,51 +26,51 @@ main(void)
 
 	r = allocm(&p, &sz, 42, 0);
 	if (r != ALLOCM_SUCCESS) {
-		fprintf(stderr, "Unexpected allocm() error\n");
+		malloc_printf("Unexpected allocm() error\n");
 		abort();
 	}
 
 	q = p;
 	r = rallocm(&q, &tsz, sz, 0, ALLOCM_NO_MOVE);
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected rallocm() error\n");
+		malloc_printf("Unexpected rallocm() error\n");
 	if (q != p)
-		fprintf(stderr, "Unexpected object move\n");
+		malloc_printf("Unexpected object move\n");
 	if (tsz != sz) {
-		fprintf(stderr, "Unexpected size change: %zu --> %zu\n",
+		malloc_printf("Unexpected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 
 	q = p;
 	r = rallocm(&q, &tsz, sz, 5, ALLOCM_NO_MOVE);
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected rallocm() error\n");
+		malloc_printf("Unexpected rallocm() error\n");
 	if (q != p)
-		fprintf(stderr, "Unexpected object move\n");
+		malloc_printf("Unexpected object move\n");
 	if (tsz != sz) {
-		fprintf(stderr, "Unexpected size change: %zu --> %zu\n",
+		malloc_printf("Unexpected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 
 	q = p;
 	r = rallocm(&q, &tsz, sz + 5, 0, ALLOCM_NO_MOVE);
 	if (r != ALLOCM_ERR_NOT_MOVED)
-		fprintf(stderr, "Unexpected rallocm() result\n");
+		malloc_printf("Unexpected rallocm() result\n");
 	if (q != p)
-		fprintf(stderr, "Unexpected object move\n");
+		malloc_printf("Unexpected object move\n");
 	if (tsz != sz) {
-		fprintf(stderr, "Unexpected size change: %zu --> %zu\n",
+		malloc_printf("Unexpected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 
 	q = p;
 	r = rallocm(&q, &tsz, sz + 5, 0, 0);
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected rallocm() error\n");
+		malloc_printf("Unexpected rallocm() error\n");
 	if (q == p)
-		fprintf(stderr, "Expected object move\n");
+		malloc_printf("Expected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		malloc_printf("Expected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 	p = q;
@@ -78,11 +78,11 @@ main(void)
 
 	r = rallocm(&q, &tsz, pagesize*2, 0, 0);
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected rallocm() error\n");
+		malloc_printf("Unexpected rallocm() error\n");
 	if (q == p)
-		fprintf(stderr, "Expected object move\n");
+		malloc_printf("Expected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		malloc_printf("Expected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 	p = q;
@@ -90,9 +90,9 @@ main(void)
 
 	r = rallocm(&q, &tsz, pagesize*4, 0, 0);
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected rallocm() error\n");
+		malloc_printf("Unexpected rallocm() error\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		malloc_printf("Expected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 	p = q;
@@ -100,28 +100,28 @@ main(void)
 
 	r = rallocm(&q, &tsz, pagesize*2, 0, ALLOCM_NO_MOVE);
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected rallocm() error\n");
+		malloc_printf("Unexpected rallocm() error\n");
 	if (q != p)
-		fprintf(stderr, "Unexpected object move\n");
+		malloc_printf("Unexpected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		malloc_printf("Expected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 	sz = tsz;
 
 	r = rallocm(&q, &tsz, pagesize*4, 0, ALLOCM_NO_MOVE);
 	if (r != ALLOCM_SUCCESS)
-		fprintf(stderr, "Unexpected rallocm() error\n");
+		malloc_printf("Unexpected rallocm() error\n");
 	if (q != p)
-		fprintf(stderr, "Unexpected object move\n");
+		malloc_printf("Unexpected object move\n");
 	if (tsz == sz) {
-		fprintf(stderr, "Expected size change: %zu --> %zu\n",
+		malloc_printf("Expected size change: %zu --> %zu\n",
 		    sz, tsz);
 	}
 	sz = tsz;
 
 	dallocm(p, 0);
 
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (0);
 }
diff --git a/test/thread_arena.c b/test/thread_arena.c
index 9b7b2dd..e443b71 100644
--- a/test/thread_arena.c
+++ b/test/thread_arena.c
@@ -20,14 +20,14 @@ thread_start(void *arg)
 
 	p = malloc(1);
 	if (p == NULL) {
-		fprintf(stderr, "%s(): Error in malloc()\n", __func__);
+		malloc_printf("%s(): Error in malloc()\n", __func__);
 		return (void *)1;
 	}
 
 	size = sizeof(arena_ind);
 	if ((err = mallctl("thread.arena", &arena_ind, &size, &main_arena_ind,
 	    sizeof(main_arena_ind)))) {
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		return (void *)1;
 	}
@@ -35,7 +35,7 @@ thread_start(void *arg)
 	size = sizeof(arena_ind);
 	if ((err = mallctl("thread.arena", &arena_ind, &size, NULL,
 	    0))) {
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		return (void *)1;
 	}
@@ -55,18 +55,18 @@ main(void)
 	pthread_t threads[NTHREADS];
 	unsigned i;
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	p = malloc(1);
 	if (p == NULL) {
-		fprintf(stderr, "%s(): Error in malloc()\n", __func__);
+		malloc_printf("%s(): Error in malloc()\n", __func__);
 		ret = 1;
 		goto label_return;
 	}
 
 	size = sizeof(arena_ind);
 	if ((err = mallctl("thread.arena", &arena_ind, &size, NULL, 0))) {
-		fprintf(stderr, "%s(): Error in mallctl(): %s\n", __func__,
+		malloc_printf("%s(): Error in mallctl(): %s\n", __func__,
 		    strerror(err));
 		ret = 1;
 		goto label_return;
@@ -75,7 +75,7 @@ main(void)
 	for (i = 0; i < NTHREADS; i++) {
 		if (pthread_create(&threads[i], NULL, thread_start,
 		    (void *)&arena_ind) != 0) {
-			fprintf(stderr, "%s(): Error in pthread_create()\n",
+			malloc_printf("%s(): Error in pthread_create()\n",
 			    __func__);
 			ret = 1;
 			goto label_return;
@@ -86,6 +86,6 @@ main(void)
 		pthread_join(threads[i], (void *)&ret);
 
 label_return:
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (ret);
 }
diff --git a/test/thread_tcache_enabled.c b/test/thread_tcache_enabled.c
index 0a3e45a..59b76a2 100644
--- a/test/thread_tcache_enabled.c
+++ b/test/thread_tcache_enabled.c
@@ -79,13 +79,13 @@ main(void)
 	int ret = 0;
 	pthread_t thread;
 
-	fprintf(stderr, "Test begin\n");
+	malloc_printf("Test begin\n");
 
 	thread_start(NULL);
 
 	if (pthread_create(&thread, NULL, thread_start, NULL)
 	    != 0) {
-		fprintf(stderr, "%s(): Error in pthread_create()\n", __func__);
+		malloc_printf("%s(): Error in pthread_create()\n", __func__);
 		ret = 1;
 		goto label_return;
 	}
@@ -95,7 +95,7 @@ main(void)
 
 	if (pthread_create(&thread, NULL, thread_start, NULL)
 	    != 0) {
-		fprintf(stderr, "%s(): Error in pthread_create()\n", __func__);
+		malloc_printf("%s(): Error in pthread_create()\n", __func__);
 		ret = 1;
 		goto label_return;
 	}
@@ -104,6 +104,6 @@ main(void)
 	thread_start(NULL);
 
 label_return:
-	fprintf(stderr, "Test end\n");
+	malloc_printf("Test end\n");
 	return (ret);
 }
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 08:08:29 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 17:08:29 +0200
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
Message-ID: <20120416150829.GA2446@glandium.org>

Hi,

I noticed something "interesting" with the test for VM map holes:
If I compile it manually, it fails:

  Hoped for 0x7f835133d000, got 0x7f8350b3d000
  0x7f835173d000..0x7f835133d000..0x7f8350f3d000..0x7f835073d000..0x7f8350b3d000

Apparently, this happens when *not* linking libm to the testcase. It
also does happen when linking libm and some other library (tried
pthread and stdc++).

Moreover, the test being run on the build machine, which can have a very
different setup from the machine the binary runs on, it is most probably
not reliable to decide whether to disable munmap or not.

Mike


From jasone at canonware.com  Mon Apr 16 12:07:58 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 16 Apr 2012 12:07:58 -0700
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
In-Reply-To: <20120416150829.GA2446@glandium.org>
References: <20120416150829.GA2446@glandium.org>
Message-ID: <B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>

On Apr 16, 2012, at 8:08 AM, Mike Hommey wrote:
> I noticed something "interesting" with the test for VM map holes:
> If I compile it manually, it fails:
> 
>  Hoped for 0x7f835133d000, got 0x7f8350b3d000
>  0x7f835173d000..0x7f835133d000..0x7f8350f3d000..0x7f835073d000..0x7f8350b3d000
> 
> Apparently, this happens when *not* linking libm to the testcase. It
> also does happen when linking libm and some other library (tried
> pthread and stdc++).

What OS is this on?  The test should fail on Linux, but not OS X or FreeBSD.  Linux has a VM map management quirk (on at least x86) that causes accumulation of VM map holes under normal operation.

> Moreover, the test being run on the build machine, which can have a very
> different setup from the machine the binary runs on, it is most probably
> not reliable to decide whether to disable munmap or not.

The AC_CACHE_CHECK() wrapper makes it possible to cross-compile, so although getting this right may be subtle, it should be possible.  I initially added a --disable-munmap configure option, but was reluctant to expose yet another option that has the sole purpose of working around a Linux VM shortcoming.

Jason

From jasone at canonware.com  Mon Apr 16 12:28:16 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 16 Apr 2012 12:28:16 -0700
Subject: [PATCH] Use a make variable instead of preprocessing for srcroot,
	and simplify source files handling
In-Reply-To: <1334243676-20455-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334243606-20354-1-git-send-email-mh+jemalloc@glandium.org>
	<1334243676-20455-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <4F6D039D-40FE-4650-8DBF-8EBE4CED7A23@canonware.com>

On Apr 12, 2012, at 8:14 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> ---
> Makefile.in |   99 ++++++++++++++++++++++++++++++-----------------------------
> 1 file changed, 50 insertions(+), 49 deletions(-)

I'm not keen on the objroot removal diff, conversion from @srcroot@ to $(srcroot), or the removal of paths relative to the top directory.  I see these all as style choices for which the existing choices are reasonable.  Unfortunately, a bunch of other diffs you sent this morning are based on this and the objroot removal diff, which makes them difficult to apply.

Jason

From mh+jemalloc at glandium.org  Mon Apr 16 13:19:13 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 22:19:13 +0200
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
In-Reply-To: <B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>
References: <20120416150829.GA2446@glandium.org>
	<B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>
Message-ID: <20120416201913.GA21542@glandium.org>

On Mon, Apr 16, 2012 at 12:07:58PM -0700, Jason Evans wrote:
> On Apr 16, 2012, at 8:08 AM, Mike Hommey wrote:
> > I noticed something "interesting" with the test for VM map holes: If
> > I compile it manually, it fails:
> > 
> >  Hoped for 0x7f835133d000, got 0x7f8350b3d000
> >  0x7f835173d000..0x7f835133d000..0x7f8350f3d000..0x7f835073d000..0x7f8350b3d000
> > 
> > Apparently, this happens when *not* linking libm to the testcase. It
> > also does happen when linking libm and some other library (tried
> > pthread and stdc++).
> 
> What OS is this on?  The test should fail on Linux, but not OS X or
> FreeBSD.  Linux has a VM map management quirk (on at least x86) that
> causes accumulation of VM map holes under normal operation.

Linux x64. Kernel 3.2.

So, you are saying that this error is the "expected" behaviour, except I
actually don't get it under "normal" conditions (those of configure.ac)

Mike


From mh+jemalloc at glandium.org  Mon Apr 16 13:22:43 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 22:22:43 +0200
Subject: [PATCH] Use a make variable instead of preprocessing for
	srcroot, and simplify source files handling
In-Reply-To: <4F6D039D-40FE-4650-8DBF-8EBE4CED7A23@canonware.com>
References: <1334243606-20354-1-git-send-email-mh+jemalloc@glandium.org>
	<1334243676-20455-1-git-send-email-mh+jemalloc@glandium.org>
	<4F6D039D-40FE-4650-8DBF-8EBE4CED7A23@canonware.com>
Message-ID: <20120416202243.GB21542@glandium.org>

On Mon, Apr 16, 2012 at 12:28:16PM -0700, Jason Evans wrote:
> On Apr 12, 2012, at 8:14 AM, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > --- Makefile.in |   99
> > ++++++++++++++++++++++++++++++----------------------------- 1 file
> > changed, 50 insertions(+), 49 deletions(-)
> 
> I'm not keen on the objroot removal diff, conversion from @srcroot@ to
> $(srcroot), or the removal of paths relative to the top directory.  I
> see these all as style choices for which the existing choices are
> reasonable.  Unfortunately, a bunch of other diffs you sent this
> morning are based on this and the objroot removal diff, which makes
> them difficult to apply.

The diffs I sent today are independent of that patch, and just apply
from 1/7 to 7/7. "[PATCH 3/7] Use make variables instead of preprocessing"
from today, is kind of equivalent to the one you mention, except it
only replaces @*@ with $(*), which makes things much easier to work on.

Mike


From mh+jemalloc at glandium.org  Mon Apr 16 13:57:04 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 22:57:04 +0200
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
In-Reply-To: <20120416201913.GA21542@glandium.org>
References: <20120416150829.GA2446@glandium.org>
	<B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>
	<20120416201913.GA21542@glandium.org>
Message-ID: <20120416205704.GA22638@glandium.org>

On Mon, Apr 16, 2012 at 10:19:13PM +0200, Mike Hommey wrote:
> On Mon, Apr 16, 2012 at 12:07:58PM -0700, Jason Evans wrote:
> > On Apr 16, 2012, at 8:08 AM, Mike Hommey wrote:
> > > I noticed something "interesting" with the test for VM map holes: If
> > > I compile it manually, it fails:
> > > 
> > >  Hoped for 0x7f835133d000, got 0x7f8350b3d000
> > >  0x7f835173d000..0x7f835133d000..0x7f8350f3d000..0x7f835073d000..0x7f8350b3d000
> > > 
> > > Apparently, this happens when *not* linking libm to the testcase. It
> > > also does happen when linking libm and some other library (tried
> > > pthread and stdc++).
> > 
> > What OS is this on?  The test should fail on Linux, but not OS X or
> > FreeBSD.  Linux has a VM map management quirk (on at least x86) that
> > causes accumulation of VM map holes under normal operation.
> 
> Linux x64. Kernel 3.2.
> 
> So, you are saying that this error is the "expected" behaviour, except I
> actually don't get it under "normal" conditions (those of configure.ac)

Since the test actually fails to find what it's supposed to find, why
not just "hardcode" that linux gets no munmap and others do?

Mike


From jasone at canonware.com  Mon Apr 16 13:59:39 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 16 Apr 2012 13:59:39 -0700
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
In-Reply-To: <20120416201913.GA21542@glandium.org>
References: <20120416150829.GA2446@glandium.org>
	<B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>
	<20120416201913.GA21542@glandium.org>
Message-ID: <76DFB457-5BCC-422B-96A8-32FF1C641D7E@canonware.com>

On Apr 16, 2012, at 1:19 PM, Mike Hommey wrote:
> On Mon, Apr 16, 2012 at 12:07:58PM -0700, Jason Evans wrote:
>> On Apr 16, 2012, at 8:08 AM, Mike Hommey wrote:
>>> I noticed something "interesting" with the test for VM map holes: If
>>> I compile it manually, it fails:
>>> 
>>> Hoped for 0x7f835133d000, got 0x7f8350b3d000
>>> 0x7f835173d000..0x7f835133d000..0x7f8350f3d000..0x7f835073d000..0x7f8350b3d000
>>> 
>>> Apparently, this happens when *not* linking libm to the testcase. It
>>> also does happen when linking libm and some other library (tried
>>> pthread and stdc++).
>> 
>> What OS is this on?  The test should fail on Linux, but not OS X or
>> FreeBSD.  Linux has a VM map management quirk (on at least x86) that
>> causes accumulation of VM map holes under normal operation.
> 
> Linux x64. Kernel 3.2.
> 
> So, you are saying that this error is the "expected" behaviour, except I
> actually don't get it under "normal" conditions (those of configure.ac)

Hmm, maybe those extra libraries are creating another hole that's preventing the initial series of mmap calls from getting contiguous memory.  Can you move the two fprintf calls ("Hoped for ?" and the next one) out of the conditional block and pull the resulting output from config.log?  That'll help me understand what's happening so that I can refine the test.  (I can't reproduce the problem on the Linux machines I'm using).

Thanks,
Jason

From mh+jemalloc at glandium.org  Mon Apr 16 14:19:03 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 16 Apr 2012 23:19:03 +0200
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
In-Reply-To: <76DFB457-5BCC-422B-96A8-32FF1C641D7E@canonware.com>
References: <20120416150829.GA2446@glandium.org>
	<B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>
	<20120416201913.GA21542@glandium.org>
	<76DFB457-5BCC-422B-96A8-32FF1C641D7E@canonware.com>
Message-ID: <20120416211903.GA23399@glandium.org>

On Mon, Apr 16, 2012 at 01:59:39PM -0700, Jason Evans wrote:
> On Apr 16, 2012, at 1:19 PM, Mike Hommey wrote:
> > On Mon, Apr 16, 2012 at 12:07:58PM -0700, Jason Evans wrote:
> >> On Apr 16, 2012, at 8:08 AM, Mike Hommey wrote:
> >>> I noticed something "interesting" with the test for VM map holes:
> >>> If I compile it manually, it fails:
> >>> 
> >>> Hoped for 0x7f835133d000, got 0x7f8350b3d000
> >>> 0x7f835173d000..0x7f835133d000..0x7f8350f3d000..0x7f835073d000..0x7f8350b3d000
> >>> 
> >>> Apparently, this happens when *not* linking libm to the testcase.
> >>> It also does happen when linking libm and some other library
> >>> (tried pthread and stdc++).
> >> 
> >> What OS is this on?  The test should fail on Linux, but not OS X or
> >> FreeBSD.  Linux has a VM map management quirk (on at least x86)
> >> that causes accumulation of VM map holes under normal operation.
> > 
> > Linux x64. Kernel 3.2.
> > 
> > So, you are saying that this error is the "expected" behaviour,
> > except I actually don't get it under "normal" conditions (those of
> > configure.ac)
> 
> Hmm, maybe those extra libraries are creating another hole that's
> preventing the initial series of mmap calls from getting contiguous
> memory.  Can you move the two fprintf calls ("Hoped for ?" and the
> next one) out of the conditional block and pull the resulting output
> from config.log?  That'll help me understand what's happening so that
> I can refine the test.  (I can't reproduce the problem on the Linux
> machines I'm using).

Hoped for 0x7f4d5d7d6000, got 0x7f4d5cfd6000
0x7f4d5dbd6000..0x7f4d5d7d6000..0x7f4d5d3d6000..0x7f4d5cbd6000..0x7f4d5cfd6000

Hoped for 0x7f82e5237000, got 0x7f82e5237000
0x7f82e5637000..0x7f82e5237000..0x7f82e4e37000..0x7f82e4637000..0x7f82e5237000

But anyways, why do you want to do a configure run test when you know
the result you want?

Mike


From jasone at canonware.com  Mon Apr 16 14:40:52 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 16 Apr 2012 14:40:52 -0700
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
In-Reply-To: <20120416211903.GA23399@glandium.org>
References: <20120416150829.GA2446@glandium.org>
	<B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>
	<20120416201913.GA21542@glandium.org>
	<76DFB457-5BCC-422B-96A8-32FF1C641D7E@canonware.com>
	<20120416211903.GA23399@glandium.org>
Message-ID: <A6193C8E-7F70-4BFC-80EC-C8E00C87CACD@canonware.com>

On Apr 16, 2012, at 2:19 PM, Mike Hommey wrote:
> Hoped for 0x7f82e5237000, got 0x7f82e5237000
> 0x7f82e5637000..0x7f82e5237000..0x7f82e4e37000..0x7f82e4637000..0x7f82e5237000

Huh.  The only explanation I can think of is that the dynamic loader is calling mmap in the midst of the mmap/munmap calls, thus resetting the "start from" address to use for address scanning.

> But anyways, why do you want to do a configure run test when you know
> the result you want?

I wanted it to "just work", but you've convinced me that it's hard to make a reliable test.  I'll add --disable-munmap.

Thanks,
Jason

From jasone at canonware.com  Mon Apr 16 14:42:35 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 16 Apr 2012 14:42:35 -0700
Subject: [PATCH] Use a make variable instead of preprocessing for srcroot,
	and simplify source files handling
In-Reply-To: <20120416202243.GB21542@glandium.org>
References: <1334243606-20354-1-git-send-email-mh+jemalloc@glandium.org>
	<1334243676-20455-1-git-send-email-mh+jemalloc@glandium.org>
	<4F6D039D-40FE-4650-8DBF-8EBE4CED7A23@canonware.com>
	<20120416202243.GB21542@glandium.org>
Message-ID: <F296F352-7989-48DE-B1D6-E4C138B78C34@canonware.com>

On Apr 16, 2012, at 1:22 PM, Mike Hommey wrote:
> On Mon, Apr 16, 2012 at 12:28:16PM -0700, Jason Evans wrote:
>> 
>> 
>> I'm not keen on the objroot removal diff, conversion from @srcroot@ to
>> $(srcroot), or the removal of paths relative to the top directory.  I
>> see these all as style choices for which the existing choices are
>> reasonable.  Unfortunately, a bunch of other diffs you sent this
>> morning are based on this and the objroot removal diff, which makes
>> them difficult to apply.
> 
> The diffs I sent today are independent of that patch, and just apply
> from 1/7 to 7/7. "[PATCH 3/7] Use make variables instead of preprocessing"
> from today, is kind of equivalent to the one you mention, except it
> only replaces @*@ with $(*), which makes things much easier to work on.

Okay, thanks for the clarification.  I'll try to get the diffs committed this afternoon.

Jason

From mh+jemalloc at glandium.org  Mon Apr 16 23:03:09 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 08:03:09 +0200
Subject: [7ca0fdf] Disable munmap() if it causes VM map holes
In-Reply-To: <A6193C8E-7F70-4BFC-80EC-C8E00C87CACD@canonware.com>
References: <20120416150829.GA2446@glandium.org>
	<B2CED6BA-53C5-4B1F-AD70-BC24E3960B04@canonware.com>
	<20120416201913.GA21542@glandium.org>
	<76DFB457-5BCC-422B-96A8-32FF1C641D7E@canonware.com>
	<20120416211903.GA23399@glandium.org>
	<A6193C8E-7F70-4BFC-80EC-C8E00C87CACD@canonware.com>
Message-ID: <20120417060309.GA31907@glandium.org>

On Mon, Apr 16, 2012 at 02:40:52PM -0700, Jason Evans wrote:
> On Apr 16, 2012, at 2:19 PM, Mike Hommey wrote:
> > Hoped for 0x7f82e5237000, got 0x7f82e5237000
> > 0x7f82e5637000..0x7f82e5237000..0x7f82e4e37000..0x7f82e4637000..0x7f82e5237000
> 
> Huh.  The only explanation I can think of is that the dynamic loader
> is calling mmap in the midst of the mmap/munmap calls, thus resetting
> the "start from" address to use for address scanning.

It's not even that. The only mmaps happening are these ones. The dynamic
linker is done when main is entered.

Mike


From jasone at canonware.com  Mon Apr 16 23:07:23 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 16 Apr 2012 23:07:23 -0700
Subject: [PATCH] Use a make variable instead of preprocessing for srcroot,
	and simplify source files handling
In-Reply-To: <F296F352-7989-48DE-B1D6-E4C138B78C34@canonware.com>
References: <1334243606-20354-1-git-send-email-mh+jemalloc@glandium.org>
	<1334243676-20455-1-git-send-email-mh+jemalloc@glandium.org>
	<4F6D039D-40FE-4650-8DBF-8EBE4CED7A23@canonware.com>
	<20120416202243.GB21542@glandium.org>
	<F296F352-7989-48DE-B1D6-E4C138B78C34@canonware.com>
Message-ID: <6AE0A1DF-583D-4017-842F-6C731C7D0A76@canonware.com>

On Apr 16, 2012, at 2:42 PM, Jason Evans wrote:
> On Apr 16, 2012, at 1:22 PM, Mike Hommey wrote:
>> On Mon, Apr 16, 2012 at 12:28:16PM -0700, Jason Evans wrote:
>>> I'm not keen on the objroot removal diff, conversion from @srcroot@ to
>>> $(srcroot), or the removal of paths relative to the top directory.  I
>>> see these all as style choices for which the existing choices are
>>> reasonable.  Unfortunately, a bunch of other diffs you sent this
>>> morning are based on this and the objroot removal diff, which makes
>>> them difficult to apply.
>> 
>> The diffs I sent today are independent of that patch, and just apply
>> from 1/7 to 7/7. "[PATCH 3/7] Use make variables instead of preprocessing"
>> from today, is kind of equivalent to the one you mention, except it
>> only replaces @*@ with $(*), which makes things much easier to work on.
> 
> Okay, thanks for the clarification.  I'll try to get the diffs committed this afternoon.

All applied now.  Good stuff.

Thanks,
Jason

From mh+jemalloc at glandium.org  Mon Apr 16 23:51:34 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 08:51:34 +0200
Subject: [PATCH] Make versioned shared library suffix configurable
Message-ID: <1334645494-7462-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

This allows for different patterns for file names:
- lib.so.version for e.g. Linux
- lib.version.dylib for OSX (which is much more common than
lib.dylib.version)
- lib.dll for Windows (no version at all).
---
 Makefile.in  |   21 ++++++++++++++-------
 configure.ac |    3 +++
 2 files changed, 17 insertions(+), 7 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 0dfddea..d426cbd 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -47,6 +47,7 @@ cfgoutputs_out := @cfgoutputs_out@
 enable_autogen := @enable_autogen@
 enable_experimental := @enable_experimental@
 DSO_LDFLAGS = @DSO_LDFLAGS@
+SOREV = @SOREV@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
@@ -72,9 +73,11 @@ ifeq (macho, $(ABI))
 CSRCS += $(srcroot)src/zone.c
 endif
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
-DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) \
-	$(objroot)lib/$(LIBJEMALLOC).$(SO) \
-	$(objroot)lib/$(LIBJEMALLOC)_pic.$(A)
+DSOS := $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) \
+	$(objroot)lib/$(LIBJEMALLOC).$(SOREV)
+ifneq ($(SOREV),$(SO))
+DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
+endif
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
 DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.html)
@@ -127,11 +130,13 @@ $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
-%.$(SO) : %.$(SO).$(REV)
+ifneq ($(SOREV),$(SO))
+%.$(SO) : %.$(SOREV)
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
+endif
 
-$(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
+$(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	@mkdir -p $(@D)
 	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) -o $@ $+ $(LDFLAGS) $(LIBS)
 
@@ -175,8 +180,10 @@ done
 
 install_lib_shared: $(DSOS)
 	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)
-	ln -sf $(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
+	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) $(LIBDIR)
+ifneq ($(SOREV),$(SO))
+	ln -sf $(LIBJEMALLOC).$(SOREV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
+endif
 
 install_lib_static: $(DSOS) $(STATIC_LIBS)
 	install -d $(LIBDIR)
diff --git a/configure.ac b/configure.ac
index 8b9ba00..7c4e8ca 100644
--- a/configure.ac
+++ b/configure.ac
@@ -201,6 +201,7 @@ exe=
 lib="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
+SOREV='$(SO).$(REV)'
 
 dnl Heap profiling uses the log(3) function.
 LIBS="$LIBS -lm"
@@ -222,6 +223,7 @@ case "${host}" in
 	so="dylib"
 	force_tls="0"
 	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
+	SOREV='$(REV).$(SO)'
 	;;
   *-*-freebsd*)
 	CFLAGS="$CFLAGS"
@@ -282,6 +284,7 @@ AC_SUBST([a])
 AC_SUBST([exe])
 AC_SUBST([lib])
 AC_SUBST([DSO_LDFLAGS])
+AC_SUBST([SOREV])
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 16 23:56:13 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 08:56:13 +0200
Subject: [PATCH] Make versioned shared library suffix configurable
In-Reply-To: <1334645494-7462-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334645494-7462-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <20120417065613.GA8147@glandium.org>

On Tue, Apr 17, 2012 at 08:51:34AM +0200, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> This allows for different patterns for file names:
> - lib.so.version for e.g. Linux
> - lib.version.dylib for OSX (which is much more common than
> lib.dylib.version)
> - lib.dll for Windows (no version at all).
> ---
>  Makefile.in  |   21 ++++++++++++++-------
>  configure.ac |    3 +++
>  2 files changed, 17 insertions(+), 7 deletions(-)

Just figured there's also a bit in bin/jemalloc.sh. New patch incoming.

Mike


From mh+jemalloc at glandium.org  Mon Apr 16 23:58:49 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 08:58:49 +0200
Subject: [PATCH] Make versioned shared library suffix configurable
In-Reply-To: <20120417065613.GA8147@glandium.org>
References: <20120417065613.GA8147@glandium.org>
Message-ID: <1334645929-8833-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

This allows for different patterns for file names:
- lib.so.version for e.g. Linux
- lib.version.dylib for OSX (which is much more common than
lib.dylib.version)
- lib.dll for Windows (no version at all).
---
 Makefile.in        |   21 ++++++++++++++-------
 bin/jemalloc.sh.in |    2 +-
 configure.ac       |    3 +++
 3 files changed, 18 insertions(+), 8 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 0dfddea..d426cbd 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -47,6 +47,7 @@ cfgoutputs_out := @cfgoutputs_out@
 enable_autogen := @enable_autogen@
 enable_experimental := @enable_experimental@
 DSO_LDFLAGS = @DSO_LDFLAGS@
+SOREV = @SOREV@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
@@ -72,9 +73,11 @@ ifeq (macho, $(ABI))
 CSRCS += $(srcroot)src/zone.c
 endif
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
-DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) \
-	$(objroot)lib/$(LIBJEMALLOC).$(SO) \
-	$(objroot)lib/$(LIBJEMALLOC)_pic.$(A)
+DSOS := $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) \
+	$(objroot)lib/$(LIBJEMALLOC).$(SOREV)
+ifneq ($(SOREV),$(SO))
+DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
+endif
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
 DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.html)
@@ -127,11 +130,13 @@ $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
-%.$(SO) : %.$(SO).$(REV)
+ifneq ($(SOREV),$(SO))
+%.$(SO) : %.$(SOREV)
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
+endif
 
-$(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
+$(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	@mkdir -p $(@D)
 	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) -o $@ $+ $(LDFLAGS) $(LIBS)
 
@@ -175,8 +180,10 @@ done
 
 install_lib_shared: $(DSOS)
 	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)
-	ln -sf $(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
+	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) $(LIBDIR)
+ifneq ($(SOREV),$(SO))
+	ln -sf $(LIBJEMALLOC).$(SOREV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
+endif
 
 install_lib_static: $(DSOS) $(STATIC_LIBS)
 	install -d $(LIBDIR)
diff --git a/bin/jemalloc.sh.in b/bin/jemalloc.sh.in
index 56cdfaf..cdf3673 100644
--- a/bin/jemalloc.sh.in
+++ b/bin/jemalloc.sh.in
@@ -4,6 +4,6 @@ prefix=@prefix@
 exec_prefix=@exec_prefix@
 libdir=@libdir@
 
- at LD_PRELOAD_VAR@=${libdir}/libjemalloc. at so@. at rev@
+ at LD_PRELOAD_VAR@=${libdir}/libjemalloc. at SOREV@
 export @LD_PRELOAD_VAR@
 exec "$@"
diff --git a/configure.ac b/configure.ac
index 3a7a245..0f78c61 100644
--- a/configure.ac
+++ b/configure.ac
@@ -201,6 +201,7 @@ exe=
 lib="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
+SOREV='$(SO).$(REV)'
 
 dnl Heap profiling uses the log(3) function.
 LIBS="$LIBS -lm"
@@ -223,6 +224,7 @@ case "${host}" in
 	so="dylib"
 	force_tls="0"
 	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
+	SOREV='$(REV).$(SO)'
 	;;
   *-*-freebsd*)
 	CFLAGS="$CFLAGS"
@@ -284,6 +286,7 @@ AC_SUBST([a])
 AC_SUBST([exe])
 AC_SUBST([lib])
 AC_SUBST([DSO_LDFLAGS])
+AC_SUBST([SOREV])
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 17 03:01:04 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 12:01:04 +0200
Subject: [PATCH] Simplify TSD without TLS
Message-ID: <1334656864-24573-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 include/jemalloc/internal/tsd.h |   85 +++++++++------------------------------
 1 file changed, 20 insertions(+), 65 deletions(-)

diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index 35ae5e3..db85ebb 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -190,36 +190,15 @@ a_name##_tsd_set(a_type *val)						\
 #else
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
-/* Data structure. */							\
-typedef struct {							\
-	bool	isstatic;						\
-	bool	initialized;						\
-	a_type	val;							\
-} a_name##_tsd_wrapper_t;						\
 /* Initialization/cleanup. */						\
 a_attr void								\
 a_name##_tsd_cleanup_wrapper(void *arg)					\
 {									\
-	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)arg;\
+	a_type *value = (a_type *)arg;					\
 									\
-	if (a_cleanup != malloc_tsd_no_cleanup &&			\
-	    wrapper->initialized) {					\
-		wrapper->initialized = false;				\
-		a_cleanup(&wrapper->val);				\
-		if (wrapper->initialized) {				\
-			/* Trigger another cleanup round. */		\
-			if (pthread_setspecific(a_name##_tsd,		\
-			    (void *)wrapper)) {				\
-				malloc_write("<jemalloc>: Error"	\
-				    " setting TSD for "#a_name"\n");	\
-				if (opt_abort)				\
-					abort();			\
-			}						\
-			return;						\
-		}							\
-	}								\
-	if (wrapper->isstatic == false)					\
-		malloc_tsd_dalloc(wrapper);				\
+	if (a_cleanup != malloc_tsd_no_cleanup)				\
+		a_cleanup(value);					\
+	malloc_tsd_dalloc(value);					\
 }									\
 a_attr bool								\
 a_name##_tsd_boot(void)							\
@@ -232,58 +211,34 @@ a_name##_tsd_boot(void)							\
 	return (false);							\
 }									\
 /* Get/set. */								\
-a_attr a_name##_tsd_wrapper_t *						\
-a_name##_tsd_get_wrapper(void)						\
+a_attr a_type *								\
+a_name##_tsd_get(void)							\
 {									\
-	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)	\
-	    pthread_getspecific(a_name##_tsd);				\
+	a_type *value;							\
 									\
-	if (wrapper == NULL) {						\
-		wrapper = (a_name##_tsd_wrapper_t *)			\
-		    malloc_tsd_malloc(sizeof(a_name##_tsd_wrapper_t));	\
-		if (wrapper == NULL) {					\
-			static a_name##_tsd_wrapper_t			\
-			    a_name##_tsd_static_data =			\
-			    {true, false, a_initializer};		\
+	assert(a_name##_booted);					\
+	value = (a_type *) pthread_getspecific(a_name##_tsd);		\
+	if (value == NULL) {						\
+		a_type tsd_init_data = a_initializer;			\
+		value = (a_type *) malloc_tsd_malloc(sizeof(a_type));	\
+		if (value == NULL) {					\
 			malloc_write("<jemalloc>: Error allocating"	\
 			    " TSD for "#a_name"\n");			\
-			if (opt_abort)					\
-				abort();				\
-			wrapper = &a_name##_tsd_static_data;		\
-		} else {						\
-			static a_type tsd_static_data = a_initializer;	\
-			wrapper->isstatic = false;			\
-			wrapper->val = tsd_static_data;			\
-		}							\
-		if (pthread_setspecific(a_name##_tsd,			\
-		    (void *)wrapper)) {					\
-			malloc_write("<jemalloc>: Error setting"	\
-			    " TSD for "#a_name"\n");			\
-			if (opt_abort)					\
-				abort();				\
+			abort();					\
 		}							\
+		*value = tsd_init_data;					\
+		pthread_setspecific(a_name##_tsd, (void *)value);	\
 	}								\
-	return (wrapper);						\
-}									\
-a_attr a_type *								\
-a_name##_tsd_get(void)							\
-{									\
-	a_name##_tsd_wrapper_t *wrapper;				\
-									\
-	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
-	return (&wrapper->val);						\
+	return (value);							\
 }									\
 a_attr void								\
 a_name##_tsd_set(a_type *val)						\
 {									\
-	a_name##_tsd_wrapper_t *wrapper;				\
+	a_type *value;							\
 									\
 	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
-	wrapper->val = *(val);						\
-	if (a_cleanup != malloc_tsd_no_cleanup)				\
-		wrapper->initialized = true;				\
+	value = a_name##_tsd_get();					\
+	*value = *(val);						\
 }
 #endif
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 17 03:07:15 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 12:07:15 +0200
Subject: [PATCH] Simplify TSD without TLS
In-Reply-To: <1334656864-24573-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334656864-24573-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <20120417100715.GA24797@glandium.org>

On Tue, Apr 17, 2012 at 12:01:04PM +0200, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> ---
>  include/jemalloc/internal/tsd.h |   85 +++++++++------------------------------
>  1 file changed, 20 insertions(+), 65 deletions(-)

Just a few notes: this implementation is 95% the same as the one I have
for mingw. I'm even tempted to make them actually share the code,
because it would make changes/fixes to one be used in the other.

It doesn't use a static variable when malloc_tsd_malloc
fails, but unconditionally aborts instead. Using a static variable is
due to fail with multithreading anyways. The 'initialized' variable is
not necessary either, as pthread_key's cleanup function won't be called
unless a non-NULL value has been set with pthread_setspecific.

Mike


From mh+jemalloc at glandium.org  Tue Apr 17 03:14:17 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 12:14:17 +0200
Subject: [PATCH] Simplify TSD without TLS
In-Reply-To: <20120417100715.GA24797@glandium.org>
References: <1334656864-24573-1-git-send-email-mh+jemalloc@glandium.org>
	<20120417100715.GA24797@glandium.org>
Message-ID: <20120417101417.GA25673@glandium.org>

On Tue, Apr 17, 2012 at 12:07:15PM +0200, Mike Hommey wrote:
> On Tue, Apr 17, 2012 at 12:01:04PM +0200, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > ---
> >  include/jemalloc/internal/tsd.h |   85 +++++++++------------------------------
> >  1 file changed, 20 insertions(+), 65 deletions(-)
> 
> Just a few notes: this implementation is 95% the same as the one I have
> for mingw. I'm even tempted to make them actually share the code,
> because it would make changes/fixes to one be used in the other.
> 
> It doesn't use a static variable when malloc_tsd_malloc
> fails, but unconditionally aborts instead. Using a static variable is
> due to fail with multithreading anyways. The 'initialized' variable is
> not necessary either, as pthread_key's cleanup function won't be called
> unless a non-NULL value has been set with pthread_setspecific.

... and it was missing a check for pthread_setspecific. Fixed patch
incoming.

Mike


From mh+jemalloc at glandium.org  Tue Apr 17 03:15:07 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 12:15:07 +0200
Subject: [PATCH] Simplify TSD without TLS
In-Reply-To: <20120417101417.GA25673@glandium.org>
References: <20120417101417.GA25673@glandium.org>
Message-ID: <1334657707-25772-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 include/jemalloc/internal/tsd.h |   87 +++++++++++----------------------------
 1 file changed, 23 insertions(+), 64 deletions(-)

diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index 35ae5e3..c6ed683 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -190,36 +190,15 @@ a_name##_tsd_set(a_type *val)						\
 #else
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
-/* Data structure. */							\
-typedef struct {							\
-	bool	isstatic;						\
-	bool	initialized;						\
-	a_type	val;							\
-} a_name##_tsd_wrapper_t;						\
 /* Initialization/cleanup. */						\
 a_attr void								\
 a_name##_tsd_cleanup_wrapper(void *arg)					\
 {									\
-	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)arg;\
+	a_type *value = (a_type *)arg;					\
 									\
-	if (a_cleanup != malloc_tsd_no_cleanup &&			\
-	    wrapper->initialized) {					\
-		wrapper->initialized = false;				\
-		a_cleanup(&wrapper->val);				\
-		if (wrapper->initialized) {				\
-			/* Trigger another cleanup round. */		\
-			if (pthread_setspecific(a_name##_tsd,		\
-			    (void *)wrapper)) {				\
-				malloc_write("<jemalloc>: Error"	\
-				    " setting TSD for "#a_name"\n");	\
-				if (opt_abort)				\
-					abort();			\
-			}						\
-			return;						\
-		}							\
-	}								\
-	if (wrapper->isstatic == false)					\
-		malloc_tsd_dalloc(wrapper);				\
+	if (a_cleanup != malloc_tsd_no_cleanup)				\
+		a_cleanup(value);					\
+	malloc_tsd_dalloc(value);					\
 }									\
 a_attr bool								\
 a_name##_tsd_boot(void)							\
@@ -232,58 +211,38 @@ a_name##_tsd_boot(void)							\
 	return (false);							\
 }									\
 /* Get/set. */								\
-a_attr a_name##_tsd_wrapper_t *						\
-a_name##_tsd_get_wrapper(void)						\
+a_attr a_type *								\
+a_name##_tsd_get(void)							\
 {									\
-	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)	\
-	    pthread_getspecific(a_name##_tsd);				\
+	a_type *value;							\
 									\
-	if (wrapper == NULL) {						\
-		wrapper = (a_name##_tsd_wrapper_t *)			\
-		    malloc_tsd_malloc(sizeof(a_name##_tsd_wrapper_t));	\
-		if (wrapper == NULL) {					\
-			static a_name##_tsd_wrapper_t			\
-			    a_name##_tsd_static_data =			\
-			    {true, false, a_initializer};		\
+	assert(a_name##_booted);					\
+	value = (a_type *) pthread_getspecific(a_name##_tsd);		\
+	if (value == NULL) {						\
+		a_type tsd_init_data = a_initializer;			\
+		value = (a_type *) malloc_tsd_malloc(sizeof(a_type));	\
+		if (value == NULL) {					\
 			malloc_write("<jemalloc>: Error allocating"	\
 			    " TSD for "#a_name"\n");			\
-			if (opt_abort)					\
-				abort();				\
-			wrapper = &a_name##_tsd_static_data;		\
-		} else {						\
-			static a_type tsd_static_data = a_initializer;	\
-			wrapper->isstatic = false;			\
-			wrapper->val = tsd_static_data;			\
+			abort();					\
 		}							\
-		if (pthread_setspecific(a_name##_tsd,			\
-		    (void *)wrapper)) {					\
-			malloc_write("<jemalloc>: Error setting"	\
-			    " TSD for "#a_name"\n");			\
-			if (opt_abort)					\
-				abort();				\
+		*value = tsd_init_data;					\
+		if (pthread_setspecific(a_name##_tsd, (void *)value)) {	\
+			malloc_write("<jemalloc>: Error"		\
+			    " setting TSD for "#a_name"\n");		\
+			abort();					\
 		}							\
 	}								\
-	return (wrapper);						\
-}									\
-a_attr a_type *								\
-a_name##_tsd_get(void)							\
-{									\
-	a_name##_tsd_wrapper_t *wrapper;				\
-									\
-	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
-	return (&wrapper->val);						\
+	return (value);							\
 }									\
 a_attr void								\
 a_name##_tsd_set(a_type *val)						\
 {									\
-	a_name##_tsd_wrapper_t *wrapper;				\
+	a_type *value;							\
 									\
 	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
-	wrapper->val = *(val);						\
-	if (a_cleanup != malloc_tsd_no_cleanup)				\
-		wrapper->initialized = true;				\
+	value = a_name##_tsd_get();					\
+	*value = *(val);						\
 }
 #endif
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 17 10:46:25 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 19:46:25 +0200
Subject: [PATCH] Remove extra argument for malloc_tsd_cleanup_register
Message-ID: <1334684785-17957-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Bookkeeping an extra argument that actually only stores a function pointer
for a function we already have is not very useful.
---
 include/jemalloc/internal/tsd.h |   15 +++++----------
 src/tsd.c                       |    7 +++----
 2 files changed, 8 insertions(+), 14 deletions(-)

diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index c6ed683..4163dea 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -4,11 +4,7 @@
 /* Maximum number of malloc_tsd users with cleanup functions. */
 #define	MALLOC_TSD_CLEANUPS_MAX	8
 
-typedef struct malloc_tsd_cleanup_s malloc_tsd_cleanup_t;
-struct malloc_tsd_cleanup_s {
-	bool	(*f)(void *);
-	void	*arg;
-};
+typedef bool (*malloc_tsd_cleanup_t)(void);
 
 /*
  * TLS/TSD-agnostic macro-based implementation of thread-specific data.  There
@@ -110,13 +106,12 @@ a_attr bool		a_name##_booted = false;
     a_cleanup)								\
 /* Initialization/cleanup. */						\
 a_attr bool								\
-a_name##_tsd_cleanup_wrapper(void *arg)					\
+a_name##_tsd_cleanup_wrapper(void)					\
 {									\
-	bool (*cleanup)(void *) = arg;					\
 									\
 	if (a_name##_initialized) {					\
 		a_name##_initialized = false;				\
-		cleanup(&a_name##_tls);					\
+		a_cleanup(&a_name##_tls);					\
 	}								\
 	return (a_name##_initialized);					\
 }									\
@@ -126,7 +121,7 @@ a_name##_tsd_boot(void)							\
 									\
 	if (a_cleanup != malloc_tsd_no_cleanup) {			\
 		malloc_tsd_cleanup_register(				\
-		    &a_name##_tsd_cleanup_wrapper, a_cleanup);		\
+		    &a_name##_tsd_cleanup_wrapper);			\
 	}								\
 	a_name##_booted = true;						\
 	return (false);							\
@@ -257,7 +252,7 @@ a_name##_tsd_set(a_type *val)						\
 void	*malloc_tsd_malloc(size_t size);
 void	malloc_tsd_dalloc(void *wrapper);
 void	malloc_tsd_no_cleanup(void *);
-void	malloc_tsd_cleanup_register(bool (*f)(void *), void *arg);
+void	malloc_tsd_cleanup_register(bool (*f)(void));
 void	malloc_tsd_boot(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
diff --git a/src/tsd.c b/src/tsd.c
index 0838dc8..8e5e716 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -45,7 +45,7 @@ _malloc_thread_cleanup(void)
 		again = false;
 		for (i = 0; i < ncleanups; i++) {
 			if (pending[i]) {
-				pending[i] = cleanups[i].f(cleanups[i].arg);
+				pending[i] = cleanups[i]();
 				if (pending[i])
 					again = true;
 			}
@@ -55,12 +55,11 @@ _malloc_thread_cleanup(void)
 #endif
 
 void
-malloc_tsd_cleanup_register(bool (*f)(void *), void *arg)
+malloc_tsd_cleanup_register(bool (*f)(void))
 {
 
 	assert(ncleanups < MALLOC_TSD_CLEANUPS_MAX);
-	cleanups[ncleanups].f = f;
-	cleanups[ncleanups].arg = arg;
+	cleanups[ncleanups] = f;
 	ncleanups++;
 }
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 17 10:46:26 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 19:46:26 +0200
Subject: [PATCH] Fix malloc_vsnprintf handling of %o, %u and %x
Message-ID: <1334684786-17995-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

These flags take unsigned values, but they were fed with signed values
taken with va_arg, and that led to sign extension in cases where the
corresponding value has the most significant bit set.
---
 src/util.c |   20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/src/util.c b/src/util.c
index 2aab61f..99ae26d 100644
--- a/src/util.c
+++ b/src/util.c
@@ -320,12 +320,21 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	case '?':							\
 		val = va_arg(ap, int);					\
 		break;							\
+	case '?' | 0x80:						\
+		val = va_arg(ap, unsigned int);				\
+		break;							\
 	case 'l':							\
 		val = va_arg(ap, long);					\
 		break;							\
+	case 'l' | 0x80:						\
+		val = va_arg(ap, unsigned long);			\
+		break;							\
 	case 'q':							\
 		val = va_arg(ap, long long);				\
 		break;							\
+	case 'q' | 0x80:						\
+		val = va_arg(ap, unsigned long long);			\
+		break;							\
 	case 'j':							\
 		val = va_arg(ap, intmax_t);				\
 		break;							\
@@ -335,6 +344,9 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	case 'z':							\
 		val = va_arg(ap, ssize_t);				\
 		break;							\
+	case 'z' | 0x80:						\
+		val = va_arg(ap, size_t);				\
+		break;							\
 	case 'p': /* Synthetic; used for %p. */				\
 		val = va_arg(ap, uintptr_t);				\
 		break;							\
@@ -358,7 +370,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 			bool plus_plus = false;
 			int prec = -1;
 			int width = -1;
-			char len = '?';
+			unsigned char len = '?';
 
 			f++;
 			if (*f == '%') {
@@ -480,7 +492,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
 				char buf[O2S_BUFSIZE];
 
-				GET_ARG_NUMERIC(val, len);
+				GET_ARG_NUMERIC(val, len | 0x80);
 				s = o2s(val, alt_form, buf, &slen);
 				APPEND_PADDED_S(s, slen, width, left_justify);
 				f++;
@@ -489,7 +501,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
 				char buf[U2S_BUFSIZE];
 
-				GET_ARG_NUMERIC(val, len);
+				GET_ARG_NUMERIC(val, len | 0x80);
 				s = u2s(val, 10, false, buf, &slen);
 				APPEND_PADDED_S(s, slen, width, left_justify);
 				f++;
@@ -498,7 +510,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
 				char buf[X2S_BUFSIZE];
 
-				GET_ARG_NUMERIC(val, len);
+				GET_ARG_NUMERIC(val, len | 0x80);
 				s = x2s(val, alt_form, *f == 'X', buf, &slen);
 				APPEND_PADDED_S(s, slen, width, left_justify);
 				f++;
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 17 10:46:25 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 19:46:25 +0200
Subject: [PATCH] Add an abstraction layer for threading in tests
Message-ID: <1334684785-17921-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 test/allocated.c             |   29 +++++++++--------------------
 test/jemalloc_test.h.in      |   20 ++++++++++++++++++++
 test/thread_arena.c          |   18 +++++-------------
 test/thread_tcache_enabled.c |   29 +++++++++--------------------
 4 files changed, 43 insertions(+), 53 deletions(-)

diff --git a/test/allocated.c b/test/allocated.c
index 81cd4ca..3f889f4 100644
--- a/test/allocated.c
+++ b/test/allocated.c
@@ -2,7 +2,6 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <stdbool.h>
-#include <pthread.h>
 #include <assert.h>
 #include <errno.h>
 #include <string.h>
@@ -11,7 +10,7 @@
 #include "jemalloc_test.h"
 
 void *
-thread_start(void *arg)
+je_thread_start(void *arg)
 {
 	int err;
 	void *p;
@@ -106,31 +105,21 @@ int
 main(void)
 {
 	int ret = 0;
-	pthread_t thread;
+	je_thread_t thread;
 
 	malloc_printf("Test begin\n");
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
 label_return:
 	malloc_printf("Test end\n");
diff --git a/test/jemalloc_test.h.in b/test/jemalloc_test.h.in
index 58fa08e..cb1a89a 100644
--- a/test/jemalloc_test.h.in
+++ b/test/jemalloc_test.h.in
@@ -5,3 +5,23 @@
  */
 #include "jemalloc/jemalloc at install_suffix@.h"
 #include "jemalloc/internal/jemalloc_internal.h"
+
+/* Abstraction layer for threading in tests */
+#include <pthread.h>
+
+typedef pthread_t je_thread_t;
+
+void
+je_thread_create(je_thread_t *thread, void *(*proc)(void *), void *arg)
+{
+	if (pthread_create(thread, NULL, proc, arg) != 0) {
+		malloc_printf("Error in pthread_create()\n");
+		exit(1);
+	}
+}
+
+void
+je_thread_join(je_thread_t thread, void **ret)
+{
+	pthread_join(thread, ret);
+}
diff --git a/test/thread_arena.c b/test/thread_arena.c
index e443b71..9835428 100644
--- a/test/thread_arena.c
+++ b/test/thread_arena.c
@@ -1,6 +1,5 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <pthread.h>
 #include <string.h>
 #include <assert.h>
 
@@ -10,7 +9,7 @@
 #define NTHREADS 10
 
 void *
-thread_start(void *arg)
+je_thread_start(void *arg)
 {
 	unsigned main_arena_ind = *(unsigned *)arg;
 	void *p;
@@ -52,7 +51,7 @@ main(void)
 	unsigned arena_ind;
 	size_t size;
 	int err;
-	pthread_t threads[NTHREADS];
+	je_thread_t threads[NTHREADS];
 	unsigned i;
 
 	malloc_printf("Test begin\n");
@@ -72,18 +71,11 @@ main(void)
 		goto label_return;
 	}
 
-	for (i = 0; i < NTHREADS; i++) {
-		if (pthread_create(&threads[i], NULL, thread_start,
-		    (void *)&arena_ind) != 0) {
-			malloc_printf("%s(): Error in pthread_create()\n",
-			    __func__);
-			ret = 1;
-			goto label_return;
-		}
-	}
+	for (i = 0; i < NTHREADS; i++)
+		je_thread_create(&threads[i], je_thread_start, (void *)&arena_ind);
 
 	for (i = 0; i < NTHREADS; i++)
-		pthread_join(threads[i], (void *)&ret);
+		je_thread_join(threads[i], (void *)&ret);
 
 label_return:
 	malloc_printf("Test end\n");
diff --git a/test/thread_tcache_enabled.c b/test/thread_tcache_enabled.c
index 59b76a2..e1cba43 100644
--- a/test/thread_tcache_enabled.c
+++ b/test/thread_tcache_enabled.c
@@ -1,7 +1,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdbool.h>
-#include <pthread.h>
 #include <assert.h>
 #include <errno.h>
 
@@ -9,7 +8,7 @@
 #include "jemalloc_test.h"
 
 void *
-thread_start(void *arg)
+je_thread_start(void *arg)
 {
 	int err;
 	size_t sz;
@@ -77,31 +76,21 @@ int
 main(void)
 {
 	int ret = 0;
-	pthread_t thread;
+	je_thread_t thread;
 
 	malloc_printf("Test begin\n");
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
 label_return:
 	malloc_printf("Test end\n");
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 17 10:46:26 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 19:46:26 +0200
Subject: [PATCH] Add a test for the TSD system
Message-ID: <1334684786-18033-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---

Note that this test doesn't compile without --enable-debug, because of
arena_malloc. Any ideas how to best fix this?

 Makefile.in  |    3 ++-
 test/tsd.c   |   76 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 test/tsd.exp |    9 +++++++
 3 files changed, 87 insertions(+), 1 deletion(-)
 create mode 100644 test/tsd.c
 create mode 100644 test/tsd.exp

diff --git a/Makefile.in b/Makefile.in
index 8a34928..24f07ab 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,7 +89,7 @@ DOCS := $(DOCS_HTML) $(DOCS_MAN3)
 CTESTS := $(srcroot)test/aligned_alloc.c $(srcroot)test/allocated.c \
 	$(srcroot)test/bitmap.c $(srcroot)test/mremap.c \
 	$(srcroot)test/posix_memalign.c $(srcroot)test/thread_arena.c \
-	$(srcroot)test/thread_tcache_enabled.c
+	$(srcroot)test/thread_tcache_enabled.c $(srcroot)test/tsd.c
 ifeq ($(enable_experimental), 1)
 CTESTS += $(srcroot)test/allocm.c $(srcroot)test/rallocm.c
 endif
@@ -156,6 +156,7 @@ $(STATIC_LIBS):
 	ar crus $@ $+
 
 $(objroot)test/bitmap$(EXE): $(objroot)src/bitmap.$(O)
+$(objroot)test/tsd$(EXE): $(objroot)src/tsd.$(O)
 
 $(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) $(DSOS)
 	@mkdir -p $(@D)
diff --git a/test/tsd.c b/test/tsd.c
new file mode 100644
index 0000000..c812f5c
--- /dev/null
+++ b/test/tsd.c
@@ -0,0 +1,76 @@
+#define	JEMALLOC_MANGLE
+#include "jemalloc_test.h"
+
+/* Stubs to avoid pulling the entire jemalloc internals */
+arena_t *_arenas[1] = { NULL };
+arena_t **arenas = _arenas;
+bool    opt_abort = true;
+
+void *
+arena_malloc(arena_t *arena, size_t size, bool zero, bool try_tcache)
+{
+	static unsigned char buf[4096];
+	static unsigned char *next_ptr = buf;
+	unsigned char *ret = next_ptr;
+
+	next_ptr += size;
+	return next_ptr;
+}
+
+void
+idalloc(void *ptr)
+{
+}
+
+#define THREAD_DATA 0x72b65c10
+
+typedef unsigned int data_t;
+
+void
+data_cleanup(void *arg)
+{
+	data_t *data = (data_t *)arg;
+
+	malloc_printf("Cleanup for data %x.\n", *data);
+}
+
+malloc_tsd_protos(, data, data_t)
+malloc_tsd_externs(data, data_t)
+#define DATA_INIT 0x12345678
+malloc_tsd_data(, data, data_t, DATA_INIT)
+malloc_tsd_funcs(, data, data_t, DATA_INIT, data_cleanup)
+
+void *
+je_thread_start(void *arg)
+{
+	data_t d = (data_t)(uintptr_t) arg;
+	malloc_printf("Initial tsd_get returns %x. Expected %x.\n",
+		*data_tsd_get(), DATA_INIT);
+
+	data_tsd_set(&d);
+	malloc_printf("After tsd_set: %x. Expected %x.\n",
+		*data_tsd_get(), d);
+
+	d = 0;
+	malloc_printf("After resetting local data: %x. Expected %x.\n",
+		*data_tsd_get(), (data_t)(uintptr_t) arg);
+
+	return NULL;
+}
+
+int
+main(void)
+{
+	je_thread_t thread;
+
+	malloc_printf("Test begin\n");
+
+	data_tsd_boot();
+	je_thread_start((void *) 0xa5f3e329);
+
+	je_thread_create(&thread, je_thread_start, (void *) THREAD_DATA);
+	je_thread_join(thread, NULL);
+
+	malloc_printf("Test end\n");
+	return (0);
+}
diff --git a/test/tsd.exp b/test/tsd.exp
new file mode 100644
index 0000000..b4abedc
--- /dev/null
+++ b/test/tsd.exp
@@ -0,0 +1,9 @@
+Test begin
+Initial tsd_get returns 12345678. Expected 12345678.
+After tsd_set: a5f3e329. Expected a5f3e329.
+After resetting local data: a5f3e329. Expected a5f3e329.
+Initial tsd_get returns 12345678. Expected 12345678.
+After tsd_set: 72b65c10. Expected 72b65c10.
+After resetting local data: 72b65c10. Expected 72b65c10.
+Cleanup for data 72b65c10.
+Test end
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 17 10:46:25 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 17 Apr 2012 19:46:25 +0200
Subject: [PATCH] Refactor object and library build,
	and only build PIC libraries when PIC_CFLAGS is defined
Message-ID: <1334684785-17885-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in  |   73 ++++++++++++++++++++++++++++++----------------------------
 configure.ac |    2 ++
 2 files changed, 40 insertions(+), 35 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index d426cbd..8a34928 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -48,6 +48,7 @@ enable_autogen := @enable_autogen@
 enable_experimental := @enable_experimental@
 DSO_LDFLAGS = @DSO_LDFLAGS@
 SOREV = @SOREV@
+PIC_CFLAGS = @PIC_CFLAGS@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
@@ -73,8 +74,10 @@ ifeq (macho, $(ABI))
 CSRCS += $(srcroot)src/zone.c
 endif
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
-DSOS := $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) \
-	$(objroot)lib/$(LIBJEMALLOC).$(SOREV)
+ifdef PIC_CFLAGS
+STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_pic.$(A)
+endif
+DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SOREV)
 ifneq ($(SOREV),$(SO))
 DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
 endif
@@ -91,12 +94,16 @@ ifeq ($(enable_experimental), 1)
 CTESTS += $(srcroot)test/allocm.c $(srcroot)test/rallocm.c
 endif
 
+COBJS := $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
+CPICOBJS := $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
+CTESTOBJS := $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
+
 .PHONY: all dist doc_html doc_man doc
 .PHONY: install_bin install_include install_lib
 .PHONY: install_html install_man install_doc install
 .PHONY: tests check clean distclean relclean
 
-.SECONDARY : $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
+.SECONDARY : $(CTESTOBJS)
 
 # Default target.
 all: build
@@ -116,18 +123,19 @@ build_doc: $(DOCS)
 #
 # Include generated dependency files.
 #
--include $(CSRCS:$(srcroot)%.c=$(objroot)%.d)
--include $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
--include $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
+-include $(COBJS:%.$(O)=%.d)
+-include $(CPICOBJS:%.$(O)=%.d)
+-include $(CTESTOBJS:%.$(O)=%.d)
 
-$(objroot)src/%.$(O): $(srcroot)src/%.c
-	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
+$(COBJS): $(objroot)src/%.$(O): $(srcroot)src/%.c
+$(CPICOBJS): $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
+$(CPICOBJS): CFLAGS += $(PIC_CFLAGS)
+$(CTESTOBJS): $(objroot)test/%.$(O): $(srcroot)test/%.c
+$(CTESTOBJS): CPPFLAGS += -I$(objroot)test
 
-$(objroot)src/%.pic.$(O): $(srcroot)src/%.c
+$(COBJS) $(CPICOBJS) $(CTESTOBJS): %.$(O):
 	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
+	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
 ifneq ($(SOREV),$(SO))
@@ -136,27 +144,20 @@ ifneq ($(SOREV),$(SO))
 	ln -sf $(<F) $@
 endif
 
-$(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
+$(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(if $(PIC_CFLAGS),$(CPICOBJS),$(COBJS))
 	@mkdir -p $(@D)
 	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) -o $@ $+ $(LDFLAGS) $(LIBS)
 
-$(objroot)lib/$(LIBJEMALLOC)_pic.$(A) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
-	@mkdir -p $(@D)
-	ar crus $@ $+
+$(objroot)lib/$(LIBJEMALLOC)_pic.$(A) : $(CPICOBJS)
+$(objroot)lib/$(LIBJEMALLOC).$(A) : $(COBJS)
 
-$(objroot)lib/$(LIBJEMALLOC).$(A) : $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
+$(STATIC_LIBS):
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-$(objroot)test/%.$(O): $(srcroot)test/%.c
-	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -c $(CPPFLAGS) -I$(objroot)test -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -I$(objroot)test -MT $@ -o $(@:%.$(O)=%.d) $<
-
 $(objroot)test/bitmap$(EXE): $(objroot)src/bitmap.$(O)
 
-$(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) \
-		 $(objroot)lib/$(LIBJEMALLOC).$(SO)
+$(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) $(DSOS)
 	@mkdir -p $(@D)
 	$(CC) -o $@ $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
 
@@ -185,10 +186,12 @@ ifneq ($(SOREV),$(SO))
 	ln -sf $(LIBJEMALLOC).$(SOREV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
 endif
 
-install_lib_static: $(DSOS) $(STATIC_LIBS)
+install_lib_static: $(STATIC_LIBS)
 	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(A) $(LIBDIR)
+	@for l in $(STATIC_LIBS); do \
+	echo "install -m 755 $$l $(LIBDIR)"; \
+	install -m 755 $$l $(LIBDIR); \
+done
 
 install_lib: install_lib_shared install_lib_static
 
@@ -241,14 +244,14 @@ check: tests
 		echo "Failures: $${failures}/$${total}"'
 
 clean:
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.d)
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%$(EXE))
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.out)
+	rm -f $(COBJS)
+	rm -f $(CPICOBJS)
+	rm -f $(COBJS:%.$(O)=%.d)
+	rm -f $(CPICOBJS:%.$(O)=%.d)
+	rm -f $(CTESTOBJS:%.$(O)=%$(EXE))
+	rm -f $(CTESTOBJS)
+	rm -f $(CTESTOBJS:%.$(O)=%.d)
+	rm -f $(CTESTOBJS:%.$(O)=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 
 distclean: clean
diff --git a/configure.ac b/configure.ac
index 0f78c61..2d7a1f3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -202,6 +202,7 @@ lib="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
 SOREV='$(SO).$(REV)'
+PIC_CFLAGS='-fPIC -DPIC'
 
 dnl Heap profiling uses the log(3) function.
 LIBS="$LIBS -lm"
@@ -287,6 +288,7 @@ AC_SUBST([exe])
 AC_SUBST([lib])
 AC_SUBST([DSO_LDFLAGS])
 AC_SUBST([SOREV])
+AC_SUBST([PIC_CFLAGS])
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:25:29 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:25:29 +0200
Subject: [PATCH] Simplify TSD without TLS
In-Reply-To: <20120417100715.GA24797@glandium.org>
References: <1334656864-24573-1-git-send-email-mh+jemalloc@glandium.org>
	<20120417100715.GA24797@glandium.org>
Message-ID: <20120418162529.GA18610@glandium.org>

On Tue, Apr 17, 2012 at 12:07:15PM +0200, Mike Hommey wrote:
> On Tue, Apr 17, 2012 at 12:01:04PM +0200, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > ---
> >  include/jemalloc/internal/tsd.h |   85 +++++++++------------------------------
> >  1 file changed, 20 insertions(+), 65 deletions(-)
> 
> Just a few notes: this implementation is 95% the same as the one I have
> for mingw. I'm even tempted to make them actually share the code,
> because it would make changes/fixes to one be used in the other.
> 
> It doesn't use a static variable when malloc_tsd_malloc
> fails, but unconditionally aborts instead. Using a static variable is
> due to fail with multithreading anyways. The 'initialized' variable is
> not necessary either, as pthread_key's cleanup function won't be called
> unless a non-NULL value has been set with pthread_setspecific.

With a more complete tsd testcase than the one I sent yesterday, I can
see how the initialized variable is necessary. However, there's a bug,
because it's not set to false when creating the wrapper, and this makes
the cleanup function called even when tsd_set was never called.

There's also a corner case, with *something_tsd_get() = value. It
doesn't trigger a cleanup at thread shutdown, and I'm not sure if that's
a desired effect. Arguably, maybe this should be forbidden. Adding
const to tsd_get() ensures that, but as a matter of fact,
thread_allocated tsd does this kind of assignment. But it also doesn't
have a cleanup function, so it's not really a problem. We may want to
avoid such things from happening in the future, though.

I'm going to attach my patch queue modifying different TSD
implementation details, and for good measure (and because the ordering
of my last patch was not obvious), I'm also going to push the whole
queue again, with proper ordering.

Please note that patch 6/11 (Add a test for the TSD system) does *not*
build without --enable-debug because it's such impossible build
independent parts of jemalloc with optimized builds. You may however
want to run the test on the freebsd implementation of the TSD system,
because that's the only one I couldn't test. With patches 8 and 9, the
--disable-tls implementation passes the test.

This patch queue closes on Mingw support. Next will be MSVC.

Mike


From mh+jemalloc at glandium.org  Wed Apr 18 09:29:40 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:40 +0200
Subject: [PATCH 01/11] Make versioned shared library suffix configurable
In-Reply-To: <20120418162529.GA18610@glandium.org>
References: <20120418162529.GA18610@glandium.org>
Message-ID: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

This allows for different patterns for file names:
- lib.so.version for e.g. Linux
- lib.version.dylib for OSX (which is much more common than
lib.dylib.version)
- lib.dll for Windows (no version at all).
---
 Makefile.in        |   21 ++++++++++++++-------
 bin/jemalloc.sh.in |    2 +-
 configure.ac       |    3 +++
 3 files changed, 18 insertions(+), 8 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 0dfddea..d426cbd 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -47,6 +47,7 @@ cfgoutputs_out := @cfgoutputs_out@
 enable_autogen := @enable_autogen@
 enable_experimental := @enable_experimental@
 DSO_LDFLAGS = @DSO_LDFLAGS@
+SOREV = @SOREV@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
@@ -72,9 +73,11 @@ ifeq (macho, $(ABI))
 CSRCS += $(srcroot)src/zone.c
 endif
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
-DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) \
-	$(objroot)lib/$(LIBJEMALLOC).$(SO) \
-	$(objroot)lib/$(LIBJEMALLOC)_pic.$(A)
+DSOS := $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) \
+	$(objroot)lib/$(LIBJEMALLOC).$(SOREV)
+ifneq ($(SOREV),$(SO))
+DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
+endif
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
 DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.html)
@@ -127,11 +130,13 @@ $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
 	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
-%.$(SO) : %.$(SO).$(REV)
+ifneq ($(SOREV),$(SO))
+%.$(SO) : %.$(SOREV)
 	@mkdir -p $(@D)
 	ln -sf $(<F) $@
+endif
 
-$(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
+$(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 	@mkdir -p $(@D)
 	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) -o $@ $+ $(LDFLAGS) $(LIBS)
 
@@ -175,8 +180,10 @@ done
 
 install_lib_shared: $(DSOS)
 	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)
-	ln -sf $(LIBJEMALLOC).$(SO).$(REV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
+	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) $(LIBDIR)
+ifneq ($(SOREV),$(SO))
+	ln -sf $(LIBJEMALLOC).$(SOREV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
+endif
 
 install_lib_static: $(DSOS) $(STATIC_LIBS)
 	install -d $(LIBDIR)
diff --git a/bin/jemalloc.sh.in b/bin/jemalloc.sh.in
index 56cdfaf..cdf3673 100644
--- a/bin/jemalloc.sh.in
+++ b/bin/jemalloc.sh.in
@@ -4,6 +4,6 @@ prefix=@prefix@
 exec_prefix=@exec_prefix@
 libdir=@libdir@
 
- at LD_PRELOAD_VAR@=${libdir}/libjemalloc. at so@. at rev@
+ at LD_PRELOAD_VAR@=${libdir}/libjemalloc. at SOREV@
 export @LD_PRELOAD_VAR@
 exec "$@"
diff --git a/configure.ac b/configure.ac
index f4c2506..0f0de90 100644
--- a/configure.ac
+++ b/configure.ac
@@ -201,6 +201,7 @@ exe=
 lib="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
+SOREV='$(SO).$(REV)'
 
 dnl Heap profiling uses the log(3) function.
 LIBS="$LIBS -lm"
@@ -223,6 +224,7 @@ case "${host}" in
 	so="dylib"
 	force_tls="0"
 	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
+	SOREV='$(REV).$(SO)'
 	;;
   *-*-freebsd*)
 	CFLAGS="$CFLAGS"
@@ -284,6 +286,7 @@ AC_SUBST([a])
 AC_SUBST([exe])
 AC_SUBST([lib])
 AC_SUBST([DSO_LDFLAGS])
+AC_SUBST([SOREV])
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:43 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:43 +0200
Subject: [PATCH 04/11] Add a pages_purge function to wrap
	madvise(JEMALLOC_MADV_PURGE) calls
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-4-git-send-email-mh+jemalloc@glandium.org>

From: unknown <mh at jigen.(none)>

This will be used to implement the feature on mingw, which doesn't have
madvise.
---
 include/jemalloc/internal/chunk_mmap.h |    2 ++
 include/jemalloc/jemalloc_defs.h.in    |    7 -------
 src/arena.c                            |    4 ++--
 src/chunk.c                            |    2 +-
 src/chunk_mmap.c                       |   13 +++++++++++++
 5 files changed, 18 insertions(+), 10 deletions(-)

diff --git a/include/jemalloc/internal/chunk_mmap.h b/include/jemalloc/internal/chunk_mmap.h
index 04e86af..2d01ac2 100644
--- a/include/jemalloc/internal/chunk_mmap.h
+++ b/include/jemalloc/internal/chunk_mmap.h
@@ -9,6 +9,8 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
+void	pages_purge(void *addr, size_t length);
+
 void	*chunk_alloc_mmap(size_t size, size_t alignment);
 bool	chunk_dealloc_mmap(void *chunk, size_t size);
 
diff --git a/include/jemalloc/jemalloc_defs.h.in b/include/jemalloc/jemalloc_defs.h.in
index 90baa35..6e81655 100644
--- a/include/jemalloc/jemalloc_defs.h.in
+++ b/include/jemalloc/jemalloc_defs.h.in
@@ -220,13 +220,6 @@
  */
 #undef JEMALLOC_PURGE_MADVISE_DONTNEED
 #undef JEMALLOC_PURGE_MADVISE_FREE
-#ifdef JEMALLOC_PURGE_MADVISE_DONTNEED
-#  define JEMALLOC_MADV_PURGE MADV_DONTNEED
-#elif defined(JEMALLOC_PURGE_MADVISE_FREE)
-#  define JEMALLOC_MADV_PURGE MADV_FREE
-#else
-#  error "No method defined for purging unused dirty pages."
-#endif
 
 /* sizeof(void *) == 2^LG_SIZEOF_PTR. */
 #undef LG_SIZEOF_PTR
diff --git a/src/arena.c b/src/arena.c
index 989034d..cbd92e2 100644
--- a/src/arena.c
+++ b/src/arena.c
@@ -676,8 +676,8 @@ arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk)
 		if (config_debug)
 			ndirty -= npages;
 
-		madvise((void *)((uintptr_t)chunk + (pageind << LG_PAGE)),
-		    (npages << LG_PAGE), JEMALLOC_MADV_PURGE);
+		pages_purge((void *)((uintptr_t)chunk + (pageind << LG_PAGE)),
+		    (npages << LG_PAGE));
 		if (config_stats)
 			nmadvise++;
 	}
diff --git a/src/chunk.c b/src/chunk.c
index 67e0d50..bcaedea 100644
--- a/src/chunk.c
+++ b/src/chunk.c
@@ -171,7 +171,7 @@ chunk_record(void *chunk, size_t size)
 {
 	extent_node_t *xnode, *node, *prev, key;
 
-	madvise(chunk, size, JEMALLOC_MADV_PURGE);
+	pages_purge(chunk, size);
 
 	xnode = NULL;
 	malloc_mutex_lock(&chunks_mtx);
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index e11cc0e..3ab9095 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -72,6 +72,19 @@ pages_unmap(void *addr, size_t size)
 	}
 }
 
+void
+pages_purge(void *addr, size_t length)
+{
+#ifdef JEMALLOC_PURGE_MADVISE_DONTNEED
+#  define JEMALLOC_MADV_PURGE MADV_DONTNEED
+#elif defined(JEMALLOC_PURGE_MADVISE_FREE)
+#  define JEMALLOC_MADV_PURGE MADV_FREE
+#else
+#  error "No method defined for purging unused dirty pages."
+#endif
+	madvise(addr, length, JEMALLOC_MADV_PURGE);
+}
+
 static void *
 chunk_alloc_mmap_slow(size_t size, size_t alignment, bool unaligned)
 {
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:44 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:44 +0200
Subject: [PATCH 05/11] Fix malloc_vsnprintf handling of %o, %u and %x
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-5-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

These flags take unsigned values, but they were fed with signed values
taken with va_arg, and that led to sign extension in cases where the
corresponding value has the most significant bit set.
---
 src/util.c |   20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/src/util.c b/src/util.c
index 2aab61f..99ae26d 100644
--- a/src/util.c
+++ b/src/util.c
@@ -320,12 +320,21 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	case '?':							\
 		val = va_arg(ap, int);					\
 		break;							\
+	case '?' | 0x80:						\
+		val = va_arg(ap, unsigned int);				\
+		break;							\
 	case 'l':							\
 		val = va_arg(ap, long);					\
 		break;							\
+	case 'l' | 0x80:						\
+		val = va_arg(ap, unsigned long);			\
+		break;							\
 	case 'q':							\
 		val = va_arg(ap, long long);				\
 		break;							\
+	case 'q' | 0x80:						\
+		val = va_arg(ap, unsigned long long);			\
+		break;							\
 	case 'j':							\
 		val = va_arg(ap, intmax_t);				\
 		break;							\
@@ -335,6 +344,9 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	case 'z':							\
 		val = va_arg(ap, ssize_t);				\
 		break;							\
+	case 'z' | 0x80:						\
+		val = va_arg(ap, size_t);				\
+		break;							\
 	case 'p': /* Synthetic; used for %p. */				\
 		val = va_arg(ap, uintptr_t);				\
 		break;							\
@@ -358,7 +370,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 			bool plus_plus = false;
 			int prec = -1;
 			int width = -1;
-			char len = '?';
+			unsigned char len = '?';
 
 			f++;
 			if (*f == '%') {
@@ -480,7 +492,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
 				char buf[O2S_BUFSIZE];
 
-				GET_ARG_NUMERIC(val, len);
+				GET_ARG_NUMERIC(val, len | 0x80);
 				s = o2s(val, alt_form, buf, &slen);
 				APPEND_PADDED_S(s, slen, width, left_justify);
 				f++;
@@ -489,7 +501,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
 				char buf[U2S_BUFSIZE];
 
-				GET_ARG_NUMERIC(val, len);
+				GET_ARG_NUMERIC(val, len | 0x80);
 				s = u2s(val, 10, false, buf, &slen);
 				APPEND_PADDED_S(s, slen, width, left_justify);
 				f++;
@@ -498,7 +510,7 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 				uintmax_t val JEMALLOC_CC_SILENCE_INIT(0);
 				char buf[X2S_BUFSIZE];
 
-				GET_ARG_NUMERIC(val, len);
+				GET_ARG_NUMERIC(val, len | 0x80);
 				s = x2s(val, alt_form, *f == 'X', buf, &slen);
 				APPEND_PADDED_S(s, slen, width, left_justify);
 				f++;
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:45 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:45 +0200
Subject: [PATCH 06/11] Add a test for the TSD system
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-6-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in  |    3 +-
 test/tsd.c   |  139 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 test/tsd.exp |    2 +
 3 files changed, 143 insertions(+), 1 deletion(-)
 create mode 100644 test/tsd.c
 create mode 100644 test/tsd.exp

diff --git a/Makefile.in b/Makefile.in
index 8a34928..7f5dcf9 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -89,7 +89,7 @@ DOCS := $(DOCS_HTML) $(DOCS_MAN3)
 CTESTS := $(srcroot)test/aligned_alloc.c $(srcroot)test/allocated.c \
 	$(srcroot)test/bitmap.c $(srcroot)test/mremap.c \
 	$(srcroot)test/posix_memalign.c $(srcroot)test/thread_arena.c \
-	$(srcroot)test/thread_tcache_enabled.c
+	$(srcroot)test/thread_tcache_enabled.c $(srcroot)test/tsd.c
 ifeq ($(enable_experimental), 1)
 CTESTS += $(srcroot)test/allocm.c $(srcroot)test/rallocm.c
 endif
@@ -156,6 +156,7 @@ $(STATIC_LIBS):
 	ar crus $@ $+
 
 $(objroot)test/bitmap$(EXE): $(objroot)src/bitmap.$(O)
+#$(objroot)test/tsd$(EXE): $(objroot)src/tsd.$(O)
 
 $(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) $(DSOS)
 	@mkdir -p $(@D)
diff --git a/test/tsd.c b/test/tsd.c
new file mode 100644
index 0000000..a3fc913
--- /dev/null
+++ b/test/tsd.c
@@ -0,0 +1,139 @@
+#define	JEMALLOC_MANGLE
+#include "jemalloc_test.h"
+
+typedef unsigned int data_t;
+
+void data_cleanup(void *arg);
+malloc_tsd_protos(, data, data_t)
+malloc_tsd_externs(data, data_t)
+#define DATA_INIT 0
+malloc_tsd_data(, data, data_t, DATA_INIT)
+malloc_tsd_funcs(, data, data_t, DATA_INIT, data_cleanup)
+
+static data_t next_cleanup = 0;
+static int ran_cleanups = 0;
+
+static void
+_check_equal(data_t a, data_t b, const char *file, int line)
+{
+	if (a != b)
+		malloc_printf("Got %x. Expected %x. %s:%d\n",
+			a, b, file, line);
+}
+#define check_equal(a, b) \
+	_check_equal(a, b, __FILE__, __LINE__)
+
+void
+data_cleanup(void *arg)
+{
+	data_t *data = (data_t *)arg;
+
+	check_equal(*data, next_cleanup);
+
+	if (ran_cleanups++)
+		return;
+
+	check_equal(*data_tsd_get(), DATA_INIT);
+	*data = 0x3b384d0f;
+	check_equal(*data_tsd_get(), DATA_INIT);
+
+	data_tsd_set(data);
+	next_cleanup = *data;
+	check_equal(*data_tsd_get(), *data);
+}
+
+void *
+thread_start(void *arg)
+{
+	data_t d = (data_t)(uintptr_t) arg;
+
+	if (d == 0)
+		return NULL;
+
+	check_equal(*data_tsd_get(), DATA_INIT);
+
+	if (d == 1)
+		return NULL;
+
+	data_tsd_set(&d);
+	next_cleanup = d;
+	check_equal(*data_tsd_get(), d);
+
+	d = 0;
+	check_equal(*data_tsd_get(), (data_t)(uintptr_t) arg);
+
+	return NULL;
+}
+
+int
+main(void)
+{
+	je_thread_t thread;
+	data_t d = 0xa5f3e329;
+
+	malloc_printf("Test begin\n");
+
+	data_tsd_boot();
+	thread_start((void *)(uintptr_t) d);
+
+	je_thread_create(&thread, thread_start, (void *) 0x72b65c10);
+	je_thread_join(thread, NULL);
+
+	check_equal(*data_tsd_get(), d);
+
+	je_thread_create(&thread, thread_start, NULL);
+	je_thread_join(thread, NULL);
+
+	je_thread_create(&thread, thread_start, (void *) 1);
+	je_thread_join(thread, NULL);
+
+	check_equal(ran_cleanups, 2);
+	malloc_printf("Test end\n");
+	return (0);
+}
+
+/* Stubs to avoid pulling the entire jemalloc internals */
+bool    opt_abort = false;
+
+arena_t *_arenas[1] = { NULL };
+arena_t **arenas = _arenas;
+
+#ifndef JEMALLOC_ENABLE_INLINE
+void *
+arena_malloc(arena_t *arena, size_t size, bool zero, bool try_tcache)
+{
+	return NULL;
+}
+
+void
+idalloc(void *ptr)
+{
+}
+#endif
+
+void *
+malloc_tsd_malloc(size_t size)
+{
+#if 0
+	return NULL;
+#else
+	static unsigned char buf[4096];
+	static unsigned char *next_ptr = buf;
+	unsigned char *ret = next_ptr;
+
+	next_ptr += size;
+	memset(ret, 42, size);
+	return ret;
+#endif
+}
+
+void
+malloc_tsd_dalloc(void *ptr)
+{
+}
+
+#undef malloc_tsd_dalloc
+#define malloc_tsd_dalloc malloc_tsd_dalloc_
+#undef malloc_tsd_malloc
+#define malloc_tsd_malloc malloc_tsd_malloc_
+#include "../src/tsd.c"
diff --git a/test/tsd.exp b/test/tsd.exp
new file mode 100644
index 0000000..369a88d
--- /dev/null
+++ b/test/tsd.exp
@@ -0,0 +1,2 @@
+Test begin
+Test end
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:48 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:48 +0200
Subject: [PATCH 09/11] Remove initialization of the non-TLS tsd wrapper from
	static memory
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-9-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Using static memory when malloc_tsd_malloc fails means all threads share
the same wrapper and thus the same wrapped value. This defeats the purpose
of TSD.
---
 include/jemalloc/internal/tsd.h |   15 +++------------
 1 file changed, 3 insertions(+), 12 deletions(-)

diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index d1dd3d0..db6b1a6 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -192,7 +192,6 @@ a_name##_tsd_set(a_type *val)						\
     a_cleanup)								\
 /* Data structure. */							\
 typedef struct {							\
-	bool	isstatic;						\
 	bool	initialized;						\
 	a_type	val;							\
 } a_name##_tsd_wrapper_t;						\
@@ -218,8 +217,7 @@ a_name##_tsd_cleanup_wrapper(void *arg)					\
 			return;						\
 		}							\
 	}								\
-	if (wrapper->isstatic == false)					\
-		malloc_tsd_dalloc(wrapper);				\
+	malloc_tsd_dalloc(wrapper);					\
 }									\
 a_attr bool								\
 a_name##_tsd_boot(void)							\
@@ -242,17 +240,11 @@ a_name##_tsd_get_wrapper(void)						\
 		wrapper = (a_name##_tsd_wrapper_t *)			\
 		    malloc_tsd_malloc(sizeof(a_name##_tsd_wrapper_t));	\
 		if (wrapper == NULL) {					\
-			static a_name##_tsd_wrapper_t			\
-			    a_name##_tsd_static_data =			\
-			    {true, false, a_initializer};		\
 			malloc_write("<jemalloc>: Error allocating"	\
 			    " TSD for "#a_name"\n");			\
-			if (opt_abort)					\
-				abort();				\
-			wrapper = &a_name##_tsd_static_data;		\
+			abort();					\
 		} else {						\
 			static a_type tsd_static_data = a_initializer;	\
-			wrapper->isstatic = false;			\
 			wrapper->initialized = false;			\
 			wrapper->val = tsd_static_data;			\
 		}							\
@@ -260,8 +252,7 @@ a_name##_tsd_get_wrapper(void)						\
 		    (void *)wrapper)) {					\
 			malloc_write("<jemalloc>: Error setting"	\
 			    " TSD for "#a_name"\n");			\
-			if (opt_abort)					\
-				abort();				\
+			abort();					\
 		}							\
 	}								\
 	return (wrapper);						\
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:41 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:41 +0200
Subject: [PATCH 02/11] Refactor object and library build,
	and only build PIC libraries when PIC_CFLAGS is defined
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-2-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in  |   73 ++++++++++++++++++++++++++++++----------------------------
 configure.ac |    2 ++
 2 files changed, 40 insertions(+), 35 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index d426cbd..8a34928 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -48,6 +48,7 @@ enable_autogen := @enable_autogen@
 enable_experimental := @enable_experimental@
 DSO_LDFLAGS = @DSO_LDFLAGS@
 SOREV = @SOREV@
+PIC_CFLAGS = @PIC_CFLAGS@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
@@ -73,8 +74,10 @@ ifeq (macho, $(ABI))
 CSRCS += $(srcroot)src/zone.c
 endif
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
-DSOS := $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) \
-	$(objroot)lib/$(LIBJEMALLOC).$(SOREV)
+ifdef PIC_CFLAGS
+STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_pic.$(A)
+endif
+DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SOREV)
 ifneq ($(SOREV),$(SO))
 DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
 endif
@@ -91,12 +94,16 @@ ifeq ($(enable_experimental), 1)
 CTESTS += $(srcroot)test/allocm.c $(srcroot)test/rallocm.c
 endif
 
+COBJS := $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
+CPICOBJS := $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
+CTESTOBJS := $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
+
 .PHONY: all dist doc_html doc_man doc
 .PHONY: install_bin install_include install_lib
 .PHONY: install_html install_man install_doc install
 .PHONY: tests check clean distclean relclean
 
-.SECONDARY : $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
+.SECONDARY : $(CTESTOBJS)
 
 # Default target.
 all: build
@@ -116,18 +123,19 @@ build_doc: $(DOCS)
 #
 # Include generated dependency files.
 #
--include $(CSRCS:$(srcroot)%.c=$(objroot)%.d)
--include $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
--include $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
+-include $(COBJS:%.$(O)=%.d)
+-include $(CPICOBJS:%.$(O)=%.d)
+-include $(CTESTOBJS:%.$(O)=%.d)
 
-$(objroot)src/%.$(O): $(srcroot)src/%.c
-	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
+$(COBJS): $(objroot)src/%.$(O): $(srcroot)src/%.c
+$(CPICOBJS): $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
+$(CPICOBJS): CFLAGS += $(PIC_CFLAGS)
+$(CTESTOBJS): $(objroot)test/%.$(O): $(srcroot)test/%.c
+$(CTESTOBJS): CPPFLAGS += -I$(objroot)test
 
-$(objroot)src/%.pic.$(O): $(srcroot)src/%.c
+$(COBJS) $(CPICOBJS) $(CTESTOBJS): %.$(O):
 	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -fPIC -DPIC -c $(CPPFLAGS) -o $@ $<
+	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
 	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
 ifneq ($(SOREV),$(SO))
@@ -136,27 +144,20 @@ ifneq ($(SOREV),$(SO))
 	ln -sf $(<F) $@
 endif
 
-$(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
+$(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(if $(PIC_CFLAGS),$(CPICOBJS),$(COBJS))
 	@mkdir -p $(@D)
 	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) -o $@ $+ $(LDFLAGS) $(LIBS)
 
-$(objroot)lib/$(LIBJEMALLOC)_pic.$(A) : $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
-	@mkdir -p $(@D)
-	ar crus $@ $+
+$(objroot)lib/$(LIBJEMALLOC)_pic.$(A) : $(CPICOBJS)
+$(objroot)lib/$(LIBJEMALLOC).$(A) : $(COBJS)
 
-$(objroot)lib/$(LIBJEMALLOC).$(A) : $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
+$(STATIC_LIBS):
 	@mkdir -p $(@D)
 	ar crus $@ $+
 
-$(objroot)test/%.$(O): $(srcroot)test/%.c
-	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -c $(CPPFLAGS) -I$(objroot)test -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -I$(objroot)test -MT $@ -o $(@:%.$(O)=%.d) $<
-
 $(objroot)test/bitmap$(EXE): $(objroot)src/bitmap.$(O)
 
-$(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) \
-		 $(objroot)lib/$(LIBJEMALLOC).$(SO)
+$(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) $(DSOS)
 	@mkdir -p $(@D)
 	$(CC) -o $@ $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) -L$(objroot)lib -ljemalloc$(install_suffix) $(LIBS)
 
@@ -185,10 +186,12 @@ ifneq ($(SOREV),$(SO))
 	ln -sf $(LIBJEMALLOC).$(SOREV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
 endif
 
-install_lib_static: $(DSOS) $(STATIC_LIBS)
+install_lib_static: $(STATIC_LIBS)
 	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(A) $(LIBDIR)
+	@for l in $(STATIC_LIBS); do \
+	echo "install -m 755 $$l $(LIBDIR)"; \
+	install -m 755 $$l $(LIBDIR); \
+done
 
 install_lib: install_lib_shared install_lib_static
 
@@ -241,14 +244,14 @@ check: tests
 		echo "Failures: $${failures}/$${total}"'
 
 clean:
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.$(O))
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.d)
-	rm -f $(CSRCS:$(srcroot)%.c=$(objroot)%.pic.d)
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%$(EXE))
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.$(O))
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.d)
-	rm -f $(CTESTS:$(srcroot)%.c=$(objroot)%.out)
+	rm -f $(COBJS)
+	rm -f $(CPICOBJS)
+	rm -f $(COBJS:%.$(O)=%.d)
+	rm -f $(CPICOBJS:%.$(O)=%.d)
+	rm -f $(CTESTOBJS:%.$(O)=%$(EXE))
+	rm -f $(CTESTOBJS)
+	rm -f $(CTESTOBJS:%.$(O)=%.d)
+	rm -f $(CTESTOBJS:%.$(O)=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 
 distclean: clean
diff --git a/configure.ac b/configure.ac
index 0f0de90..0ed0494 100644
--- a/configure.ac
+++ b/configure.ac
@@ -202,6 +202,7 @@ lib="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
 SOREV='$(SO).$(REV)'
+PIC_CFLAGS='-fPIC -DPIC'
 
 dnl Heap profiling uses the log(3) function.
 LIBS="$LIBS -lm"
@@ -287,6 +288,7 @@ AC_SUBST([exe])
 AC_SUBST([lib])
 AC_SUBST([DSO_LDFLAGS])
 AC_SUBST([SOREV])
+AC_SUBST([PIC_CFLAGS])
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:42 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:42 +0200
Subject: [PATCH 03/11] Add an abstraction layer for threading in tests
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-3-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 test/allocated.c             |   29 +++++++++--------------------
 test/jemalloc_test.h.in      |   20 ++++++++++++++++++++
 test/thread_arena.c          |   18 +++++-------------
 test/thread_tcache_enabled.c |   29 +++++++++--------------------
 4 files changed, 43 insertions(+), 53 deletions(-)

diff --git a/test/allocated.c b/test/allocated.c
index 81cd4ca..3f889f4 100644
--- a/test/allocated.c
+++ b/test/allocated.c
@@ -2,7 +2,6 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <stdbool.h>
-#include <pthread.h>
 #include <assert.h>
 #include <errno.h>
 #include <string.h>
@@ -11,7 +10,7 @@
 #include "jemalloc_test.h"
 
 void *
-thread_start(void *arg)
+je_thread_start(void *arg)
 {
 	int err;
 	void *p;
@@ -106,31 +105,21 @@ int
 main(void)
 {
 	int ret = 0;
-	pthread_t thread;
+	je_thread_t thread;
 
 	malloc_printf("Test begin\n");
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
 label_return:
 	malloc_printf("Test end\n");
diff --git a/test/jemalloc_test.h.in b/test/jemalloc_test.h.in
index 58fa08e..cb1a89a 100644
--- a/test/jemalloc_test.h.in
+++ b/test/jemalloc_test.h.in
@@ -5,3 +5,23 @@
  */
 #include "jemalloc/jemalloc at install_suffix@.h"
 #include "jemalloc/internal/jemalloc_internal.h"
+
+/* Abstraction layer for threading in tests */
+#include <pthread.h>
+
+typedef pthread_t je_thread_t;
+
+void
+je_thread_create(je_thread_t *thread, void *(*proc)(void *), void *arg)
+{
+	if (pthread_create(thread, NULL, proc, arg) != 0) {
+		malloc_printf("Error in pthread_create()\n");
+		exit(1);
+	}
+}
+
+void
+je_thread_join(je_thread_t thread, void **ret)
+{
+	pthread_join(thread, ret);
+}
diff --git a/test/thread_arena.c b/test/thread_arena.c
index e443b71..9835428 100644
--- a/test/thread_arena.c
+++ b/test/thread_arena.c
@@ -1,6 +1,5 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <pthread.h>
 #include <string.h>
 #include <assert.h>
 
@@ -10,7 +9,7 @@
 #define NTHREADS 10
 
 void *
-thread_start(void *arg)
+je_thread_start(void *arg)
 {
 	unsigned main_arena_ind = *(unsigned *)arg;
 	void *p;
@@ -52,7 +51,7 @@ main(void)
 	unsigned arena_ind;
 	size_t size;
 	int err;
-	pthread_t threads[NTHREADS];
+	je_thread_t threads[NTHREADS];
 	unsigned i;
 
 	malloc_printf("Test begin\n");
@@ -72,18 +71,11 @@ main(void)
 		goto label_return;
 	}
 
-	for (i = 0; i < NTHREADS; i++) {
-		if (pthread_create(&threads[i], NULL, thread_start,
-		    (void *)&arena_ind) != 0) {
-			malloc_printf("%s(): Error in pthread_create()\n",
-			    __func__);
-			ret = 1;
-			goto label_return;
-		}
-	}
+	for (i = 0; i < NTHREADS; i++)
+		je_thread_create(&threads[i], je_thread_start, (void *)&arena_ind);
 
 	for (i = 0; i < NTHREADS; i++)
-		pthread_join(threads[i], (void *)&ret);
+		je_thread_join(threads[i], (void *)&ret);
 
 label_return:
 	malloc_printf("Test end\n");
diff --git a/test/thread_tcache_enabled.c b/test/thread_tcache_enabled.c
index 59b76a2..e1cba43 100644
--- a/test/thread_tcache_enabled.c
+++ b/test/thread_tcache_enabled.c
@@ -1,7 +1,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdbool.h>
-#include <pthread.h>
 #include <assert.h>
 #include <errno.h>
 
@@ -9,7 +8,7 @@
 #include "jemalloc_test.h"
 
 void *
-thread_start(void *arg)
+je_thread_start(void *arg)
 {
 	int err;
 	size_t sz;
@@ -77,31 +76,21 @@ int
 main(void)
 {
 	int ret = 0;
-	pthread_t thread;
+	je_thread_t thread;
 
 	malloc_printf("Test begin\n");
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
-	if (pthread_create(&thread, NULL, thread_start, NULL)
-	    != 0) {
-		malloc_printf("%s(): Error in pthread_create()\n", __func__);
-		ret = 1;
-		goto label_return;
-	}
-	pthread_join(thread, (void *)&ret);
+	je_thread_create(&thread, je_thread_start, NULL);
+	je_thread_join(thread, (void *)&ret);
 
-	thread_start(NULL);
+	je_thread_start(NULL);
 
 label_return:
 	malloc_printf("Test end\n");
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:49 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:49 +0200
Subject: [PATCH 10/11] Remove extra argument for malloc_tsd_cleanup_register
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-10-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Bookkeeping an extra argument that actually only stores a function pointer
for a function we already have is not very useful.
---
 include/jemalloc/internal/tsd.h |   15 +++++----------
 src/tsd.c                       |    7 +++----
 2 files changed, 8 insertions(+), 14 deletions(-)

diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index db6b1a6..8f671a2 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -4,11 +4,7 @@
 /* Maximum number of malloc_tsd users with cleanup functions. */
 #define	MALLOC_TSD_CLEANUPS_MAX	8
 
-typedef struct malloc_tsd_cleanup_s malloc_tsd_cleanup_t;
-struct malloc_tsd_cleanup_s {
-	bool	(*f)(void *);
-	void	*arg;
-};
+typedef bool (*malloc_tsd_cleanup_t)(void);
 
 /*
  * TLS/TSD-agnostic macro-based implementation of thread-specific data.  There
@@ -110,13 +106,12 @@ a_attr bool		a_name##_booted = false;
     a_cleanup)								\
 /* Initialization/cleanup. */						\
 a_attr bool								\
-a_name##_tsd_cleanup_wrapper(void *arg)					\
+a_name##_tsd_cleanup_wrapper(void)					\
 {									\
-	bool (*cleanup)(void *) = arg;					\
 									\
 	if (a_name##_initialized) {					\
 		a_name##_initialized = false;				\
-		cleanup(&a_name##_tls);					\
+		a_cleanup(&a_name##_tls);					\
 	}								\
 	return (a_name##_initialized);					\
 }									\
@@ -126,7 +121,7 @@ a_name##_tsd_boot(void)							\
 									\
 	if (a_cleanup != malloc_tsd_no_cleanup) {			\
 		malloc_tsd_cleanup_register(				\
-		    &a_name##_tsd_cleanup_wrapper, a_cleanup);		\
+		    &a_name##_tsd_cleanup_wrapper);			\
 	}								\
 	a_name##_booted = true;						\
 	return (false);							\
@@ -290,7 +285,7 @@ a_name##_tsd_set(a_type *val)						\
 void	*malloc_tsd_malloc(size_t size);
 void	malloc_tsd_dalloc(void *wrapper);
 void	malloc_tsd_no_cleanup(void *);
-void	malloc_tsd_cleanup_register(bool (*f)(void *), void *arg);
+void	malloc_tsd_cleanup_register(bool (*f)(void));
 void	malloc_tsd_boot(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
diff --git a/src/tsd.c b/src/tsd.c
index 0838dc8..8e5e716 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -45,7 +45,7 @@ _malloc_thread_cleanup(void)
 		again = false;
 		for (i = 0; i < ncleanups; i++) {
 			if (pending[i]) {
-				pending[i] = cleanups[i].f(cleanups[i].arg);
+				pending[i] = cleanups[i]();
 				if (pending[i])
 					again = true;
 			}
@@ -55,12 +55,11 @@ _malloc_thread_cleanup(void)
 #endif
 
 void
-malloc_tsd_cleanup_register(bool (*f)(void *), void *arg)
+malloc_tsd_cleanup_register(bool (*f)(void))
 {
 
 	assert(ncleanups < MALLOC_TSD_CLEANUPS_MAX);
-	cleanups[ncleanups].f = f;
-	cleanups[ncleanups].arg = arg;
+	cleanups[ncleanups] = f;
 	ncleanups++;
 }
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:50 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:50 +0200
Subject: [PATCH 11/11] Add support for Mingw
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in                                      |    6 +-
 configure.ac                                     |   55 +++++++++---
 include/jemalloc/internal/jemalloc_internal.h.in |   11 ++-
 include/jemalloc/internal/mutex.h                |   16 +++-
 include/jemalloc/internal/tsd.h                  |  101 ++++++++++++++++++++++
 src/chunk_mmap.c                                 |   92 ++++++++++++++++----
 src/jemalloc.c                                   |   23 ++++-
 src/mutex.c                                      |   16 +++-
 src/tsd.c                                        |   26 +++++-
 src/util.c                                       |    5 +-
 test/jemalloc_test.h.in                          |   24 +++++
 test/rallocm.c                                   |    6 ++
 12 files changed, 332 insertions(+), 49 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 7f5dcf9..151f55f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -51,10 +51,14 @@ SOREV = @SOREV@
 PIC_CFLAGS = @PIC_CFLAGS@
 
 ifeq (macho, $(ABI))
-TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
+TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH="$(objroot)lib"
+else
+ifeq (pecoff, $(ABI))
+TEST_LIBRARY_PATH := PATH="$(PATH):$(objroot)lib"
 else
 TEST_LIBRARY_PATH :=
 endif
+endif
 
 LIBJEMALLOC := $(LIB)jemalloc$(install_suffix)
 
diff --git a/configure.ac b/configure.ac
index 0ed0494..ba5355a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -273,6 +273,18 @@ case "${host}" in
 	fi
 	abi="xcoff"
 	;;
+  *-*-mingw*)
+	abi="pecoff"
+	force_tls="0"
+	RPATH=""
+	so="dll"
+	DSO_LDFLAGS="-shared"
+	o="obj"
+	a="lib"
+	exe=".exe"
+	SOREV='$(SO)'
+	PIC_CFLAGS=""
+	;;
   *)
 	AC_MSG_RESULT([Unsupported operating system: ${host}])
 	abi="elf"
@@ -817,23 +829,36 @@ AC_SUBST([enable_xmalloc])
 AC_CACHE_CHECK([STATIC_PAGE_SHIFT],
                [je_cv_static_page_shift],
                AC_RUN_IFELSE([AC_LANG_PROGRAM(
-[[#include <stdio.h>
+[[
+#ifdef _WIN32
+#include <windows.h>
+#else
 #include <unistd.h>
 #include <strings.h>
+#endif
+#include <stdio.h>
 ]],
 [[
     long result;
     FILE *f;
 
+#ifdef _WIN32
+    SYSTEM_INFO si;
+    GetSystemInfo(&si);
+    result = si.dwPageSize;
+#else
     result = sysconf(_SC_PAGESIZE);
+#endif
     if (result == -1) {
 	return 1;
     }
+    result = ffsl(result) - 1;
+
     f = fopen("conftest.out", "w");
     if (f == NULL) {
 	return 1;
     }
-    fprintf(f, "%u\n", ffs((int)result) - 1);
+    fprintf(f, "%u\n", result);
     fclose(f);
 
     return 0;
@@ -871,12 +896,14 @@ AC_SUBST([jemalloc_version_gid])
 dnl ============================================================================
 dnl Configure pthreads.
 
-AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])
-dnl Some systems may embed pthreads functionality in libc; check for libpthread
-dnl first, but try libc too before failing.
-AC_CHECK_LIB([pthread], [pthread_create], [LIBS="$LIBS -lpthread"],
-             [AC_SEARCH_LIBS([pthread_create], , ,
-                             AC_MSG_ERROR([libpthread is missing]))])
+if test "x$abi" != "xpecoff" ; then
+  AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])
+  dnl Some systems may embed pthreads functionality in libc; check for libpthread
+  dnl first, but try libc too before failing.
+  AC_CHECK_LIB([pthread], [pthread_create], [LIBS="$LIBS -lpthread"],
+               [AC_SEARCH_LIBS([pthread_create], , ,
+                               AC_MSG_ERROR([libpthread is missing]))])
+fi
 
 CPPFLAGS="$CPPFLAGS -D_REENTRANT"
 
@@ -921,11 +948,13 @@ if test "x$enable_lazy_lock" = "x0" -a "x${force_lazy_lock}" = "x1" ; then
   enable_lazy_lock="1"
 fi
 if test "x$enable_lazy_lock" = "x1" ; then
-  AC_CHECK_HEADERS([dlfcn.h], , [AC_MSG_ERROR([dlfcn.h is missing])])
-  AC_CHECK_FUNC([dlsym], [],
-    [AC_CHECK_LIB([dl], [dlsym], [LIBS="$LIBS -ldl"],
-                  [AC_MSG_ERROR([libdl is missing])])
-    ])
+  if test "x$abi" != "xpecoff" ; then
+    AC_CHECK_HEADERS([dlfcn.h], , [AC_MSG_ERROR([dlfcn.h is missing])])
+    AC_CHECK_FUNC([dlsym], [],
+      [AC_CHECK_LIB([dl], [dlsym], [LIBS="$LIBS -ldl"],
+                    [AC_MSG_ERROR([libdl is missing])])
+      ])
+  fi
   AC_DEFINE([JEMALLOC_LAZY_LOCK], [ ])
 fi
 AC_SUBST([enable_lazy_lock])
diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index 905653a..2439797 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -1,21 +1,25 @@
 #ifndef JEMALLOC_INTERNAL_H
 #define JEMALLOC_INTERNAL_H
-#include <sys/mman.h>
 #include <sys/param.h>
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <sys/mman.h>
 #include <sys/syscall.h>
 #if !defined(SYS_write) && defined(__NR_write)
 #define	SYS_write __NR_write
 #endif
+#include <sys/uio.h>
+#include <pthread.h>
+#endif
 #include <sys/time.h>
 #include <sys/types.h>
-#include <sys/uio.h>
 
 #include <errno.h>
 #include <limits.h>
 #ifndef SIZE_T_MAX
 #  define SIZE_T_MAX	SIZE_MAX
 #endif
-#include <pthread.h>
 #include <sched.h>
 #include <stdarg.h>
 #include <stdbool.h>
@@ -32,7 +36,6 @@
 #include <ctype.h>
 #include <unistd.h>
 #include <fcntl.h>
-#include <pthread.h>
 #include <math.h>
 
 #define	JEMALLOC_NO_DEMANGLE
diff --git a/include/jemalloc/internal/mutex.h b/include/jemalloc/internal/mutex.h
index c46feee..3940280 100644
--- a/include/jemalloc/internal/mutex.h
+++ b/include/jemalloc/internal/mutex.h
@@ -3,7 +3,9 @@
 
 typedef struct malloc_mutex_s malloc_mutex_t;
 
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+#define	MALLOC_MUTEX_INITIALIZER
+#elif (defined(JEMALLOC_OSSPIN))
 #define	MALLOC_MUTEX_INITIALIZER {0}
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 #define	MALLOC_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER, NULL}
@@ -23,7 +25,9 @@ typedef struct malloc_mutex_s malloc_mutex_t;
 #ifdef JEMALLOC_H_STRUCTS
 
 struct malloc_mutex_s {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+	CRITICAL_SECTION	lock;
+#elif (defined(JEMALLOC_OSSPIN))
 	OSSpinLock		lock;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	pthread_mutex_t		lock;
@@ -64,7 +68,9 @@ malloc_mutex_lock(malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+		EnterCriticalSection(&mutex->lock);
+#elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockLock(&mutex->lock);
 #else
 		pthread_mutex_lock(&mutex->lock);
@@ -77,7 +83,9 @@ malloc_mutex_unlock(malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+		LeaveCriticalSection(&mutex->lock);
+#elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockUnlock(&mutex->lock);
 #else
 		pthread_mutex_unlock(&mutex->lock);
diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index 8f671a2..4b129e3 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -74,6 +74,10 @@ extern bool		a_name##_booted;
 extern __thread a_type	a_name##_tls;					\
 extern pthread_key_t	a_name##_tsd;					\
 extern bool		a_name##_booted;
+#elif (defined(_WIN32))
+#define malloc_tsd_externs(a_name, a_type)				\
+extern DWORD		a_name##_tsd;					\
+extern bool		a_name##_booted;
 #else
 #define	malloc_tsd_externs(a_name, a_type)				\
 extern pthread_key_t	a_name##_tsd;					\
@@ -94,6 +98,10 @@ a_attr __thread a_type JEMALLOC_TLS_MODEL				\
     a_name##_tls = a_initializer;					\
 a_attr pthread_key_t	a_name##_tsd;					\
 a_attr bool		a_name##_booted = false;
+#elif (defined(_WIN32))
+#define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
+a_attr DWORD		a_name##_tsd;					\
+a_attr bool		a_name##_booted = false;
 #else
 #define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
 a_attr pthread_key_t	a_name##_tsd;					\
@@ -182,6 +190,99 @@ a_name##_tsd_set(a_type *val)						\
 		}							\
 	}								\
 }
+#elif (defined(_WIN32))
+#define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
+    a_cleanup)								\
+/* Data structure. */							\
+typedef struct {							\
+	bool	initialized;						\
+	a_type	val;							\
+} a_name##_tsd_wrapper_t;						\
+/* Initialization/cleanup. */						\
+a_attr bool								\
+a_name##_tsd_cleanup_wrapper(void)					\
+{									\
+	a_name##_tsd_wrapper_t *wrapper;				\
+									\
+	wrapper = (a_name##_tsd_wrapper_t *) TlsGetValue(a_name##_tsd);	\
+	if (wrapper == NULL)						\
+		return false;						\
+	if (a_cleanup != malloc_tsd_no_cleanup &&			\
+	    wrapper->initialized) {					\
+		a_type val = wrapper->val;				\
+		a_type tsd_static_data = a_initializer;			\
+		wrapper->initialized = false;				\
+		wrapper->val = tsd_static_data;				\
+		a_cleanup(&val);					\
+		if (wrapper->initialized) {				\
+			/* Trigger another cleanup round. */		\
+			return (true);					\
+		}							\
+	}								\
+	malloc_tsd_dalloc(wrapper);					\
+	return (false);							\
+}									\
+a_attr bool								\
+a_name##_tsd_boot(void)							\
+{									\
+									\
+	a_name##_tsd = TlsAlloc();					\
+	if (a_name##_tsd == TLS_OUT_OF_INDEXES)				\
+		return (true);						\
+	if (a_cleanup != malloc_tsd_no_cleanup) {			\
+		malloc_tsd_cleanup_register(				\
+		    &a_name##_tsd_cleanup_wrapper);			\
+	}								\
+	a_name##_booted = true;						\
+	return (false);							\
+}									\
+/* Get/set. */								\
+a_attr a_name##_tsd_wrapper_t *						\
+a_name##_tsd_get_wrapper(void)						\
+{									\
+	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)	\
+	    TlsGetValue(a_name##_tsd);					\
+									\
+	if (wrapper == NULL) {						\
+		wrapper = (a_name##_tsd_wrapper_t *)			\
+		    malloc_tsd_malloc(sizeof(a_name##_tsd_wrapper_t));	\
+		if (wrapper == NULL) {					\
+			malloc_write("<jemalloc>: Error allocating"	\
+			    " TSD for "#a_name"\n");			\
+			abort();					\
+		} else {						\
+			static a_type tsd_static_data = a_initializer;	\
+			wrapper->initialized = false;			\
+			wrapper->val = tsd_static_data;			\
+		}							\
+		if (!TlsSetValue(a_name##_tsd, (void *)wrapper)) {	\
+			malloc_write("<jemalloc>: Error setting"	\
+			    " TSD for "#a_name"\n");			\
+			abort();					\
+		}							\
+	}								\
+	return (wrapper);						\
+}									\
+a_attr a_type const *							\
+a_name##_tsd_get(void)							\
+{									\
+	a_name##_tsd_wrapper_t *wrapper;				\
+									\
+	assert(a_name##_booted);					\
+	wrapper = a_name##_tsd_get_wrapper();				\
+	return (&wrapper->val);						\
+}									\
+a_attr void								\
+a_name##_tsd_set(a_type *val)						\
+{									\
+	a_name##_tsd_wrapper_t *wrapper;				\
+									\
+	assert(a_name##_booted);					\
+	wrapper = a_name##_tsd_get_wrapper();				\
+	wrapper->val = *(val);						\
+	if (a_cleanup != malloc_tsd_no_cleanup)				\
+		wrapper->initialized = true;				\
+}
 #else
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index 3ab9095..ae411e0 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -27,6 +27,14 @@ pages_map(void *addr, size_t size)
 {
 	void *ret;
 
+#ifdef _WIN32
+	/*
+	 * If it can't allocate at the given address when one is given,
+	 * VirtualAlloc fails and returns NULL.
+	 */
+	ret = VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE,
+	                   PAGE_READWRITE);
+#else
 	/*
 	 * We don't use MAP_FIXED here, because it can cause the *replacement*
 	 * of existing mappings, and we only want to create new mappings.
@@ -52,7 +60,7 @@ pages_map(void *addr, size_t size)
 		}
 		ret = NULL;
 	}
-
+#endif
 	assert(ret == NULL || (addr == NULL && ret != addr)
 	    || (addr != NULL && ret == addr));
 	return (ret);
@@ -62,19 +70,62 @@ static void
 pages_unmap(void *addr, size_t size)
 {
 
-	if (munmap(addr, size) == -1) {
+#ifdef _WIN32
+	if (VirtualFree(addr, 0, MEM_RELEASE) == 0)
+#else
+	if (munmap(addr, size) == -1)
+#endif
+	{
 		char buf[BUFERROR_BUF];
 
 		buferror(errno, buf, sizeof(buf));
-		malloc_printf("<jemalloc>: Error in munmap(): %s\n", buf);
+		malloc_printf("<jemalloc>: Error in "
+#ifdef _WIN32
+		              "VirtualFree"
+#else
+		              "munmap"
+#endif
+		              "(): %s\n", buf);
 		if (opt_abort)
 			abort();
 	}
 }
 
+static void *
+pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size)
+{
+
+	void *ret = (void *)((uintptr_t)addr + leadsize);
+#ifndef _WIN32
+	size_t trailsize;
+#endif
+
+	assert(alloc_size >= leadsize + size);
+#ifdef _WIN32
+	void *new_addr;
+	pages_unmap(addr, alloc_size);
+	new_addr = pages_map(ret, size);
+	if (new_addr == ret)
+		return ret;
+	if (new_addr)
+		pages_unmap(new_addr, size);
+	return NULL;
+#else
+	trailsize = alloc_size - leadsize - size;
+	if (leadsize != 0)
+		pages_unmap(addr, leadsize);
+	if (trailsize != 0)
+		pages_unmap((void *)((uintptr_t)ret + size), trailsize);
+	return ret;
+#endif
+}
+
 void
 pages_purge(void *addr, size_t length)
 {
+#ifdef _WIN32
+	VirtualAlloc(addr, length, MEM_RESET, PAGE_READWRITE);
+#else
 #ifdef JEMALLOC_PURGE_MADVISE_DONTNEED
 #  define JEMALLOC_MADV_PURGE MADV_DONTNEED
 #elif defined(JEMALLOC_PURGE_MADVISE_FREE)
@@ -83,33 +134,32 @@ pages_purge(void *addr, size_t length)
 #  error "No method defined for purging unused dirty pages."
 #endif
 	madvise(addr, length, JEMALLOC_MADV_PURGE);
+#endif
 }
 
+
 static void *
 chunk_alloc_mmap_slow(size_t size, size_t alignment, bool unaligned)
 {
 	void *ret, *pages;
-	size_t alloc_size, leadsize, trailsize;
+	size_t alloc_size, leadsize;
 
 	alloc_size = size + alignment - PAGE;
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size)
 		return (NULL);
-	pages = pages_map(NULL, alloc_size);
-	if (pages == NULL)
-		return (NULL);
-	leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment) -
-	    (uintptr_t)pages;
-	assert(alloc_size >= leadsize + size);
-	trailsize = alloc_size - leadsize - size;
-	ret = (void *)((uintptr_t)pages + leadsize);
-	if (leadsize != 0) {
-		/* Note that mmap() returned an unaligned mapping. */
-		unaligned = true;
-		pages_unmap(pages, leadsize);
-	}
-	if (trailsize != 0)
-		pages_unmap((void *)((uintptr_t)ret + size), trailsize);
+	do {
+		pages = pages_map(NULL, alloc_size);
+		if (pages == NULL)
+			return (NULL);
+		leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment) -
+		    (uintptr_t)pages;
+		ret = pages_trim(pages, alloc_size, leadsize, size);
+		if (leadsize != 0) {
+			/* Note that mmap() returned an unaligned mapping. */
+			unaligned = true;
+		}
+	} while (ret == NULL);
 
 	/*
 	 * If mmap() returned an aligned mapping, reset mmap_unaligned so that
@@ -168,6 +218,9 @@ chunk_alloc_mmap(size_t size, size_t alignment)
 		if (offset != 0) {
 			bool mu = true;
 			mmap_unaligned_tsd_set(&mu);
+#ifdef _WIN32
+			ret = chunk_alloc_mmap_slow(size, alignment, true);
+#else
 			/* Try to extend chunk boundary. */
 			if (pages_map((void *)((uintptr_t)ret + size),
 			    chunksize - offset) == NULL) {
@@ -184,6 +237,7 @@ chunk_alloc_mmap(size_t size, size_t alignment)
 				ret = (void *)((uintptr_t)ret + (chunksize -
 				    offset));
 			}
+#endif
 		}
 	} else
 		ret = chunk_alloc_mmap_slow(size, alignment, false);
diff --git a/src/jemalloc.c b/src/jemalloc.c
index db0b2b5..6d83ab0 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -52,7 +52,17 @@ static bool			malloc_initializer = NO_INITIALIZER;
 #endif
 
 /* Used to avoid initialization races. */
+#ifdef _WIN32
+static malloc_mutex_t	init_lock;
+
+JEMALLOC_ATTR(constructor)
+static void
+init_init_lock() {
+	malloc_mutex_init(&init_lock);
+}
+#else
 static malloc_mutex_t	init_lock = MALLOC_MUTEX_INITIALIZER;
+#endif
 
 typedef struct {
 	void	*p;	/* Input pointer (as in realloc(p, s)). */
@@ -229,11 +239,17 @@ malloc_ncpus(void)
 	unsigned ret;
 	long result;
 
+#ifdef _WIN32
+	SYSTEM_INFO si;
+	GetSystemInfo(&si);
+	result = si.dwNumberOfProcessors;
+#else
 	result = sysconf(_SC_NPROCESSORS_ONLN);
 	if (result == -1) {
 		/* Error. */
 		ret = 1;
 	}
+#endif
 	ret = (unsigned)result;
 
 	return (ret);
@@ -369,6 +385,7 @@ malloc_conf_init(void)
 			}
 			break;
 		case 1: {
+#ifndef _WIN32
 			int linklen;
 			const char *linkname =
 #ifdef JEMALLOC_PREFIX
@@ -386,7 +403,9 @@ malloc_conf_init(void)
 				 */
 				buf[linklen] = '\0';
 				opts = buf;
-			} else {
+			} else
+#endif
+			{
 				/* No configuration specified. */
 				buf[0] = '\0';
 				opts = buf;
@@ -609,7 +628,7 @@ malloc_init_hard(void)
 
 	malloc_conf_init();
 
-#if (!defined(JEMALLOC_MUTEX_INIT_CB) && !defined(JEMALLOC_ZONE))
+#if (!defined(JEMALLOC_MUTEX_INIT_CB) && !defined(JEMALLOC_ZONE) && !defined(_WIN32))
 	/* Register fork handlers. */
 	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
 	    jemalloc_postfork_child) != 0) {
diff --git a/src/mutex.c b/src/mutex.c
index 4b8ce57..159d82a 100644
--- a/src/mutex.c
+++ b/src/mutex.c
@@ -1,10 +1,14 @@
 #define	JEMALLOC_MUTEX_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
-#ifdef JEMALLOC_LAZY_LOCK
+#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
 #include <dlfcn.h>
 #endif
 
+#ifndef _CRT_SPINCOUNT
+#define _CRT_SPINCOUNT 4000
+#endif
+
 /******************************************************************************/
 /* Data. */
 
@@ -16,7 +20,7 @@ static bool		postpone_init = true;
 static malloc_mutex_t	*postponed_mutexes = NULL;
 #endif
 
-#ifdef JEMALLOC_LAZY_LOCK
+#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
 static void	pthread_create_once(void);
 #endif
 
@@ -26,7 +30,7 @@ static void	pthread_create_once(void);
  * process goes multi-threaded.
  */
 
-#ifdef JEMALLOC_LAZY_LOCK
+#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
 static int (*pthread_create_fptr)(pthread_t *__restrict, const pthread_attr_t *,
     void *(*)(void *), void *__restrict);
 
@@ -68,7 +72,11 @@ int	_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,
 bool
 malloc_mutex_init(malloc_mutex_t *mutex)
 {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+	if (!InitializeCriticalSectionAndSpinCount(&mutex->lock,
+	    _CRT_SPINCOUNT))
+		return (true);
+#elif (defined(JEMALLOC_OSSPIN))
 	mutex->lock = 0;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	if (postpone_init) {
diff --git a/src/tsd.c b/src/tsd.c
index 8e5e716..417f958 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -31,7 +31,7 @@ malloc_tsd_no_cleanup(void *arg)
 	not_reached();
 }
 
-#ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
+#if defined(JEMALLOC_MALLOC_THREAD_CLEANUP) || defined(_WIN32)
 void
 _malloc_thread_cleanup(void)
 {
@@ -69,3 +69,27 @@ malloc_tsd_boot(void)
 
 	ncleanups = 0;
 }
+
+#ifdef _WIN32
+static BOOL WINAPI
+_tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+{
+	switch (fdwReason) {
+#ifdef JEMALLOC_LAZY_LOCK
+	case DLL_THREAD_ATTACH:
+		isthreaded = true;
+		break;
+#endif
+	case DLL_THREAD_DETACH:
+		_malloc_thread_cleanup();
+		break;
+	default:
+		break;
+	}
+	return true;
+}
+
+JEMALLOC_ATTR(section(".CRT$XLY")) JEMALLOC_ATTR(used)
+static const BOOL WINAPI (*tls_callback)(HINSTANCE hinstDLL, DWORD fdwReason,
+	LPVOID lpvReserved) = _tls_callback;
+#endif
diff --git a/src/util.c b/src/util.c
index 99ae26d..2f1c8f0 100644
--- a/src/util.c
+++ b/src/util.c
@@ -67,7 +67,10 @@ void	(*je_malloc_message)(void *, const char *s)
 int
 buferror(int errnum, char *buf, size_t buflen)
 {
-#ifdef _GNU_SOURCE
+#ifdef _WIN32
+	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, (LPSTR)buf, buflen, NULL);
+	return (0);
+#elif defined(_GNU_SOURCE)
 	char *b = strerror_r(errno, buf, buflen);
 	if (b != buf) {
 		strncpy(buf, b, buflen);
diff --git a/test/jemalloc_test.h.in b/test/jemalloc_test.h.in
index cb1a89a..43f8d24 100644
--- a/test/jemalloc_test.h.in
+++ b/test/jemalloc_test.h.in
@@ -7,6 +7,29 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /* Abstraction layer for threading in tests */
+#ifdef _WIN32
+#include <windows.h>
+
+typedef HANDLE je_thread_t;
+
+void
+je_thread_create(je_thread_t *thread, void *(*proc)(void *), void *arg)
+{
+	LPTHREAD_START_ROUTINE routine = (LPTHREAD_START_ROUTINE)proc;
+	*thread = CreateThread(NULL, 0, routine, arg, 0, NULL);
+	if (*thread == NULL) {
+		malloc_printf("Error in CreateThread()\n");
+		exit(1);
+	}
+}
+
+void
+je_thread_join(je_thread_t thread, void **ret)
+{
+	WaitForSingleObject(thread, INFINITE);
+}
+
+#else
 #include <pthread.h>
 
 typedef pthread_t je_thread_t;
@@ -25,3 +48,4 @@ je_thread_join(je_thread_t thread, void **ret)
 {
 	pthread_join(thread, ret);
 }
+#endif
diff --git a/test/rallocm.c b/test/rallocm.c
index 18db5ee..f2a4770 100644
--- a/test/rallocm.c
+++ b/test/rallocm.c
@@ -19,9 +19,15 @@ main(void)
 
 	/* Get page size. */
 	{
+#ifdef _WIN32
+		SYSTEM_INFO si;
+		GetSystemInfo(&si);
+		pagesize = (size_t)si.dwPageSize;
+#else
 		long result = sysconf(_SC_PAGESIZE);
 		assert(result != -1);
 		pagesize = (size_t)result;
+#endif
 	}
 
 	r = allocm(&p, &sz, 42, 0);
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:46 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:46 +0200
Subject: [PATCH 07/11] Disallow *_tsd_get() = value assignments
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-7-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 include/jemalloc/internal/tsd.h |    8 +++---
 src/ctl.c                       |    4 +--
 src/jemalloc.c                  |   51 +++++++++++++++++++++++++++------------
 3 files changed, 41 insertions(+), 22 deletions(-)

diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index 35ae5e3..aee37b1 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -62,7 +62,7 @@ struct malloc_tsd_cleanup_s {
 #define	malloc_tsd_protos(a_attr, a_name, a_type)			\
 a_attr bool								\
 a_name##_tsd_boot(void);						\
-a_attr a_type *								\
+a_attr a_type const *							\
 a_name##_tsd_get(void);							\
 a_attr void								\
 a_name##_tsd_set(a_type *val);
@@ -132,7 +132,7 @@ a_name##_tsd_boot(void)							\
 	return (false);							\
 }									\
 /* Get/set. */								\
-a_attr a_type *								\
+a_attr a_type const *							\
 a_name##_tsd_get(void)							\
 {									\
 									\
@@ -164,7 +164,7 @@ a_name##_tsd_boot(void)							\
 	return (false);							\
 }									\
 /* Get/set. */								\
-a_attr a_type *								\
+a_attr a_type const *							\
 a_name##_tsd_get(void)							\
 {									\
 									\
@@ -265,7 +265,7 @@ a_name##_tsd_get_wrapper(void)						\
 	}								\
 	return (wrapper);						\
 }									\
-a_attr a_type *								\
+a_attr a_type const *							\
 a_name##_tsd_get(void)							\
 {									\
 	a_name##_tsd_wrapper_t *wrapper;				\
diff --git a/src/ctl.c b/src/ctl.c
index 98ea3d1..0c1c8f8 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -1079,11 +1079,11 @@ label_return:
 CTL_RO_NL_CGEN(config_stats, thread_allocated,
     thread_allocated_tsd_get()->allocated, uint64_t)
 CTL_RO_NL_CGEN(config_stats, thread_allocatedp,
-    &thread_allocated_tsd_get()->allocated, uint64_t *)
+    &thread_allocated_tsd_get()->allocated, uint64_t const *)
 CTL_RO_NL_CGEN(config_stats, thread_deallocated,
     thread_allocated_tsd_get()->deallocated, uint64_t)
 CTL_RO_NL_CGEN(config_stats, thread_deallocatedp,
-    &thread_allocated_tsd_get()->deallocated, uint64_t *)
+    &thread_allocated_tsd_get()->deallocated, uint64_t const *)
 
 /******************************************************************************/
 
diff --git a/src/jemalloc.c b/src/jemalloc.c
index d4b681b..db0b2b5 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -818,8 +818,11 @@ label_oom:
 	if (config_prof && opt_prof && ret != NULL)
 		prof_malloc(ret, usize, cnt);
 	if (config_stats && ret != NULL) {
+		thread_allocated_t ta;
 		assert(usize == isalloc(ret, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		ta = *thread_allocated_tsd_get();
+		ta.allocated += usize;
+		thread_allocated_tsd_set(&ta);
 	}
 	UTRACE(0, size, ret);
 	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, usize, false);
@@ -911,8 +914,11 @@ imemalign(void **memptr, size_t alignment, size_t size,
 
 label_return:
 	if (config_stats && result != NULL) {
+		thread_allocated_t ta;
 		assert(usize == isalloc(result, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		ta = *thread_allocated_tsd_get();
+		ta.allocated += usize;
+		thread_allocated_tsd_set(&ta);
 	}
 	if (config_prof && opt_prof && result != NULL)
 		prof_malloc(result, usize, cnt);
@@ -1017,8 +1023,11 @@ label_return:
 	if (config_prof && opt_prof && ret != NULL)
 		prof_malloc(ret, usize, cnt);
 	if (config_stats && ret != NULL) {
+		thread_allocated_t ta;
 		assert(usize == isalloc(ret, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		ta = *thread_allocated_tsd_get();
+		ta.allocated += usize;
+		thread_allocated_tsd_set(&ta);
 	}
 	UTRACE(0, num_size, ret);
 	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, usize, true);
@@ -1162,11 +1171,12 @@ label_return:
 	if (config_prof && opt_prof)
 		prof_realloc(ret, usize, cnt, old_size, old_ctx);
 	if (config_stats && ret != NULL) {
-		thread_allocated_t *ta;
+		thread_allocated_t ta;
 		assert(usize == isalloc(ret, config_prof));
-		ta = thread_allocated_tsd_get();
-		ta->allocated += usize;
-		ta->deallocated += old_size;
+		ta = *thread_allocated_tsd_get();
+		ta.allocated += usize;
+		ta.deallocated += old_size;
+		thread_allocated_tsd_set(&ta);
 	}
 	UTRACE(ptr, size, ret);
 	JEMALLOC_VALGRIND_REALLOC(ret, usize, ptr, old_size, old_rzsize, false);
@@ -1190,8 +1200,11 @@ je_free(void *ptr)
 			prof_free(ptr, usize);
 		} else if (config_stats || config_valgrind)
 			usize = isalloc(ptr, config_prof);
-		if (config_stats)
-			thread_allocated_tsd_get()->deallocated += usize;
+		if (config_stats) {
+			thread_allocated_t ta = *thread_allocated_tsd_get();
+			ta.deallocated += usize;
+			thread_allocated_tsd_set(&ta);
+		}
 		if (config_valgrind && opt_valgrind)
 			rzsize = p2rz(ptr);
 		iqalloc(ptr);
@@ -1408,8 +1421,11 @@ je_allocm(void **ptr, size_t *rsize, size_t size, int flags)
 
 	*ptr = p;
 	if (config_stats) {
+		thread_allocated_t ta;
 		assert(usize == isalloc(p, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		ta = *thread_allocated_tsd_get();
+		ta.allocated += usize;
+		thread_allocated_tsd_set(&ta);
 	}
 	UTRACE(0, size, p);
 	JEMALLOC_VALGRIND_MALLOC(true, p, usize, zero);
@@ -1512,10 +1528,10 @@ je_rallocm(void **ptr, size_t *rsize, size_t size, size_t extra, int flags)
 
 	*ptr = q;
 	if (config_stats) {
-		thread_allocated_t *ta;
-		ta = thread_allocated_tsd_get();
-		ta->allocated += usize;
-		ta->deallocated += old_size;
+		thread_allocated_t ta = *thread_allocated_tsd_get();
+		ta.allocated += usize;
+		ta.deallocated += old_size;
+		thread_allocated_tsd_set(&ta);
 	}
 	UTRACE(p, size, q);
 	JEMALLOC_VALGRIND_REALLOC(q, usize, p, old_size, old_rzsize, zero);
@@ -1575,8 +1591,11 @@ je_dallocm(void *ptr, int flags)
 			usize = isalloc(ptr, config_prof);
 		prof_free(ptr, usize);
 	}
-	if (config_stats)
-		thread_allocated_tsd_get()->deallocated += usize;
+	if (config_stats) {
+		thread_allocated_t ta = *thread_allocated_tsd_get();
+		ta.deallocated += usize;
+		thread_allocated_tsd_set(&ta);
+	}
 	if (config_valgrind && opt_valgrind)
 		rzsize = p2rz(ptr);
 	iqalloc(ptr);
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 09:29:47 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 18:29:47 +0200
Subject: [PATCH 08/11] Initialize all members of non-TLS tsd wrapper when
	creating it
In-Reply-To: <1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334766590-7296-8-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Not setting the initialized member leads to randomly calling the cleanup
function in cases it shouldn't be called (and isn't called in other
implementations).
---
 include/jemalloc/internal/tsd.h |    1 +
 1 file changed, 1 insertion(+)

diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index aee37b1..d1dd3d0 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -253,6 +253,7 @@ a_name##_tsd_get_wrapper(void)						\
 		} else {						\
 			static a_type tsd_static_data = a_initializer;	\
 			wrapper->isstatic = false;			\
+			wrapper->initialized = false;			\
 			wrapper->val = tsd_static_data;			\
 		}							\
 		if (pthread_setspecific(a_name##_tsd,			\
-- 
1.7.10



From mh+jemalloc at glandium.org  Wed Apr 18 10:34:15 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 19:34:15 +0200
Subject: jemalloc-dev is massive
Message-ID: <20120418173415.GA15242@glandium.org>

Hi,

I just saw that even stripped, libjemalloc.so is massive: 234K on my
system. This size goes down to about 180K when using -ffunction-sections
-fdata-sections when compiling, and -Wl,--gc-sections when linking.
As a comparison, the fork we currently use in Firefox builds as
a 32K library.
There's also 74K (!) of .bss in jemalloc-dev, vs. <1K in the old Firefox
fork. That seems quite excessive.

Mike


From mh+jemalloc at glandium.org  Wed Apr 18 10:40:36 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Wed, 18 Apr 2012 19:40:36 +0200
Subject: jemalloc-dev is massive
In-Reply-To: <20120418173415.GA15242@glandium.org>
References: <20120418173415.GA15242@glandium.org>
Message-ID: <20120418174036.GB15242@glandium.org>

On Wed, Apr 18, 2012 at 07:34:15PM +0200, Mike Hommey wrote:
> Hi,
> 
> I just saw that even stripped, libjemalloc.so is massive: 234K on my
> system. This size goes down to about 180K when using -ffunction-sections
> -fdata-sections when compiling, and -Wl,--gc-sections when linking.
> As a comparison, the fork we currently use in Firefox builds as
> a 32K library.
> There's also 74K (!) of .bss in jemalloc-dev, vs. <1K in the old Firefox
> fork. That seems quite excessive.

I just figured that .bss is only 8K in the -Wl,--gc-sections build. It
seems most of its size comes from the (disabled at build time) profiler.
In these 8K, 4K come from the opt_prof_prefix variable, which is not
stripped out, and 3K from arena_bin_info.

Mike


From jasone at canonware.com  Wed Apr 18 14:14:04 2012
From: jasone at canonware.com (Jason Evans)
Date: Wed, 18 Apr 2012 14:14:04 -0700
Subject: jemalloc-dev is massive
In-Reply-To: <20120418174036.GB15242@glandium.org>
References: <20120418173415.GA15242@glandium.org>
	<20120418174036.GB15242@glandium.org>
Message-ID: <5222E671-2B67-4D76-B384-D7B15136451C@canonware.com>

On Apr 18, 2012, at 10:40 AM, Mike Hommey wrote:
> On Wed, Apr 18, 2012 at 07:34:15PM +0200, Mike Hommey wrote:
>> 
>> I just saw that even stripped, libjemalloc.so is massive: 234K on my
>> system. This size goes down to about 180K when using -ffunction-sections
>> -fdata-sections when compiling, and -Wl,--gc-sections when linking.
>> As a comparison, the fork we currently use in Firefox builds as
>> a 32K library.
>> There's also 74K (!) of .bss in jemalloc-dev, vs. <1K in the old Firefox
>> fork. That seems quite excessive.
> 
> I just figured that .bss is only 8K in the -Wl,--gc-sections build. It
> seems most of its size comes from the (disabled at build time) profiler.
> In these 8K, 4K come from the opt_prof_prefix variable, which is not
> stripped out, and 3K from arena_bin_info.


I just committed a change that should allow opt_prof_prefix to be stripped out.  arena_bin_info used to be duplicated in the bins of every arena, so although it increases the binary size, it decreases memory usage.

With the following configuration (similar to what Mozilla currently uses, IIRC), I get a .so that is 135 KiB:

	EXTRA_CFLAGS="-ffunction-sections -fdata-sections"  LDFLAGS=-Wl,--gc-sections ./autogen.sh --disable-fill --disable-valgrind --disable-experimental

That's still a lot bigger than 32 KiB, but is it so terrible?  Most of the bulk appears to be in the mallctl, stats, and util code, which is cold code unless explicitly called.

Jason

From mh+jemalloc at glandium.org  Thu Apr 19 04:03:57 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 13:03:57 +0200
Subject: [PATCH 12/14] Rename LIB to LIBPREFIX, and set it to nothing on mingw
In-Reply-To: <1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>
References: <1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334833439-5736-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in  |    4 ++--
 configure.ac |    5 +++--
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 151f55f..6caad4e 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -32,7 +32,7 @@ SO := @so@
 O := @o@
 A := @a@
 EXE := @exe@
-LIB := @lib@
+LIBPREFIX := @libprefix@
 REV := @rev@
 install_suffix := @install_suffix@
 ABI := @abi@
@@ -60,7 +60,7 @@ TEST_LIBRARY_PATH :=
 endif
 endif
 
-LIBJEMALLOC := $(LIB)jemalloc$(install_suffix)
+LIBJEMALLOC := $(LIBPREFIX)jemalloc$(install_suffix)
 
 # Lists of files.
 BINS := $(srcroot)bin/pprof $(objroot)bin/jemalloc.sh
diff --git a/configure.ac b/configure.ac
index ba5355a..5bdddfa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -198,7 +198,7 @@ so="so"
 o="o"
 a="a"
 exe=
-lib="lib"
+libprefix="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
 SOREV='$(SO).$(REV)'
@@ -281,6 +281,7 @@ case "${host}" in
 	DSO_LDFLAGS="-shared"
 	o="obj"
 	a="lib"
+	libprefix=""
 	exe=".exe"
 	SOREV='$(SO)'
 	PIC_CFLAGS=""
@@ -297,7 +298,7 @@ AC_SUBST([so])
 AC_SUBST([o])
 AC_SUBST([a])
 AC_SUBST([exe])
-AC_SUBST([lib])
+AC_SUBST([libprefix])
 AC_SUBST([DSO_LDFLAGS])
 AC_SUBST([SOREV])
 AC_SUBST([PIC_CFLAGS])
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 04:03:59 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 13:03:59 +0200
Subject: [PATCH 14/14] Remove leftovers from the vsnprintf check in
	malloc_vsnprintf
In-Reply-To: <1334833439-5736-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>
	<1334833439-5736-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334833439-5736-3-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Commit 4eeb52f removed vsnprintf validation, but left a now unused va_copy.
It so happens that MSVC doesn't support va_copy.
---
 src/util.c |    4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/util.c b/src/util.c
index 2f1c8f0..e31644d 100644
--- a/src/util.c
+++ b/src/util.c
@@ -286,7 +286,6 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	int ret;
 	size_t i;
 	const char *f;
-	va_list tap;
 
 #define	APPEND_C(c) do {						\
 	if (i < size)							\
@@ -357,9 +356,6 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	}								\
 } while (0)
 
-	if (config_debug)
-		va_copy(tap, ap);
-
 	i = 0;
 	f = format;
 	while (true) {
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 04:03:58 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 13:03:58 +0200
Subject: [PATCH 13/14] Fixup definition of the tls_callback for win32
In-Reply-To: <1334833439-5736-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>
	<1334833439-5736-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334833439-5736-2-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 src/tsd.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/tsd.c b/src/tsd.c
index 417f958..3dee355 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -90,6 +90,6 @@ _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 }
 
 JEMALLOC_ATTR(section(".CRT$XLY")) JEMALLOC_ATTR(used)
-static const BOOL WINAPI (*tls_callback)(HINSTANCE hinstDLL, DWORD fdwReason,
+static const BOOL (WINAPI *tls_callback)(HINSTANCE hinstDLL, DWORD fdwReason,
 	LPVOID lpvReserved) = _tls_callback;
 #endif
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 04:19:08 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 13:19:08 +0200
Subject: [PATCH 12/14] Rename LIB to LIBPREFIX, and set it to nothing on
	mingw
In-Reply-To: <1334833439-5736-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>
	<1334833439-5736-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <20120419111908.GA6031@glandium.org>

On Thu, Apr 19, 2012 at 01:03:57PM +0200, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> ---
>  Makefile.in  |    4 ++--
>  configure.ac |    5 +++--
>  2 files changed, 5 insertions(+), 4 deletions(-)

Forgot to mention this is required because MSVC uses the LIB environment
variable.

Mike


From mh+jemalloc at glandium.org  Thu Apr 19 04:35:35 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 13:35:35 +0200
Subject: [PATCH 15/15] Fix intmax_t configure error message
In-Reply-To: <1334833439-5736-3-git-send-email-mh+jemalloc@glandium.org>
References: <1334833439-5736-3-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334835335-8299-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 configure.ac |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 5bdddfa..396b5ef 100644
--- a/configure.ac
+++ b/configure.ac
@@ -164,7 +164,7 @@ elif test "x${ac_cv_sizeof_intmax_t}" = "x8" ; then
 elif test "x${ac_cv_sizeof_intmax_t}" = "x4" ; then
   LG_SIZEOF_INTMAX_T=2
 else
-  AC_MSG_ERROR([Unsupported intmax_t size: ${ac_cv_sizeof_long}])
+  AC_MSG_ERROR([Unsupported intmax_t size: ${ac_cv_sizeof_intmax_t}])
 fi
 AC_DEFINE_UNQUOTED([LG_SIZEOF_INTMAX_T], [$LG_SIZEOF_INTMAX_T])
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 09:28:06 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 18:28:06 +0200
Subject: [PATCH 19/19] Remove variable length arrays and declarations within
	code
In-Reply-To: <1334852886-28716-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334835335-8299-1-git-send-email-mh+jemalloc@glandium.org>
	<1334852886-28716-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334852886-28716-4-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

MSVC doesn't support C99, and building as C++ to be able to use them is
dangerous, as C++ and C99 are incompatible.
---
 include/jemalloc/internal/prof.h |    3 ++-
 src/arena.c                      |   17 ++++++++++-------
 src/chunk_mmap.c                 |    5 +++--
 src/ctl.c                        |    6 ++++--
 src/stats.c                      |   12 ++++++++----
 src/tsd.c                        |    2 +-
 test/bitmap.c                    |   12 ++++++++----
 7 files changed, 36 insertions(+), 21 deletions(-)

diff --git a/include/jemalloc/internal/prof.h b/include/jemalloc/internal/prof.h
index a4c563c..ee82d1c 100644
--- a/include/jemalloc/internal/prof.h
+++ b/include/jemalloc/internal/prof.h
@@ -501,8 +501,9 @@ prof_free(const void *ptr, size_t size)
 	cassert(config_prof);
 
 	if ((uintptr_t)ctx > (uintptr_t)1) {
+		prof_thr_cnt_t *tcnt;
 		assert(size == isalloc(ptr, true));
-		prof_thr_cnt_t *tcnt = prof_lookup(ctx->bt);
+		tcnt = prof_lookup(ctx->bt);
 
 		if (tcnt != NULL) {
 			tcnt->epoch++;
diff --git a/src/arena.c b/src/arena.c
index cbd92e2..6988f4b 100644
--- a/src/arena.c
+++ b/src/arena.c
@@ -642,12 +642,13 @@ arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk)
 			else {
 				arena_run_t *run = (arena_run_t *)((uintptr_t)
 				    chunk + (uintptr_t)(pageind << LG_PAGE));
+				size_t binind;
+				arena_bin_info_t *bin_info;
 
 				assert((mapelm->bits >> LG_PAGE) == 0);
-				size_t binind = arena_bin_index(arena,
+				binind = arena_bin_index(arena,
 				    run->bin);
-				arena_bin_info_t *bin_info =
-				    &arena_bin_info[binind];
+				bin_info = &arena_bin_info[binind];
 				pageind += bin_info->run_size >> LG_PAGE;
 			}
 		}
@@ -1056,11 +1057,12 @@ arena_bin_runs_first(arena_bin_t *bin)
 	if (mapelm != NULL) {
 		arena_chunk_t *chunk;
 		size_t pageind;
+		arena_run_t *run;
 
 		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mapelm);
 		pageind = ((((uintptr_t)mapelm - (uintptr_t)chunk->map) /
 		    sizeof(arena_chunk_map_t))) + map_bias;
-		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
+		run = (arena_run_t *)((uintptr_t)chunk +
 		    (uintptr_t)((pageind - (mapelm->bits >> LG_PAGE)) <<
 		    LG_PAGE));
 		return (run);
@@ -1629,17 +1631,18 @@ void
 arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
     arena_chunk_map_t *mapelm)
 {
-	size_t pageind;
+	size_t pageind, binind;
 	arena_run_t *run;
 	arena_bin_t *bin;
+	arena_bin_info_t *bin_info;
 	size_t size;
 
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
 	    (mapelm->bits >> LG_PAGE)) << LG_PAGE));
 	bin = run->bin;
-	size_t binind = arena_bin_index(arena, bin);
-	arena_bin_info_t *bin_info = &arena_bin_info[binind];
+	binind = arena_bin_index(arena, bin);
+	bin_info = &arena_bin_info[binind];
 	if (config_fill || config_stats)
 		size = bin_info->reg_size;
 
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index ae411e0..ea83f69 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -96,13 +96,14 @@ pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size)
 {
 
 	void *ret = (void *)((uintptr_t)addr + leadsize);
-#ifndef _WIN32
+#ifdef _WIN32
+	void *new_addr;
+#else
 	size_t trailsize;
 #endif
 
 	assert(alloc_size >= leadsize + size);
 #ifdef _WIN32
-	void *new_addr;
 	pages_unmap(addr, alloc_size);
 	new_addr = pages_map(ret, size);
 	if (new_addr == ret)
diff --git a/src/ctl.c b/src/ctl.c
index b7ea669..20d39bf 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -514,7 +514,7 @@ static void
 ctl_refresh(void)
 {
 	unsigned i;
-	arena_t *tarenas[narenas];
+	arena_t **tarenas = malloc(sizeof(arena_t *) * narenas);
 
 	if (config_stats) {
 		malloc_mutex_lock(&chunks_mtx);
@@ -553,6 +553,7 @@ ctl_refresh(void)
 		if (initialized)
 			ctl_arena_refresh(tarenas[i], i);
 	}
+	free(tarenas);
 
 	if (config_stats) {
 		ctl_stats.allocated = ctl_stats.arenas[narenas].allocated_small
@@ -1227,7 +1228,7 @@ arenas_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 		ret = EFAULT;
 		goto label_return;
 	} else {
-		arena_t *tarenas[narenas];
+		arena_t **tarenas = malloc(sizeof(arena_t *) * narenas);
 
 		malloc_mutex_lock(&arenas_lock);
 		memcpy(tarenas, arenas, sizeof(arena_t *) * narenas);
@@ -1244,6 +1245,7 @@ arenas_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 			if (tarenas[arena] != NULL)
 				arena_purge_all(tarenas[arena]);
 		}
+		free(tarenas);
 	}
 
 	ret = 0;
diff --git a/src/stats.c b/src/stats.c
index 08f7098..ed9d890 100644
--- a/src/stats.c
+++ b/src/stats.c
@@ -498,17 +498,19 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				bool *initialized;
 				size_t isz;
 				unsigned i, ninitialized;
 
-				isz = sizeof(initialized);
+				isz = sizeof(bool) * narenas;
+				initialized = malloc(isz);
 				xmallctl("arenas.initialized", initialized,
 				    &isz, NULL, 0);
 				for (i = ninitialized = 0; i < narenas; i++) {
 					if (initialized[i])
 						ninitialized++;
 				}
+				free(initialized);
 
 				if (ninitialized > 1 || unmerged == false) {
 					/* Print merged arena stats. */
@@ -527,11 +529,12 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				bool *initialized;
 				size_t isz;
 				unsigned i;
 
-				isz = sizeof(initialized);
+				isz = sizeof(bool) * narenas;
+				initialized = malloc(isz);
 				xmallctl("arenas.initialized", initialized,
 				    &isz, NULL, 0);
 
@@ -544,6 +547,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 						    cbopaque, i, bins, large);
 					}
 				}
+				free(initialized);
 			}
 		}
 	}
diff --git a/src/tsd.c b/src/tsd.c
index 3dee355..cf26fd7 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -35,7 +35,7 @@ malloc_tsd_no_cleanup(void *arg)
 void
 _malloc_thread_cleanup(void)
 {
-	bool pending[ncleanups], again;
+	bool pending[MALLOC_TSD_CLEANUPS_MAX], again;
 	unsigned i;
 
 	for (i = 0; i < ncleanups; i++)
diff --git a/test/bitmap.c b/test/bitmap.c
index ff50ecb..e5941fd 100644
--- a/test/bitmap.c
+++ b/test/bitmap.c
@@ -30,12 +30,13 @@ test_bitmap_init(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				assert(bitmap_get(bitmap, &binfo, j) == false);
 
+			free(bitmap);
 		}
 	}
 }
@@ -50,12 +51,13 @@ test_bitmap_set(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -70,7 +72,7 @@ test_bitmap_unset(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
@@ -81,6 +83,7 @@ test_bitmap_unset(void)
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -95,7 +98,7 @@ test_bitmap_sfu(void)
 		bitmap_info_init(&binfo, i);
 		{
 			ssize_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			/* Iteratively set bits starting at the beginning. */
@@ -125,6 +128,7 @@ test_bitmap_sfu(void)
 			}
 			assert(bitmap_sfu(bitmap, &binfo) == i - 1);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 09:28:03 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 18:28:03 +0200
Subject: [PATCH 16/19] Remove #includes in tests
In-Reply-To: <1334835335-8299-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334835335-8299-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334852886-28716-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Since we're now including jemalloc_internal.h, all the required headers
are already pulled. This will avoid having to fiddle with headers that can
or can't be used with MSVC. Also, now that we use malloc_printf, we can use
util.h's definition of assert instead of assert.h's.
---
 test/aligned_alloc.c         |    7 -------
 test/allocated.c             |    8 --------
 test/allocm.c                |    4 ----
 test/bitmap.c                |    6 ------
 test/mremap.c                |    6 ------
 test/posix_memalign.c        |    7 -------
 test/rallocm.c               |    6 ------
 test/thread_arena.c          |    5 -----
 test/thread_tcache_enabled.c |    6 ------
 9 files changed, 55 deletions(-)

diff --git a/test/aligned_alloc.c b/test/aligned_alloc.c
index 81b8f93..81caa0a 100644
--- a/test/aligned_alloc.c
+++ b/test/aligned_alloc.c
@@ -1,10 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/allocated.c b/test/allocated.c
index 3f889f4..b29f2bc 100644
--- a/test/allocated.c
+++ b/test/allocated.c
@@ -1,11 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <assert.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/allocm.c b/test/allocm.c
index c6bc6f8..80be673 100644
--- a/test/allocm.c
+++ b/test/allocm.c
@@ -1,7 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/bitmap.c b/test/bitmap.c
index ee9b1ec..ff50ecb 100644
--- a/test/bitmap.c
+++ b/test/bitmap.c
@@ -1,12 +1,6 @@
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
-/*
- * Avoid using the assert() from jemalloc_internal.h, since it requires
- * internal libjemalloc functionality.
- * */
-#include <assert.h>
-
 #if (LG_BITMAP_MAXBITS > 12)
 #  define MAXBITS	4500
 #else
diff --git a/test/mremap.c b/test/mremap.c
index 84c0349..47efa7c 100644
--- a/test/mremap.c
+++ b/test/mremap.c
@@ -1,9 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/posix_memalign.c b/test/posix_memalign.c
index e1302df..2185bcf 100644
--- a/test/posix_memalign.c
+++ b/test/posix_memalign.c
@@ -1,10 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/rallocm.c b/test/rallocm.c
index f2a4770..c5dedf4 100644
--- a/test/rallocm.c
+++ b/test/rallocm.c
@@ -1,9 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <assert.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/thread_arena.c b/test/thread_arena.c
index 9835428..2020d99 100644
--- a/test/thread_arena.c
+++ b/test/thread_arena.c
@@ -1,8 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/thread_tcache_enabled.c b/test/thread_tcache_enabled.c
index e1cba43..150a224 100644
--- a/test/thread_tcache_enabled.c
+++ b/test/thread_tcache_enabled.c
@@ -1,9 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <assert.h>
-#include <errno.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 09:28:04 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 18:28:04 +0200
Subject: [PATCH 17/19] Remove unused #includes
In-Reply-To: <1334852886-28716-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334835335-8299-1-git-send-email-mh+jemalloc@glandium.org>
	<1334852886-28716-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334852886-28716-2-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 include/jemalloc/internal/jemalloc_internal.h.in |    2 --
 1 file changed, 2 deletions(-)

diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index 2439797..27240d7 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -12,7 +12,6 @@
 #include <sys/uio.h>
 #include <pthread.h>
 #endif
-#include <sys/time.h>
 #include <sys/types.h>
 
 #include <errno.h>
@@ -20,7 +19,6 @@
 #ifndef SIZE_T_MAX
 #  define SIZE_T_MAX	SIZE_MAX
 #endif
-#include <sched.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdio.h>
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 09:28:05 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 18:28:05 +0200
Subject: [PATCH 18/19] Avoid using a union for ctl_node_s
In-Reply-To: <1334852886-28716-1-git-send-email-mh+jemalloc@glandium.org>
References: <1334835335-8299-1-git-send-email-mh+jemalloc@glandium.org>
	<1334852886-28716-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334852886-28716-3-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

MSVC doesn't support C99, and as such doesn't support designated
initialization of structs and unions. As there is never a mix of
indexed and named nodes, it is pretty straightforward to use a
different type for each.
---
 include/jemalloc/internal/ctl.h |   27 ++++---
 src/ctl.c                       |  164 +++++++++++++++++++++++----------------
 2 files changed, 110 insertions(+), 81 deletions(-)

diff --git a/include/jemalloc/internal/ctl.h b/include/jemalloc/internal/ctl.h
index a48d09f..c06b9af 100644
--- a/include/jemalloc/internal/ctl.h
+++ b/include/jemalloc/internal/ctl.h
@@ -2,6 +2,8 @@
 #ifdef JEMALLOC_H_TYPES
 
 typedef struct ctl_node_s ctl_node_t;
+typedef struct ctl_named_node_s ctl_named_node_t;
+typedef struct ctl_indexed_node_s ctl_indexed_node_t;
 typedef struct ctl_arena_stats_s ctl_arena_stats_t;
 typedef struct ctl_stats_s ctl_stats_t;
 
@@ -11,22 +13,23 @@ typedef struct ctl_stats_s ctl_stats_t;
 
 struct ctl_node_s {
 	bool			named;
-	union {
-		struct {
-			const char	*name;
-			/* If (nchildren == 0), this is a terminal node. */
-			unsigned	nchildren;
-			const	ctl_node_t *children;
-		} named;
-		struct {
-			const ctl_node_t *(*index)(const size_t *, size_t,
-			    size_t);
-		} indexed;
-	} u;
+};
+
+struct ctl_named_node_s {
+	struct ctl_node_s	node;
+	const char	*name;
+	/* If (nchildren == 0), this is a terminal node. */
+	unsigned	nchildren;
+	const	ctl_node_t *children;
 	int	(*ctl)(const size_t *, size_t, void *, size_t *, void *,
 	    size_t);
 };
 
+struct ctl_indexed_node_s {
+	struct ctl_node_s	node;
+	const ctl_named_node_t *(*index)(const size_t *, size_t, size_t);
+};
+
 struct ctl_arena_stats_s {
 	bool			initialized;
 	unsigned		nthreads;
diff --git a/src/ctl.c b/src/ctl.c
index 0c1c8f8..b7ea669 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -15,6 +15,28 @@ static uint64_t		ctl_epoch;
 static ctl_stats_t	ctl_stats;
 
 /******************************************************************************/
+/* Helpers for named and indexed nodes. */
+
+static inline const ctl_named_node_t *
+ctl_named_node(const ctl_node_t *node)
+{
+	return (node->named) ? (const ctl_named_node_t *)node : NULL;
+}
+
+static inline const ctl_named_node_t *
+ctl_named_children(const ctl_named_node_t *node, int index)
+{
+	const ctl_named_node_t *children = ctl_named_node(node->children);
+	return children ? &children[index] : NULL;
+}
+
+static inline const ctl_indexed_node_t *
+ctl_indexed_node(const ctl_node_t *node)
+{
+	return (node->named) ? (const ctl_indexed_node_t *)node : NULL;
+}
+
+/******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
 #define	CTL_PROTO(n)							\
@@ -22,7 +44,7 @@ static int	n##_ctl(const size_t *mib, size_t miblen, void *oldp,	\
     size_t *oldlenp, void *newp, size_t newlen);
 
 #define	INDEX_PROTO(n)							\
-const ctl_node_t	*n##_index(const size_t *mib, size_t miblen,	\
+const ctl_named_node_t	*n##_index(const size_t *mib, size_t miblen,	\
     size_t i);
 
 static bool	ctl_arena_init(ctl_arena_stats_t *astats);
@@ -149,22 +171,23 @@ CTL_PROTO(stats_mapped)
 /* Maximum tree depth. */
 #define	CTL_MAX_DEPTH	6
 
-#define	NAME(n)	true,	{.named = {n
-#define	CHILD(c) sizeof(c##_node) / sizeof(ctl_node_t),	c##_node}},	NULL
-#define	CTL(c)	0,				NULL}},		c##_ctl
+#define	NAME(n)	{true},	n
+#define	CHILD(c) sizeof(c##_node) / sizeof(ctl_node_t),				\
+	(ctl_node_t *)c##_node,	NULL
+#define	CTL(c)	0,				NULL,		c##_ctl
 
 /*
  * Only handles internal indexed nodes, since there are currently no external
  * ones.
  */
-#define	INDEX(i)	false,	{.indexed = {i##_index}},		NULL
+#define	INDEX(i)	{false},	i##_index
 
-static const ctl_node_t	tcache_node[] = {
+static const ctl_named_node_t	tcache_node[] = {
 	{NAME("enabled"),	CTL(thread_tcache_enabled)},
 	{NAME("flush"),		CTL(thread_tcache_flush)}
 };
 
-static const ctl_node_t	thread_node[] = {
+static const ctl_named_node_t	thread_node[] = {
 	{NAME("arena"),		CTL(thread_arena)},
 	{NAME("allocated"),	CTL(thread_allocated)},
 	{NAME("allocatedp"),	CTL(thread_allocatedp)},
@@ -173,7 +196,7 @@ static const ctl_node_t	thread_node[] = {
 	{NAME("tcache"),	CHILD(tcache)}
 };
 
-static const ctl_node_t	config_node[] = {
+static const ctl_named_node_t	config_node[] = {
 	{NAME("debug"),			CTL(config_debug)},
 	{NAME("dss"),			CTL(config_dss)},
 	{NAME("fill"),			CTL(config_fill)},
@@ -190,7 +213,7 @@ static const ctl_node_t	config_node[] = {
 	{NAME("xmalloc"),		CTL(config_xmalloc)}
 };
 
-static const ctl_node_t opt_node[] = {
+static const ctl_named_node_t opt_node[] = {
 	{NAME("abort"),			CTL(opt_abort)},
 	{NAME("lg_chunk"),		CTL(opt_lg_chunk)},
 	{NAME("narenas"),		CTL(opt_narenas)},
@@ -216,31 +239,31 @@ static const ctl_node_t opt_node[] = {
 	{NAME("prof_accum"),		CTL(opt_prof_accum)}
 };
 
-static const ctl_node_t arenas_bin_i_node[] = {
+static const ctl_named_node_t arenas_bin_i_node[] = {
 	{NAME("size"),			CTL(arenas_bin_i_size)},
 	{NAME("nregs"),			CTL(arenas_bin_i_nregs)},
 	{NAME("run_size"),		CTL(arenas_bin_i_run_size)}
 };
-static const ctl_node_t super_arenas_bin_i_node[] = {
+static const ctl_named_node_t super_arenas_bin_i_node[] = {
 	{NAME(""),			CHILD(arenas_bin_i)}
 };
 
-static const ctl_node_t arenas_bin_node[] = {
+static const ctl_indexed_node_t arenas_bin_node[] = {
 	{INDEX(arenas_bin_i)}
 };
 
-static const ctl_node_t arenas_lrun_i_node[] = {
+static const ctl_named_node_t arenas_lrun_i_node[] = {
 	{NAME("size"),			CTL(arenas_lrun_i_size)}
 };
-static const ctl_node_t super_arenas_lrun_i_node[] = {
+static const ctl_named_node_t super_arenas_lrun_i_node[] = {
 	{NAME(""),			CHILD(arenas_lrun_i)}
 };
 
-static const ctl_node_t arenas_lrun_node[] = {
+static const ctl_indexed_node_t arenas_lrun_node[] = {
 	{INDEX(arenas_lrun_i)}
 };
 
-static const ctl_node_t arenas_node[] = {
+static const ctl_named_node_t arenas_node[] = {
 	{NAME("narenas"),		CTL(arenas_narenas)},
 	{NAME("initialized"),		CTL(arenas_initialized)},
 	{NAME("quantum"),		CTL(arenas_quantum)},
@@ -254,39 +277,39 @@ static const ctl_node_t arenas_node[] = {
 	{NAME("purge"),			CTL(arenas_purge)}
 };
 
-static const ctl_node_t	prof_node[] = {
+static const ctl_named_node_t	prof_node[] = {
 	{NAME("active"),	CTL(prof_active)},
 	{NAME("dump"),		CTL(prof_dump)},
 	{NAME("interval"),	CTL(prof_interval)}
 };
 
-static const ctl_node_t stats_chunks_node[] = {
+static const ctl_named_node_t stats_chunks_node[] = {
 	{NAME("current"),		CTL(stats_chunks_current)},
 	{NAME("total"),			CTL(stats_chunks_total)},
 	{NAME("high"),			CTL(stats_chunks_high)}
 };
 
-static const ctl_node_t stats_huge_node[] = {
+static const ctl_named_node_t stats_huge_node[] = {
 	{NAME("allocated"),		CTL(stats_huge_allocated)},
 	{NAME("nmalloc"),		CTL(stats_huge_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_huge_ndalloc)}
 };
 
-static const ctl_node_t stats_arenas_i_small_node[] = {
+static const ctl_named_node_t stats_arenas_i_small_node[] = {
 	{NAME("allocated"),		CTL(stats_arenas_i_small_allocated)},
 	{NAME("nmalloc"),		CTL(stats_arenas_i_small_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_small_ndalloc)},
 	{NAME("nrequests"),		CTL(stats_arenas_i_small_nrequests)}
 };
 
-static const ctl_node_t stats_arenas_i_large_node[] = {
+static const ctl_named_node_t stats_arenas_i_large_node[] = {
 	{NAME("allocated"),		CTL(stats_arenas_i_large_allocated)},
 	{NAME("nmalloc"),		CTL(stats_arenas_i_large_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_large_ndalloc)},
 	{NAME("nrequests"),		CTL(stats_arenas_i_large_nrequests)}
 };
 
-static const ctl_node_t stats_arenas_i_bins_j_node[] = {
+static const ctl_named_node_t stats_arenas_i_bins_j_node[] = {
 	{NAME("allocated"),		CTL(stats_arenas_i_bins_j_allocated)},
 	{NAME("nmalloc"),		CTL(stats_arenas_i_bins_j_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_bins_j_ndalloc)},
@@ -297,29 +320,29 @@ static const ctl_node_t stats_arenas_i_bins_j_node[] = {
 	{NAME("nreruns"),		CTL(stats_arenas_i_bins_j_nreruns)},
 	{NAME("curruns"),		CTL(stats_arenas_i_bins_j_curruns)}
 };
-static const ctl_node_t super_stats_arenas_i_bins_j_node[] = {
+static const ctl_named_node_t super_stats_arenas_i_bins_j_node[] = {
 	{NAME(""),			CHILD(stats_arenas_i_bins_j)}
 };
 
-static const ctl_node_t stats_arenas_i_bins_node[] = {
+static const ctl_indexed_node_t stats_arenas_i_bins_node[] = {
 	{INDEX(stats_arenas_i_bins_j)}
 };
 
-static const ctl_node_t stats_arenas_i_lruns_j_node[] = {
+static const ctl_named_node_t stats_arenas_i_lruns_j_node[] = {
 	{NAME("nmalloc"),		CTL(stats_arenas_i_lruns_j_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_lruns_j_ndalloc)},
 	{NAME("nrequests"),		CTL(stats_arenas_i_lruns_j_nrequests)},
 	{NAME("curruns"),		CTL(stats_arenas_i_lruns_j_curruns)}
 };
-static const ctl_node_t super_stats_arenas_i_lruns_j_node[] = {
+static const ctl_named_node_t super_stats_arenas_i_lruns_j_node[] = {
 	{NAME(""),			CHILD(stats_arenas_i_lruns_j)}
 };
 
-static const ctl_node_t stats_arenas_i_lruns_node[] = {
+static const ctl_indexed_node_t stats_arenas_i_lruns_node[] = {
 	{INDEX(stats_arenas_i_lruns_j)}
 };
 
-static const ctl_node_t stats_arenas_i_node[] = {
+static const ctl_named_node_t stats_arenas_i_node[] = {
 	{NAME("nthreads"),		CTL(stats_arenas_i_nthreads)},
 	{NAME("pactive"),		CTL(stats_arenas_i_pactive)},
 	{NAME("pdirty"),		CTL(stats_arenas_i_pdirty)},
@@ -332,15 +355,15 @@ static const ctl_node_t stats_arenas_i_node[] = {
 	{NAME("bins"),			CHILD(stats_arenas_i_bins)},
 	{NAME("lruns"),		CHILD(stats_arenas_i_lruns)}
 };
-static const ctl_node_t super_stats_arenas_i_node[] = {
+static const ctl_named_node_t super_stats_arenas_i_node[] = {
 	{NAME(""),			CHILD(stats_arenas_i)}
 };
 
-static const ctl_node_t stats_arenas_node[] = {
+static const ctl_indexed_node_t stats_arenas_node[] = {
 	{INDEX(stats_arenas_i)}
 };
 
-static const ctl_node_t stats_node[] = {
+static const ctl_named_node_t stats_node[] = {
 	{NAME("cactive"),		CTL(stats_cactive)},
 	{NAME("allocated"),		CTL(stats_allocated)},
 	{NAME("active"),		CTL(stats_active)},
@@ -350,7 +373,7 @@ static const ctl_node_t stats_node[] = {
 	{NAME("arenas"),		CHILD(stats_arenas)}
 };
 
-static const ctl_node_t	root_node[] = {
+static const ctl_named_node_t	root_node[] = {
 	{NAME("version"),	CTL(version)},
 	{NAME("epoch"),		CTL(epoch)},
 	{NAME("thread"),	CHILD(thread)},
@@ -360,7 +383,7 @@ static const ctl_node_t	root_node[] = {
 	{NAME("prof"),		CHILD(prof)},
 	{NAME("stats"),		CHILD(stats)}
 };
-static const ctl_node_t super_root_node[] = {
+static const ctl_named_node_t super_root_node[] = {
 	{NAME(""),		CHILD(root)}
 };
 
@@ -597,7 +620,7 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 	int ret;
 	const char *elm, *tdot, *dot;
 	size_t elen, i, j;
-	const ctl_node_t *node;
+	const ctl_named_node_t *node;
 
 	elm = name;
 	/* Equivalent to strchrnul(). */
@@ -609,21 +632,21 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 	}
 	node = super_root_node;
 	for (i = 0; i < *depthp; i++) {
-		assert(node->named);
-		assert(node->u.named.nchildren > 0);
-		if (node->u.named.children[0].named) {
-			const ctl_node_t *pnode = node;
+		assert(node);
+		assert(node->nchildren > 0);
+		if (ctl_named_node(node->children)) {
+			const ctl_named_node_t *pnode = node;
 
 			/* Children are named. */
-			for (j = 0; j < node->u.named.nchildren; j++) {
-				const ctl_node_t *child =
-				    &node->u.named.children[j];
-				if (strlen(child->u.named.name) == elen
-				    && strncmp(elm, child->u.named.name,
-				    elen) == 0) {
+			for (j = 0; j < node->nchildren; j++) {
+				const ctl_named_node_t *child =
+				    ctl_named_children(node, j);
+				if (strlen(child->name) == elen &&
+				    strncmp(elm, child->name, elen) == 0) {
 					node = child;
 					if (nodesp != NULL)
-						nodesp[i] = node;
+						nodesp[i] =
+						    (const ctl_node_t *)node;
 					mibp[i] = j;
 					break;
 				}
@@ -634,7 +657,7 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 			}
 		} else {
 			uintmax_t index;
-			const ctl_node_t *inode;
+			const ctl_indexed_node_t *inode;
 
 			/* Children are indexed. */
 			index = malloc_strtoumax(elm, NULL, 10);
@@ -643,16 +666,15 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 				goto label_return;
 			}
 
-			inode = &node->u.named.children[0];
-			node = inode->u.indexed.index(mibp, *depthp,
-			    (size_t)index);
+			inode = ctl_indexed_node(node->children);
+			node = inode->index(mibp, *depthp, (size_t)index);
 			if (node == NULL) {
 				ret = ENOENT;
 				goto label_return;
 			}
 
 			if (nodesp != NULL)
-				nodesp[i] = node;
+				nodesp[i] = (const ctl_node_t *)node;
 			mibp[i] = (size_t)index;
 		}
 
@@ -696,6 +718,7 @@ ctl_byname(const char *name, void *oldp, size_t *oldlenp, void *newp,
 	size_t depth;
 	ctl_node_t const *nodes[CTL_MAX_DEPTH];
 	size_t mib[CTL_MAX_DEPTH];
+	const ctl_named_node_t *node;
 
 	if (ctl_initialized == false && ctl_init()) {
 		ret = EAGAIN;
@@ -707,13 +730,14 @@ ctl_byname(const char *name, void *oldp, size_t *oldlenp, void *newp,
 	if (ret != 0)
 		goto label_return;
 
-	if (nodes[depth-1]->ctl == NULL) {
+	node = ctl_named_node(nodes[depth-1]);
+	if (node && node->ctl) {
+		ret = node->ctl(mib, depth, oldp, oldlenp, newp, newlen);
+	} else {
 		/* The name refers to a partial path through the ctl tree. */
 		ret = ENOENT;
-		goto label_return;
 	}
 
-	ret = nodes[depth-1]->ctl(mib, depth, oldp, oldlenp, newp, newlen);
 label_return:
 	return(ret);
 }
@@ -738,7 +762,7 @@ ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen)
 {
 	int ret;
-	const ctl_node_t *node;
+	const ctl_named_node_t *node;
 	size_t i;
 
 	if (ctl_initialized == false && ctl_init()) {
@@ -749,19 +773,21 @@ ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 	/* Iterate down the tree. */
 	node = super_root_node;
 	for (i = 0; i < miblen; i++) {
-		if (node->u.named.children[0].named) {
+		assert(node);
+		assert(node->nchildren > 0);
+		if (ctl_named_node(node->children)) {
 			/* Children are named. */
-			if (node->u.named.nchildren <= mib[i]) {
+			if (node->nchildren <= mib[i]) {
 				ret = ENOENT;
 				goto label_return;
 			}
-			node = &node->u.named.children[mib[i]];
+			node = ctl_named_children(node, mib[i]);
 		} else {
-			const ctl_node_t *inode;
+			const ctl_indexed_node_t *inode;
 
 			/* Indexed element. */
-			inode = &node->u.named.children[0];
-			node = inode->u.indexed.index(mib, miblen, mib[i]);
+			inode = ctl_indexed_node(node->children);
+			node = inode->index(mib, miblen, mib[i]);
 			if (node == NULL) {
 				ret = ENOENT;
 				goto label_return;
@@ -770,12 +796,12 @@ ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 	}
 
 	/* Call the ctl function. */
-	if (node->ctl == NULL) {
+	if (node && node->ctl) {
+		ret = node->ctl(mib, miblen, oldp, oldlenp, newp, newlen);
+	} else {
 		/* Partial MIB. */
 		ret = ENOENT;
-		goto label_return;
 	}
-	ret = node->ctl(mib, miblen, oldp, oldlenp, newp, newlen);
 
 label_return:
 	return(ret);
@@ -1133,7 +1159,7 @@ CTL_RO_NL_CGEN(config_prof, opt_prof_accum, opt_prof_accum, bool)
 CTL_RO_NL_GEN(arenas_bin_i_size, arena_bin_info[mib[2]].reg_size, size_t)
 CTL_RO_NL_GEN(arenas_bin_i_nregs, arena_bin_info[mib[2]].nregs, uint32_t)
 CTL_RO_NL_GEN(arenas_bin_i_run_size, arena_bin_info[mib[2]].run_size, size_t)
-const ctl_node_t *
+const ctl_named_node_t *
 arenas_bin_i_index(const size_t *mib, size_t miblen, size_t i)
 {
 
@@ -1143,7 +1169,7 @@ arenas_bin_i_index(const size_t *mib, size_t miblen, size_t i)
 }
 
 CTL_RO_NL_GEN(arenas_lrun_i_size, ((mib[2]+1) << LG_PAGE), size_t)
-const ctl_node_t *
+const ctl_named_node_t *
 arenas_lrun_i_index(const size_t *mib, size_t miblen, size_t i)
 {
 
@@ -1326,7 +1352,7 @@ CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nreruns,
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_curruns,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].curruns, size_t)
 
-const ctl_node_t *
+const ctl_named_node_t *
 stats_arenas_i_bins_j_index(const size_t *mib, size_t miblen, size_t j)
 {
 
@@ -1344,7 +1370,7 @@ CTL_RO_CGEN(config_stats, stats_arenas_i_lruns_j_nrequests,
 CTL_RO_CGEN(config_stats, stats_arenas_i_lruns_j_curruns,
     ctl_stats.arenas[mib[2]].lstats[mib[4]].curruns, size_t)
 
-const ctl_node_t *
+const ctl_named_node_t *
 stats_arenas_i_lruns_j_index(const size_t *mib, size_t miblen, size_t j)
 {
 
@@ -1365,10 +1391,10 @@ CTL_RO_CGEN(config_stats, stats_arenas_i_nmadvise,
 CTL_RO_CGEN(config_stats, stats_arenas_i_purged,
     ctl_stats.arenas[mib[2]].astats.purged, uint64_t)
 
-const ctl_node_t *
+const ctl_named_node_t *
 stats_arenas_i_index(const size_t *mib, size_t miblen, size_t i)
 {
-	const ctl_node_t * ret;
+	const ctl_named_node_t * ret;
 
 	malloc_mutex_lock(&ctl_mtx);
 	if (ctl_stats.arenas[i].initialized == false) {
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 09:56:57 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 18:56:57 +0200
Subject: On the use of ffs
Message-ID: <20120419165657.GA29562@glandium.org>

Hi,

Since MSVC doesn't have strings.h or ffs/ffsl, I took a look at the
various uses of ffs/ffsl, and it seems to me all uses of ffs should
actually be ffsl. Any thoughts?

Mike


From mh+jemalloc at glandium.org  Thu Apr 19 10:06:42 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 19:06:42 +0200
Subject: On static library naming
Message-ID: <20120419170642.GA29730@glandium.org>

Hi,

Currently, building jemalloc brings up three libraries:
- libjemalloc.a, static, non-PIC
- libjemalloc_pic.a, static, PIC
- libjemalloc.so, shared, PIC

The world of Windows is kind of different. First, everything is PIC.
Then, to link against a shared library, you have an import library.
So you have:
- library.dll, shared, PIC
- library.lib, import lib
and you can have
- something_else.lib, static library

I have several questions related to this:
- Do we want a static library for Windows?
- If we do, how should it be named? (for example, NSPR uses a _s.lib
  suffix instead of .lib)
- If we do, wouldn't it make sense to kind of uniformize the naming
  across platforms?

Cheers,

Mike


From mh+jemalloc at glandium.org  Thu Apr 19 10:26:06 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Thu, 19 Apr 2012 19:26:06 +0200
Subject: [PATCH 11/11] Add support for Mingw
In-Reply-To: <1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>
References: <20120418162529.GA18610@glandium.org>
	<1334766590-7296-1-git-send-email-mh+jemalloc@glandium.org>
	<1334766590-7296-11-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <20120419172606.GA30307@glandium.org>

On Wed, Apr 18, 2012 at 06:29:50PM +0200, Mike Hommey wrote:
>  int
>  buferror(int errnum, char *buf, size_t buflen)
> +#ifdef _WIN32
> +	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, (LPSTR)buf, buflen, NULL);
> +	return (0);
> +#elif defined(_GNU_SOURCE)
>  	char *b = strerror_r(errno, buf, buflen);

Note that there is an error in buferror: it ignores the errnum argument.
Which is okayish, since it's always called for errno. There are two
ways out here:
- actually using the given argument
- remove that argument

I'd go for the latter... Anyways, there are other errno-related things
I need to change for MSVC, so it's fine to land this patch as-is.

Cheers,

Mike


From jasone at canonware.com  Thu Apr 19 17:32:05 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 19 Apr 2012 17:32:05 -0700
Subject: [PATCH] Simplify TSD without TLS
In-Reply-To: <20120418162529.GA18610@glandium.org>
References: <1334656864-24573-1-git-send-email-mh+jemalloc@glandium.org>
	<20120417100715.GA24797@glandium.org>
	<20120418162529.GA18610@glandium.org>
Message-ID: <7961F582-CE77-45AF-9A1E-67434B805B57@canonware.com>

On Apr 18, 2012, at 9:25 AM, Mike Hommey wrote:
> On Tue, Apr 17, 2012 at 12:07:15PM +0200, Mike Hommey wrote:
>> 
>> It doesn't use a static variable when malloc_tsd_malloc
>> fails, but unconditionally aborts instead. Using a static variable is
>> due to fail with multithreading anyways. The 'initialized' variable is
>> not necessary either, as pthread_key's cleanup function won't be called
>> unless a non-NULL value has been set with pthread_setspecific.
> 
> With a more complete tsd testcase than the one I sent yesterday, I can
> see how the initialized variable is necessary. However, there's a bug,
> because it's not set to false when creating the wrapper, and this makes
> the cleanup function called even when tsd_set was never called.

Nice catch.

> There's also a corner case, with *something_tsd_get() = value. It
> doesn't trigger a cleanup at thread shutdown, and I'm not sure if that's
> a desired effect.

This is intended behavior; something_tsd_set() must be called to trigger cleanup.  pthreads tsd uses NULL/non-NULL to make the decision, but that doesn't quite make sense with this tsd API.

> Arguably, maybe this should be forbidden. Adding
> const to tsd_get() ensures that, but as a matter of fact,
> thread_allocated tsd does this kind of assignment. But it also doesn't
> have a cleanup function, so it's not really a problem. We may want to
> avoid such things from happening in the future, though.

Patch 7/11 (Disallow *_tsd_get() = value assignments) disallows intended functionality.  The thread_allocated code is on the fast path, and I don't want to make it any slower than it already is.

> Please note that patch 6/11 (Add a test for the TSD system) does *not*
> build without --enable-debug because it's such impossible build
> independent parts of jemalloc with optimized builds. You may however
> want to run the test on the freebsd implementation of the TSD system,
> because that's the only one I couldn't test. With patches 8 and 9, the
> --disable-tls implementation passes the test.

Patch 6/11 did indeed expose a bug in the FreeBSD implementation -- the cleanup function wasn't being called at all!  I've been thinking about how to include such tests, and two closely related ideas come to mind.  One is to add a --enable-unit-tests option that causes unit test entry points to be built into libjemalloc.  Then test programs can call those entry points.  I'm not super excited about this though, because it requires special build configuration to run all the tests.  The other option is to build a libjemalloc_test that has these entry points built in, and link all tests against that instead of libjemalloc.  What do you think?  Any other ideas?

> This patch queue closes on Mingw support. Next will be MSVC.


Patch 11/11 (Add support for Mingw) doesn't apply after the various changes I made while applying the rest of your patches (and leaving out 6/11 and 7/11).  Can you please rebase and resend?

Thanks,
Jason

From jasone at canonware.com  Thu Apr 19 17:38:45 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 19 Apr 2012 17:38:45 -0700
Subject: On the use of ffs
In-Reply-To: <20120419165657.GA29562@glandium.org>
References: <20120419165657.GA29562@glandium.org>
Message-ID: <88AC0045-5B63-4744-85A9-33FA8A72096C@canonware.com>

On Apr 19, 2012, at 9:56 AM, Mike Hommey wrote:
> Hi,
> 
> Since MSVC doesn't have strings.h or ffs/ffsl, I took a look at the
> various uses of ffs/ffsl, and it seems to me all uses of ffs should
> actually be ffsl. Any thoughts?

I ran into problems trying to use ffsl() in the ALLOCM_ALIGN() macro, because of Linux's Byzantine _GNU_SOURCE requirements to get its definition.  The other remaining uses of ffs() are correct, though ffsl() would work fine.

Jason

From jasone at canonware.com  Thu Apr 19 17:42:31 2012
From: jasone at canonware.com (Jason Evans)
Date: Thu, 19 Apr 2012 17:42:31 -0700
Subject: On static library naming
In-Reply-To: <20120419170642.GA29730@glandium.org>
References: <20120419170642.GA29730@glandium.org>
Message-ID: <69BCF5A5-37C2-4271-9192-CC3C082A92CF@canonware.com>

On Apr 19, 2012, at 10:06 AM, Mike Hommey wrote:
> Currently, building jemalloc brings up three libraries:
> - libjemalloc.a, static, non-PIC
> - libjemalloc_pic.a, static, PIC
> - libjemalloc.so, shared, PIC
> 
> The world of Windows is kind of different. First, everything is PIC.
> Then, to link against a shared library, you have an import library.
> So you have:
> - library.dll, shared, PIC
> - library.lib, import lib
> and you can have
> - something_else.lib, static library
> 
> I have several questions related to this:
> - Do we want a static library for Windows?
> - If we do, how should it be named? (for example, NSPR uses a _s.lib
>  suffix instead of .lib)
> - If we do, wouldn't it make sense to kind of uniformize the naming
>  across platforms?

I don't know whether a static library would be useful on Windows (replacing malloc on Windows is black magic that I'm not current on), and if so, how to name it.  Whatever you decide, the current naming scheme should remain for the Unix-like systems.

Thanks,
Jason

From mh+jemalloc at glandium.org  Thu Apr 19 23:36:56 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:36:56 +0200
Subject: [PATCH] Simplify TSD without TLS
In-Reply-To: <7961F582-CE77-45AF-9A1E-67434B805B57@canonware.com>
References: <1334656864-24573-1-git-send-email-mh+jemalloc@glandium.org>
	<20120417100715.GA24797@glandium.org>
	<20120418162529.GA18610@glandium.org>
	<7961F582-CE77-45AF-9A1E-67434B805B57@canonware.com>
Message-ID: <20120420063656.GA2098@glandium.org>

On Thu, Apr 19, 2012 at 05:32:05PM -0700, Jason Evans wrote:
> Patch 6/11 did indeed expose a bug in the FreeBSD implementation --
> the cleanup function wasn't being called at all!  I've been thinking
> about how to include such tests, and two closely related ideas come to
> mind.  One is to add a --enable-unit-tests option that causes unit
> test entry points to be built into libjemalloc.  Then test programs
> can call those entry points.  I'm not super excited about this though,
> because it requires special build configuration to run all the tests.
> The other option is to build a libjemalloc_test that has these entry
> points built in, and link all tests against that instead of
> libjemalloc.  What do you think?  Any other ideas?

We could go with a variant of the latter: build a shared library off the
tests + libjemalloc_pic.a. And then have a program linked against that
library and calls all tests. That would also allow to get rid of the
Makefile glue to run the tests.

> > This patch queue closes on Mingw support. Next will be MSVC.
> 
> Patch 11/11 (Add support for Mingw) doesn't apply after the various
> changes I made while applying the rest of your patches (and leaving
> out 6/11 and 7/11).  Can you please rebase and resend?

I'll rebase and squash a few things. For good measure, I'll resend the
remaining patch queue.

Mike


From mh+jemalloc at glandium.org  Thu Apr 19 23:38:37 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:38:37 +0200
Subject: [PATCH 1/7] Add support for Mingw
In-Reply-To: <20120420063656.GA2098@glandium.org>
References: <20120420063656.GA2098@glandium.org>
Message-ID: <1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 Makefile.in                                      |   10 ++-
 configure.ac                                     |   60 +++++++++----
 include/jemalloc/internal/jemalloc_internal.h.in |   11 ++-
 include/jemalloc/internal/mutex.h                |   16 +++-
 include/jemalloc/internal/tsd.h                  |  101 ++++++++++++++++++++++
 src/chunk_mmap.c                                 |   92 ++++++++++++++++----
 src/jemalloc.c                                   |   23 ++++-
 src/mutex.c                                      |   16 +++-
 src/tsd.c                                        |   26 +++++-
 src/util.c                                       |    5 +-
 test/jemalloc_test.h.in                          |   24 +++++
 test/rallocm.c                                   |    6 ++
 12 files changed, 337 insertions(+), 53 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 8a34928..b9917da 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -32,7 +32,7 @@ SO := @so@
 O := @o@
 A := @a@
 EXE := @exe@
-LIB := @lib@
+LIBPREFIX := @libprefix@
 REV := @rev@
 install_suffix := @install_suffix@
 ABI := @abi@
@@ -51,12 +51,16 @@ SOREV = @SOREV@
 PIC_CFLAGS = @PIC_CFLAGS@
 
 ifeq (macho, $(ABI))
-TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH=$(objroot)lib
+TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH="$(objroot)lib"
+else
+ifeq (pecoff, $(ABI))
+TEST_LIBRARY_PATH := PATH="$(PATH):$(objroot)lib"
 else
 TEST_LIBRARY_PATH :=
 endif
+endif
 
-LIBJEMALLOC := $(LIB)jemalloc$(install_suffix)
+LIBJEMALLOC := $(LIBPREFIX)jemalloc$(install_suffix)
 
 # Lists of files.
 BINS := $(srcroot)bin/pprof $(objroot)bin/jemalloc.sh
diff --git a/configure.ac b/configure.ac
index 0ed0494..5bdddfa 100644
--- a/configure.ac
+++ b/configure.ac
@@ -198,7 +198,7 @@ so="so"
 o="o"
 a="a"
 exe=
-lib="lib"
+libprefix="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
 SOREV='$(SO).$(REV)'
@@ -273,6 +273,19 @@ case "${host}" in
 	fi
 	abi="xcoff"
 	;;
+  *-*-mingw*)
+	abi="pecoff"
+	force_tls="0"
+	RPATH=""
+	so="dll"
+	DSO_LDFLAGS="-shared"
+	o="obj"
+	a="lib"
+	libprefix=""
+	exe=".exe"
+	SOREV='$(SO)'
+	PIC_CFLAGS=""
+	;;
   *)
 	AC_MSG_RESULT([Unsupported operating system: ${host}])
 	abi="elf"
@@ -285,7 +298,7 @@ AC_SUBST([so])
 AC_SUBST([o])
 AC_SUBST([a])
 AC_SUBST([exe])
-AC_SUBST([lib])
+AC_SUBST([libprefix])
 AC_SUBST([DSO_LDFLAGS])
 AC_SUBST([SOREV])
 AC_SUBST([PIC_CFLAGS])
@@ -817,23 +830,36 @@ AC_SUBST([enable_xmalloc])
 AC_CACHE_CHECK([STATIC_PAGE_SHIFT],
                [je_cv_static_page_shift],
                AC_RUN_IFELSE([AC_LANG_PROGRAM(
-[[#include <stdio.h>
+[[
+#ifdef _WIN32
+#include <windows.h>
+#else
 #include <unistd.h>
 #include <strings.h>
+#endif
+#include <stdio.h>
 ]],
 [[
     long result;
     FILE *f;
 
+#ifdef _WIN32
+    SYSTEM_INFO si;
+    GetSystemInfo(&si);
+    result = si.dwPageSize;
+#else
     result = sysconf(_SC_PAGESIZE);
+#endif
     if (result == -1) {
 	return 1;
     }
+    result = ffsl(result) - 1;
+
     f = fopen("conftest.out", "w");
     if (f == NULL) {
 	return 1;
     }
-    fprintf(f, "%u\n", ffs((int)result) - 1);
+    fprintf(f, "%u\n", result);
     fclose(f);
 
     return 0;
@@ -871,12 +897,14 @@ AC_SUBST([jemalloc_version_gid])
 dnl ============================================================================
 dnl Configure pthreads.
 
-AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])
-dnl Some systems may embed pthreads functionality in libc; check for libpthread
-dnl first, but try libc too before failing.
-AC_CHECK_LIB([pthread], [pthread_create], [LIBS="$LIBS -lpthread"],
-             [AC_SEARCH_LIBS([pthread_create], , ,
-                             AC_MSG_ERROR([libpthread is missing]))])
+if test "x$abi" != "xpecoff" ; then
+  AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])
+  dnl Some systems may embed pthreads functionality in libc; check for libpthread
+  dnl first, but try libc too before failing.
+  AC_CHECK_LIB([pthread], [pthread_create], [LIBS="$LIBS -lpthread"],
+               [AC_SEARCH_LIBS([pthread_create], , ,
+                               AC_MSG_ERROR([libpthread is missing]))])
+fi
 
 CPPFLAGS="$CPPFLAGS -D_REENTRANT"
 
@@ -921,11 +949,13 @@ if test "x$enable_lazy_lock" = "x0" -a "x${force_lazy_lock}" = "x1" ; then
   enable_lazy_lock="1"
 fi
 if test "x$enable_lazy_lock" = "x1" ; then
-  AC_CHECK_HEADERS([dlfcn.h], , [AC_MSG_ERROR([dlfcn.h is missing])])
-  AC_CHECK_FUNC([dlsym], [],
-    [AC_CHECK_LIB([dl], [dlsym], [LIBS="$LIBS -ldl"],
-                  [AC_MSG_ERROR([libdl is missing])])
-    ])
+  if test "x$abi" != "xpecoff" ; then
+    AC_CHECK_HEADERS([dlfcn.h], , [AC_MSG_ERROR([dlfcn.h is missing])])
+    AC_CHECK_FUNC([dlsym], [],
+      [AC_CHECK_LIB([dl], [dlsym], [LIBS="$LIBS -ldl"],
+                    [AC_MSG_ERROR([libdl is missing])])
+      ])
+  fi
   AC_DEFINE([JEMALLOC_LAZY_LOCK], [ ])
 fi
 AC_SUBST([enable_lazy_lock])
diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index b61abe8..b5021ca 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -1,21 +1,25 @@
 #ifndef JEMALLOC_INTERNAL_H
 #define JEMALLOC_INTERNAL_H
-#include <sys/mman.h>
 #include <sys/param.h>
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <sys/mman.h>
 #include <sys/syscall.h>
 #if !defined(SYS_write) && defined(__NR_write)
 #define	SYS_write __NR_write
 #endif
+#include <sys/uio.h>
+#include <pthread.h>
+#endif
 #include <sys/time.h>
 #include <sys/types.h>
-#include <sys/uio.h>
 
 #include <errno.h>
 #include <limits.h>
 #ifndef SIZE_T_MAX
 #  define SIZE_T_MAX	SIZE_MAX
 #endif
-#include <pthread.h>
 #include <sched.h>
 #include <stdarg.h>
 #include <stdbool.h>
@@ -32,7 +36,6 @@
 #include <ctype.h>
 #include <unistd.h>
 #include <fcntl.h>
-#include <pthread.h>
 #include <math.h>
 
 #define	JEMALLOC_NO_DEMANGLE
diff --git a/include/jemalloc/internal/mutex.h b/include/jemalloc/internal/mutex.h
index c46feee..3940280 100644
--- a/include/jemalloc/internal/mutex.h
+++ b/include/jemalloc/internal/mutex.h
@@ -3,7 +3,9 @@
 
 typedef struct malloc_mutex_s malloc_mutex_t;
 
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+#define	MALLOC_MUTEX_INITIALIZER
+#elif (defined(JEMALLOC_OSSPIN))
 #define	MALLOC_MUTEX_INITIALIZER {0}
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 #define	MALLOC_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER, NULL}
@@ -23,7 +25,9 @@ typedef struct malloc_mutex_s malloc_mutex_t;
 #ifdef JEMALLOC_H_STRUCTS
 
 struct malloc_mutex_s {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+	CRITICAL_SECTION	lock;
+#elif (defined(JEMALLOC_OSSPIN))
 	OSSpinLock		lock;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	pthread_mutex_t		lock;
@@ -64,7 +68,9 @@ malloc_mutex_lock(malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+		EnterCriticalSection(&mutex->lock);
+#elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockLock(&mutex->lock);
 #else
 		pthread_mutex_lock(&mutex->lock);
@@ -77,7 +83,9 @@ malloc_mutex_unlock(malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+		LeaveCriticalSection(&mutex->lock);
+#elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockUnlock(&mutex->lock);
 #else
 		pthread_mutex_unlock(&mutex->lock);
diff --git a/include/jemalloc/internal/tsd.h b/include/jemalloc/internal/tsd.h
index 5e904cb..bc57f26 100644
--- a/include/jemalloc/internal/tsd.h
+++ b/include/jemalloc/internal/tsd.h
@@ -74,6 +74,10 @@ extern bool		a_name##_booted;
 extern __thread a_type	a_name##_tls;					\
 extern pthread_key_t	a_name##_tsd;					\
 extern bool		a_name##_booted;
+#elif (defined(_WIN32))
+#define malloc_tsd_externs(a_name, a_type)				\
+extern DWORD		a_name##_tsd;					\
+extern bool		a_name##_booted;
 #else
 #define	malloc_tsd_externs(a_name, a_type)				\
 extern pthread_key_t	a_name##_tsd;					\
@@ -94,6 +98,10 @@ a_attr __thread a_type JEMALLOC_TLS_MODEL				\
     a_name##_tls = a_initializer;					\
 a_attr pthread_key_t	a_name##_tsd;					\
 a_attr bool		a_name##_booted = false;
+#elif (defined(_WIN32))
+#define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
+a_attr DWORD		a_name##_tsd;					\
+a_attr bool		a_name##_booted = false;
 #else
 #define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
 a_attr pthread_key_t	a_name##_tsd;					\
@@ -182,6 +190,99 @@ a_name##_tsd_set(a_type *val)						\
 		}							\
 	}								\
 }
+#elif (defined(_WIN32))
+#define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
+    a_cleanup)								\
+/* Data structure. */							\
+typedef struct {							\
+	bool	initialized;						\
+	a_type	val;							\
+} a_name##_tsd_wrapper_t;						\
+/* Initialization/cleanup. */						\
+a_attr bool								\
+a_name##_tsd_cleanup_wrapper(void)					\
+{									\
+	a_name##_tsd_wrapper_t *wrapper;				\
+									\
+	wrapper = (a_name##_tsd_wrapper_t *) TlsGetValue(a_name##_tsd);	\
+	if (wrapper == NULL)						\
+		return false;						\
+	if (a_cleanup != malloc_tsd_no_cleanup &&			\
+	    wrapper->initialized) {					\
+		a_type val = wrapper->val;				\
+		a_type tsd_static_data = a_initializer;			\
+		wrapper->initialized = false;				\
+		wrapper->val = tsd_static_data;				\
+		a_cleanup(&val);					\
+		if (wrapper->initialized) {				\
+			/* Trigger another cleanup round. */		\
+			return (true);					\
+		}							\
+	}								\
+	malloc_tsd_dalloc(wrapper);					\
+	return (false);							\
+}									\
+a_attr bool								\
+a_name##_tsd_boot(void)							\
+{									\
+									\
+	a_name##_tsd = TlsAlloc();					\
+	if (a_name##_tsd == TLS_OUT_OF_INDEXES)				\
+		return (true);						\
+	if (a_cleanup != malloc_tsd_no_cleanup) {			\
+		malloc_tsd_cleanup_register(				\
+		    &a_name##_tsd_cleanup_wrapper);			\
+	}								\
+	a_name##_booted = true;						\
+	return (false);							\
+}									\
+/* Get/set. */								\
+a_attr a_name##_tsd_wrapper_t *						\
+a_name##_tsd_get_wrapper(void)						\
+{									\
+	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)	\
+	    TlsGetValue(a_name##_tsd);					\
+									\
+	if (wrapper == NULL) {						\
+		wrapper = (a_name##_tsd_wrapper_t *)			\
+		    malloc_tsd_malloc(sizeof(a_name##_tsd_wrapper_t));	\
+		if (wrapper == NULL) {					\
+			malloc_write("<jemalloc>: Error allocating"	\
+			    " TSD for "#a_name"\n");			\
+			abort();					\
+		} else {						\
+			static a_type tsd_static_data = a_initializer;	\
+			wrapper->initialized = false;			\
+			wrapper->val = tsd_static_data;			\
+		}							\
+		if (!TlsSetValue(a_name##_tsd, (void *)wrapper)) {	\
+			malloc_write("<jemalloc>: Error setting"	\
+			    " TSD for "#a_name"\n");			\
+			abort();					\
+		}							\
+	}								\
+	return (wrapper);						\
+}									\
+a_attr a_type *								\
+a_name##_tsd_get(void)							\
+{									\
+	a_name##_tsd_wrapper_t *wrapper;				\
+									\
+	assert(a_name##_booted);					\
+	wrapper = a_name##_tsd_get_wrapper();				\
+	return (&wrapper->val);						\
+}									\
+a_attr void								\
+a_name##_tsd_set(a_type *val)						\
+{									\
+	a_name##_tsd_wrapper_t *wrapper;				\
+									\
+	assert(a_name##_booted);					\
+	wrapper = a_name##_tsd_get_wrapper();				\
+	wrapper->val = *(val);						\
+	if (a_cleanup != malloc_tsd_no_cleanup)				\
+		wrapper->initialized = true;				\
+}
 #else
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index 9dea831..fe618bd 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -27,6 +27,14 @@ pages_map(void *addr, size_t size)
 {
 	void *ret;
 
+#ifdef _WIN32
+	/*
+	 * If it can't allocate at the given address when one is given,
+	 * VirtualAlloc fails and returns NULL.
+	 */
+	ret = VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE,
+	                   PAGE_READWRITE);
+#else
 	/*
 	 * We don't use MAP_FIXED here, because it can cause the *replacement*
 	 * of existing mappings, and we only want to create new mappings.
@@ -52,7 +60,7 @@ pages_map(void *addr, size_t size)
 		}
 		ret = NULL;
 	}
-
+#endif
 	assert(ret == NULL || (addr == NULL && ret != addr)
 	    || (addr != NULL && ret == addr));
 	return (ret);
@@ -62,20 +70,63 @@ static void
 pages_unmap(void *addr, size_t size)
 {
 
-	if (munmap(addr, size) == -1) {
+#ifdef _WIN32
+	if (VirtualFree(addr, 0, MEM_RELEASE) == 0)
+#else
+	if (munmap(addr, size) == -1)
+#endif
+	{
 		char buf[BUFERROR_BUF];
 
 		buferror(errno, buf, sizeof(buf));
-		malloc_printf("<jemalloc>: Error in munmap(): %s\n", buf);
+		malloc_printf("<jemalloc>: Error in "
+#ifdef _WIN32
+		              "VirtualFree"
+#else
+		              "munmap"
+#endif
+		              "(): %s\n", buf);
 		if (opt_abort)
 			abort();
 	}
 }
 
+static void *
+pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size)
+{
+
+	void *ret = (void *)((uintptr_t)addr + leadsize);
+#ifndef _WIN32
+	size_t trailsize;
+#endif
+
+	assert(alloc_size >= leadsize + size);
+#ifdef _WIN32
+	void *new_addr;
+	pages_unmap(addr, alloc_size);
+	new_addr = pages_map(ret, size);
+	if (new_addr == ret)
+		return ret;
+	if (new_addr)
+		pages_unmap(new_addr, size);
+	return NULL;
+#else
+	trailsize = alloc_size - leadsize - size;
+	if (leadsize != 0)
+		pages_unmap(addr, leadsize);
+	if (trailsize != 0)
+		pages_unmap((void *)((uintptr_t)ret + size), trailsize);
+	return ret;
+#endif
+}
+
 void
 pages_purge(void *addr, size_t length)
 {
 
+#ifdef _WIN32
+	VirtualAlloc(addr, length, MEM_RESET, PAGE_READWRITE);
+#else
 #ifdef JEMALLOC_PURGE_MADVISE_DONTNEED
 #  define JEMALLOC_MADV_PURGE MADV_DONTNEED
 #elif defined(JEMALLOC_PURGE_MADVISE_FREE)
@@ -84,33 +135,32 @@ pages_purge(void *addr, size_t length)
 #  error "No method defined for purging unused dirty pages."
 #endif
 	madvise(addr, length, JEMALLOC_MADV_PURGE);
+#endif
 }
 
+
 static void *
 chunk_alloc_mmap_slow(size_t size, size_t alignment, bool unaligned)
 {
 	void *ret, *pages;
-	size_t alloc_size, leadsize, trailsize;
+	size_t alloc_size, leadsize;
 
 	alloc_size = size + alignment - PAGE;
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size)
 		return (NULL);
-	pages = pages_map(NULL, alloc_size);
-	if (pages == NULL)
-		return (NULL);
-	leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment) -
-	    (uintptr_t)pages;
-	assert(alloc_size >= leadsize + size);
-	trailsize = alloc_size - leadsize - size;
-	ret = (void *)((uintptr_t)pages + leadsize);
-	if (leadsize != 0) {
-		/* Note that mmap() returned an unaligned mapping. */
-		unaligned = true;
-		pages_unmap(pages, leadsize);
-	}
-	if (trailsize != 0)
-		pages_unmap((void *)((uintptr_t)ret + size), trailsize);
+	do {
+		pages = pages_map(NULL, alloc_size);
+		if (pages == NULL)
+			return (NULL);
+		leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment) -
+		    (uintptr_t)pages;
+		ret = pages_trim(pages, alloc_size, leadsize, size);
+		if (leadsize != 0) {
+			/* Note that mmap() returned an unaligned mapping. */
+			unaligned = true;
+		}
+	} while (ret == NULL);
 
 	/*
 	 * If mmap() returned an aligned mapping, reset mmap_unaligned so that
@@ -169,6 +219,9 @@ chunk_alloc_mmap(size_t size, size_t alignment)
 		if (offset != 0) {
 			bool mu = true;
 			mmap_unaligned_tsd_set(&mu);
+#ifdef _WIN32
+			ret = chunk_alloc_mmap_slow(size, alignment, true);
+#else
 			/* Try to extend chunk boundary. */
 			if (pages_map((void *)((uintptr_t)ret + size),
 			    chunksize - offset) == NULL) {
@@ -185,6 +238,7 @@ chunk_alloc_mmap(size_t size, size_t alignment)
 				ret = (void *)((uintptr_t)ret + (chunksize -
 				    offset));
 			}
+#endif
 		}
 	} else
 		ret = chunk_alloc_mmap_slow(size, alignment, false);
diff --git a/src/jemalloc.c b/src/jemalloc.c
index 6669c11..9f917cd 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -52,7 +52,17 @@ static bool			malloc_initializer = NO_INITIALIZER;
 #endif
 
 /* Used to avoid initialization races. */
+#ifdef _WIN32
+static malloc_mutex_t	init_lock;
+
+JEMALLOC_ATTR(constructor)
+static void
+init_init_lock() {
+	malloc_mutex_init(&init_lock);
+}
+#else
 static malloc_mutex_t	init_lock = MALLOC_MUTEX_INITIALIZER;
+#endif
 
 typedef struct {
 	void	*p;	/* Input pointer (as in realloc(p, s)). */
@@ -229,11 +239,17 @@ malloc_ncpus(void)
 	unsigned ret;
 	long result;
 
+#ifdef _WIN32
+	SYSTEM_INFO si;
+	GetSystemInfo(&si);
+	result = si.dwNumberOfProcessors;
+#else
 	result = sysconf(_SC_NPROCESSORS_ONLN);
 	if (result == -1) {
 		/* Error. */
 		ret = 1;
 	}
+#endif
 	ret = (unsigned)result;
 
 	return (ret);
@@ -369,6 +385,7 @@ malloc_conf_init(void)
 			}
 			break;
 		case 1: {
+#ifndef _WIN32
 			int linklen;
 			const char *linkname =
 #ifdef JEMALLOC_PREFIX
@@ -386,7 +403,9 @@ malloc_conf_init(void)
 				 */
 				buf[linklen] = '\0';
 				opts = buf;
-			} else {
+			} else
+#endif
+			{
 				/* No configuration specified. */
 				buf[0] = '\0';
 				opts = buf;
@@ -609,7 +628,7 @@ malloc_init_hard(void)
 
 	malloc_conf_init();
 
-#if (!defined(JEMALLOC_MUTEX_INIT_CB) && !defined(JEMALLOC_ZONE))
+#if (!defined(JEMALLOC_MUTEX_INIT_CB) && !defined(JEMALLOC_ZONE) && !defined(_WIN32))
 	/* Register fork handlers. */
 	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
 	    jemalloc_postfork_child) != 0) {
diff --git a/src/mutex.c b/src/mutex.c
index 4b8ce57..159d82a 100644
--- a/src/mutex.c
+++ b/src/mutex.c
@@ -1,10 +1,14 @@
 #define	JEMALLOC_MUTEX_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
-#ifdef JEMALLOC_LAZY_LOCK
+#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
 #include <dlfcn.h>
 #endif
 
+#ifndef _CRT_SPINCOUNT
+#define _CRT_SPINCOUNT 4000
+#endif
+
 /******************************************************************************/
 /* Data. */
 
@@ -16,7 +20,7 @@ static bool		postpone_init = true;
 static malloc_mutex_t	*postponed_mutexes = NULL;
 #endif
 
-#ifdef JEMALLOC_LAZY_LOCK
+#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
 static void	pthread_create_once(void);
 #endif
 
@@ -26,7 +30,7 @@ static void	pthread_create_once(void);
  * process goes multi-threaded.
  */
 
-#ifdef JEMALLOC_LAZY_LOCK
+#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)
 static int (*pthread_create_fptr)(pthread_t *__restrict, const pthread_attr_t *,
     void *(*)(void *), void *__restrict);
 
@@ -68,7 +72,11 @@ int	_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,
 bool
 malloc_mutex_init(malloc_mutex_t *mutex)
 {
-#ifdef JEMALLOC_OSSPIN
+#ifdef _WIN32
+	if (!InitializeCriticalSectionAndSpinCount(&mutex->lock,
+	    _CRT_SPINCOUNT))
+		return (true);
+#elif (defined(JEMALLOC_OSSPIN))
 	mutex->lock = 0;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	if (postpone_init) {
diff --git a/src/tsd.c b/src/tsd.c
index 281a2e9..20f6430 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -31,7 +31,7 @@ malloc_tsd_no_cleanup(void *arg)
 	not_reached();
 }
 
-#ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
+#if defined(JEMALLOC_MALLOC_THREAD_CLEANUP) || defined(_WIN32)
 JEMALLOC_ATTR(visibility("default"))
 void
 _malloc_thread_cleanup(void)
@@ -70,3 +70,27 @@ malloc_tsd_boot(void)
 
 	ncleanups = 0;
 }
+
+#ifdef _WIN32
+static BOOL WINAPI
+_tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+{
+	switch (fdwReason) {
+#ifdef JEMALLOC_LAZY_LOCK
+	case DLL_THREAD_ATTACH:
+		isthreaded = true;
+		break;
+#endif
+	case DLL_THREAD_DETACH:
+		_malloc_thread_cleanup();
+		break;
+	default:
+		break;
+	}
+	return true;
+}
+
+JEMALLOC_ATTR(section(".CRT$XLY")) JEMALLOC_ATTR(used)
+static const BOOL (WINAPI *tls_callback)(HINSTANCE hinstDLL, DWORD fdwReason,
+	LPVOID lpvReserved) = _tls_callback;
+#endif
diff --git a/src/util.c b/src/util.c
index 99ae26d..2f1c8f0 100644
--- a/src/util.c
+++ b/src/util.c
@@ -67,7 +67,10 @@ void	(*je_malloc_message)(void *, const char *s)
 int
 buferror(int errnum, char *buf, size_t buflen)
 {
-#ifdef _GNU_SOURCE
+#ifdef _WIN32
+	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, (LPSTR)buf, buflen, NULL);
+	return (0);
+#elif defined(_GNU_SOURCE)
 	char *b = strerror_r(errno, buf, buflen);
 	if (b != buf) {
 		strncpy(buf, b, buflen);
diff --git a/test/jemalloc_test.h.in b/test/jemalloc_test.h.in
index 8833a03..e38b48e 100644
--- a/test/jemalloc_test.h.in
+++ b/test/jemalloc_test.h.in
@@ -7,6 +7,29 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /* Abstraction layer for threading in tests */
+#ifdef _WIN32
+#include <windows.h>
+
+typedef HANDLE je_thread_t;
+
+void
+je_thread_create(je_thread_t *thread, void *(*proc)(void *), void *arg)
+{
+	LPTHREAD_START_ROUTINE routine = (LPTHREAD_START_ROUTINE)proc;
+	*thread = CreateThread(NULL, 0, routine, arg, 0, NULL);
+	if (*thread == NULL) {
+		malloc_printf("Error in CreateThread()\n");
+		exit(1);
+	}
+}
+
+void
+je_thread_join(je_thread_t thread, void **ret)
+{
+	WaitForSingleObject(thread, INFINITE);
+}
+
+#else
 #include <pthread.h>
 
 typedef pthread_t je_thread_t;
@@ -27,3 +50,4 @@ je_thread_join(je_thread_t thread, void **ret)
 
 	pthread_join(thread, ret);
 }
+#endif
diff --git a/test/rallocm.c b/test/rallocm.c
index 18db5ee..f2a4770 100644
--- a/test/rallocm.c
+++ b/test/rallocm.c
@@ -19,9 +19,15 @@ main(void)
 
 	/* Get page size. */
 	{
+#ifdef _WIN32
+		SYSTEM_INFO si;
+		GetSystemInfo(&si);
+		pagesize = (size_t)si.dwPageSize;
+#else
 		long result = sysconf(_SC_PAGESIZE);
 		assert(result != -1);
 		pagesize = (size_t)result;
+#endif
 	}
 
 	r = allocm(&p, &sz, 42, 0);
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 23:38:39 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:38:39 +0200
Subject: [PATCH 3/7] Fix intmax_t configure error message
In-Reply-To: <1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334903923-4973-3-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 configure.ac |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 5bdddfa..396b5ef 100644
--- a/configure.ac
+++ b/configure.ac
@@ -164,7 +164,7 @@ elif test "x${ac_cv_sizeof_intmax_t}" = "x8" ; then
 elif test "x${ac_cv_sizeof_intmax_t}" = "x4" ; then
   LG_SIZEOF_INTMAX_T=2
 else
-  AC_MSG_ERROR([Unsupported intmax_t size: ${ac_cv_sizeof_long}])
+  AC_MSG_ERROR([Unsupported intmax_t size: ${ac_cv_sizeof_intmax_t}])
 fi
 AC_DEFINE_UNQUOTED([LG_SIZEOF_INTMAX_T], [$LG_SIZEOF_INTMAX_T])
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 23:38:43 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:38:43 +0200
Subject: [PATCH 7/7] Remove variable length arrays and declarations within code
In-Reply-To: <1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334903923-4973-7-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

MSVC doesn't support C99, and building as C++ to be able to use them is
dangerous, as C++ and C99 are incompatible.
---
 include/jemalloc/internal/prof.h |    3 ++-
 src/arena.c                      |   17 ++++++++++-------
 src/chunk_mmap.c                 |    5 +++--
 src/ctl.c                        |    6 ++++--
 src/stats.c                      |   12 ++++++++----
 src/tsd.c                        |    2 +-
 test/bitmap.c                    |   12 ++++++++----
 7 files changed, 36 insertions(+), 21 deletions(-)

diff --git a/include/jemalloc/internal/prof.h b/include/jemalloc/internal/prof.h
index a4c563c..ee82d1c 100644
--- a/include/jemalloc/internal/prof.h
+++ b/include/jemalloc/internal/prof.h
@@ -501,8 +501,9 @@ prof_free(const void *ptr, size_t size)
 	cassert(config_prof);
 
 	if ((uintptr_t)ctx > (uintptr_t)1) {
+		prof_thr_cnt_t *tcnt;
 		assert(size == isalloc(ptr, true));
-		prof_thr_cnt_t *tcnt = prof_lookup(ctx->bt);
+		tcnt = prof_lookup(ctx->bt);
 
 		if (tcnt != NULL) {
 			tcnt->epoch++;
diff --git a/src/arena.c b/src/arena.c
index 6f28abe..877119a 100644
--- a/src/arena.c
+++ b/src/arena.c
@@ -642,12 +642,13 @@ arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk)
 			else {
 				arena_run_t *run = (arena_run_t *)((uintptr_t)
 				    chunk + (uintptr_t)(pageind << LG_PAGE));
+				size_t binind;
+				arena_bin_info_t *bin_info;
 
 				assert((mapelm->bits >> LG_PAGE) == 0);
-				size_t binind = arena_bin_index(arena,
+				binind = arena_bin_index(arena,
 				    run->bin);
-				arena_bin_info_t *bin_info =
-				    &arena_bin_info[binind];
+				bin_info = &arena_bin_info[binind];
 				pageind += bin_info->run_size >> LG_PAGE;
 			}
 		}
@@ -1056,11 +1057,12 @@ arena_bin_runs_first(arena_bin_t *bin)
 	if (mapelm != NULL) {
 		arena_chunk_t *chunk;
 		size_t pageind;
+		arena_run_t *run;
 
 		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mapelm);
 		pageind = ((((uintptr_t)mapelm - (uintptr_t)chunk->map) /
 		    sizeof(arena_chunk_map_t))) + map_bias;
-		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
+		run = (arena_run_t *)((uintptr_t)chunk +
 		    (uintptr_t)((pageind - (mapelm->bits >> LG_PAGE)) <<
 		    LG_PAGE));
 		return (run);
@@ -1591,17 +1593,18 @@ void
 arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
     arena_chunk_map_t *mapelm)
 {
-	size_t pageind;
+	size_t pageind, binind;
 	arena_run_t *run;
 	arena_bin_t *bin;
+	arena_bin_info_t *bin_info;
 	size_t size;
 
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
 	    (mapelm->bits >> LG_PAGE)) << LG_PAGE));
 	bin = run->bin;
-	size_t binind = arena_bin_index(arena, bin);
-	arena_bin_info_t *bin_info = &arena_bin_info[binind];
+	binind = arena_bin_index(arena, bin);
+	bin_info = &arena_bin_info[binind];
 	if (config_fill || config_stats)
 		size = bin_info->reg_size;
 
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index fe618bd..84b83d2 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -96,13 +96,14 @@ pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size)
 {
 
 	void *ret = (void *)((uintptr_t)addr + leadsize);
-#ifndef _WIN32
+#ifdef _WIN32
+	void *new_addr;
+#else
 	size_t trailsize;
 #endif
 
 	assert(alloc_size >= leadsize + size);
 #ifdef _WIN32
-	void *new_addr;
 	pages_unmap(addr, alloc_size);
 	new_addr = pages_map(ret, size);
 	if (new_addr == ret)
diff --git a/src/ctl.c b/src/ctl.c
index 60f4ae0..426351c 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -514,7 +514,7 @@ static void
 ctl_refresh(void)
 {
 	unsigned i;
-	arena_t *tarenas[narenas];
+	arena_t **tarenas = malloc(sizeof(arena_t *) * narenas);
 
 	if (config_stats) {
 		malloc_mutex_lock(&chunks_mtx);
@@ -553,6 +553,7 @@ ctl_refresh(void)
 		if (initialized)
 			ctl_arena_refresh(tarenas[i], i);
 	}
+	free(tarenas);
 
 	if (config_stats) {
 		ctl_stats.allocated = ctl_stats.arenas[narenas].allocated_small
@@ -1227,7 +1228,7 @@ arenas_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 		ret = EFAULT;
 		goto label_return;
 	} else {
-		arena_t *tarenas[narenas];
+		arena_t **tarenas = malloc(sizeof(arena_t *) * narenas);
 
 		malloc_mutex_lock(&arenas_lock);
 		memcpy(tarenas, arenas, sizeof(arena_t *) * narenas);
@@ -1244,6 +1245,7 @@ arenas_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 			if (tarenas[arena] != NULL)
 				arena_purge_all(tarenas[arena]);
 		}
+		free(tarenas);
 	}
 
 	ret = 0;
diff --git a/src/stats.c b/src/stats.c
index 08f7098..ed9d890 100644
--- a/src/stats.c
+++ b/src/stats.c
@@ -498,17 +498,19 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				bool *initialized;
 				size_t isz;
 				unsigned i, ninitialized;
 
-				isz = sizeof(initialized);
+				isz = sizeof(bool) * narenas;
+				initialized = malloc(isz);
 				xmallctl("arenas.initialized", initialized,
 				    &isz, NULL, 0);
 				for (i = ninitialized = 0; i < narenas; i++) {
 					if (initialized[i])
 						ninitialized++;
 				}
+				free(initialized);
 
 				if (ninitialized > 1 || unmerged == false) {
 					/* Print merged arena stats. */
@@ -527,11 +529,12 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				bool *initialized;
 				size_t isz;
 				unsigned i;
 
-				isz = sizeof(initialized);
+				isz = sizeof(bool) * narenas;
+				initialized = malloc(isz);
 				xmallctl("arenas.initialized", initialized,
 				    &isz, NULL, 0);
 
@@ -544,6 +547,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 						    cbopaque, i, bins, large);
 					}
 				}
+				free(initialized);
 			}
 		}
 	}
diff --git a/src/tsd.c b/src/tsd.c
index 20f6430..452baa1 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -36,7 +36,7 @@ JEMALLOC_ATTR(visibility("default"))
 void
 _malloc_thread_cleanup(void)
 {
-	bool pending[ncleanups], again;
+	bool pending[MALLOC_TSD_CLEANUPS_MAX], again;
 	unsigned i;
 
 	for (i = 0; i < ncleanups; i++)
diff --git a/test/bitmap.c b/test/bitmap.c
index ff50ecb..e5941fd 100644
--- a/test/bitmap.c
+++ b/test/bitmap.c
@@ -30,12 +30,13 @@ test_bitmap_init(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				assert(bitmap_get(bitmap, &binfo, j) == false);
 
+			free(bitmap);
 		}
 	}
 }
@@ -50,12 +51,13 @@ test_bitmap_set(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -70,7 +72,7 @@ test_bitmap_unset(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
@@ -81,6 +83,7 @@ test_bitmap_unset(void)
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -95,7 +98,7 @@ test_bitmap_sfu(void)
 		bitmap_info_init(&binfo, i);
 		{
 			ssize_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) * bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			/* Iteratively set bits starting at the beginning. */
@@ -125,6 +128,7 @@ test_bitmap_sfu(void)
 			}
 			assert(bitmap_sfu(bitmap, &binfo) == i - 1);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 23:38:41 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:38:41 +0200
Subject: [PATCH 5/7] Remove unused #includes
In-Reply-To: <1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334903923-4973-5-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

---
 include/jemalloc/internal/jemalloc_internal.h.in |    2 --
 1 file changed, 2 deletions(-)

diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index b5021ca..6e48804 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -12,7 +12,6 @@
 #include <sys/uio.h>
 #include <pthread.h>
 #endif
-#include <sys/time.h>
 #include <sys/types.h>
 
 #include <errno.h>
@@ -20,7 +19,6 @@
 #ifndef SIZE_T_MAX
 #  define SIZE_T_MAX	SIZE_MAX
 #endif
-#include <sched.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdio.h>
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 23:38:40 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:38:40 +0200
Subject: [PATCH 4/7] Remove #includes in tests
In-Reply-To: <1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334903923-4973-4-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Since we're now including jemalloc_internal.h, all the required headers
are already pulled. This will avoid having to fiddle with headers that can
or can't be used with MSVC. Also, now that we use malloc_printf, we can use
util.h's definition of assert instead of assert.h's.
---
 test/aligned_alloc.c         |    7 -------
 test/allocated.c             |    8 --------
 test/allocm.c                |    4 ----
 test/bitmap.c                |    6 ------
 test/mremap.c                |    6 ------
 test/posix_memalign.c        |    7 -------
 test/rallocm.c               |    6 ------
 test/thread_arena.c          |    5 -----
 test/thread_tcache_enabled.c |    6 ------
 9 files changed, 55 deletions(-)

diff --git a/test/aligned_alloc.c b/test/aligned_alloc.c
index 81b8f93..81caa0a 100644
--- a/test/aligned_alloc.c
+++ b/test/aligned_alloc.c
@@ -1,10 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/allocated.c b/test/allocated.c
index 00039ed..9884905 100644
--- a/test/allocated.c
+++ b/test/allocated.c
@@ -1,11 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stdbool.h>
-#include <assert.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/allocm.c b/test/allocm.c
index c6bc6f8..80be673 100644
--- a/test/allocm.c
+++ b/test/allocm.c
@@ -1,7 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/bitmap.c b/test/bitmap.c
index ee9b1ec..ff50ecb 100644
--- a/test/bitmap.c
+++ b/test/bitmap.c
@@ -1,12 +1,6 @@
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
-/*
- * Avoid using the assert() from jemalloc_internal.h, since it requires
- * internal libjemalloc functionality.
- * */
-#include <assert.h>
-
 #if (LG_BITMAP_MAXBITS > 12)
 #  define MAXBITS	4500
 #else
diff --git a/test/mremap.c b/test/mremap.c
index 84c0349..47efa7c 100644
--- a/test/mremap.c
+++ b/test/mremap.c
@@ -1,9 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/posix_memalign.c b/test/posix_memalign.c
index e1302df..2185bcf 100644
--- a/test/posix_memalign.c
+++ b/test/posix_memalign.c
@@ -1,10 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/rallocm.c b/test/rallocm.c
index f2a4770..c5dedf4 100644
--- a/test/rallocm.c
+++ b/test/rallocm.c
@@ -1,9 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <assert.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/thread_arena.c b/test/thread_arena.c
index 9835428..2020d99 100644
--- a/test/thread_arena.c
+++ b/test/thread_arena.c
@@ -1,8 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
diff --git a/test/thread_tcache_enabled.c b/test/thread_tcache_enabled.c
index 9f76584..2061b7b 100644
--- a/test/thread_tcache_enabled.c
+++ b/test/thread_tcache_enabled.c
@@ -1,9 +1,3 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdbool.h>
-#include <assert.h>
-#include <errno.h>
-
 #define	JEMALLOC_MANGLE
 #include "jemalloc_test.h"
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 23:38:38 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:38:38 +0200
Subject: [PATCH 2/7] Remove leftovers from the vsnprintf check in
	malloc_vsnprintf
In-Reply-To: <1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334903923-4973-2-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Commit 4eeb52f removed vsnprintf validation, but left a now unused va_copy.
It so happens that MSVC doesn't support va_copy.
---
 src/util.c |    4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/util.c b/src/util.c
index 2f1c8f0..e31644d 100644
--- a/src/util.c
+++ b/src/util.c
@@ -286,7 +286,6 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	int ret;
 	size_t i;
 	const char *f;
-	va_list tap;
 
 #define	APPEND_C(c) do {						\
 	if (i < size)							\
@@ -357,9 +356,6 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 	}								\
 } while (0)
 
-	if (config_debug)
-		va_copy(tap, ap);
-
 	i = 0;
 	f = format;
 	while (true) {
-- 
1.7.10



From mh+jemalloc at glandium.org  Thu Apr 19 23:38:42 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Fri, 20 Apr 2012 08:38:42 +0200
Subject: [PATCH 6/7] Avoid using a union for ctl_node_s
In-Reply-To: <1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1334903923-4973-6-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

MSVC doesn't support C99, and as such doesn't support designated
initialization of structs and unions. As there is never a mix of
indexed and named nodes, it is pretty straightforward to use a
different type for each.
---
 include/jemalloc/internal/ctl.h |   27 ++++---
 src/ctl.c                       |  164 +++++++++++++++++++++++----------------
 2 files changed, 110 insertions(+), 81 deletions(-)

diff --git a/include/jemalloc/internal/ctl.h b/include/jemalloc/internal/ctl.h
index a48d09f..c06b9af 100644
--- a/include/jemalloc/internal/ctl.h
+++ b/include/jemalloc/internal/ctl.h
@@ -2,6 +2,8 @@
 #ifdef JEMALLOC_H_TYPES
 
 typedef struct ctl_node_s ctl_node_t;
+typedef struct ctl_named_node_s ctl_named_node_t;
+typedef struct ctl_indexed_node_s ctl_indexed_node_t;
 typedef struct ctl_arena_stats_s ctl_arena_stats_t;
 typedef struct ctl_stats_s ctl_stats_t;
 
@@ -11,22 +13,23 @@ typedef struct ctl_stats_s ctl_stats_t;
 
 struct ctl_node_s {
 	bool			named;
-	union {
-		struct {
-			const char	*name;
-			/* If (nchildren == 0), this is a terminal node. */
-			unsigned	nchildren;
-			const	ctl_node_t *children;
-		} named;
-		struct {
-			const ctl_node_t *(*index)(const size_t *, size_t,
-			    size_t);
-		} indexed;
-	} u;
+};
+
+struct ctl_named_node_s {
+	struct ctl_node_s	node;
+	const char	*name;
+	/* If (nchildren == 0), this is a terminal node. */
+	unsigned	nchildren;
+	const	ctl_node_t *children;
 	int	(*ctl)(const size_t *, size_t, void *, size_t *, void *,
 	    size_t);
 };
 
+struct ctl_indexed_node_s {
+	struct ctl_node_s	node;
+	const ctl_named_node_t *(*index)(const size_t *, size_t, size_t);
+};
+
 struct ctl_arena_stats_s {
 	bool			initialized;
 	unsigned		nthreads;
diff --git a/src/ctl.c b/src/ctl.c
index 98ea3d1..60f4ae0 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -15,6 +15,28 @@ static uint64_t		ctl_epoch;
 static ctl_stats_t	ctl_stats;
 
 /******************************************************************************/
+/* Helpers for named and indexed nodes. */
+
+static inline const ctl_named_node_t *
+ctl_named_node(const ctl_node_t *node)
+{
+	return (node->named) ? (const ctl_named_node_t *)node : NULL;
+}
+
+static inline const ctl_named_node_t *
+ctl_named_children(const ctl_named_node_t *node, int index)
+{
+	const ctl_named_node_t *children = ctl_named_node(node->children);
+	return children ? &children[index] : NULL;
+}
+
+static inline const ctl_indexed_node_t *
+ctl_indexed_node(const ctl_node_t *node)
+{
+	return (node->named) ? (const ctl_indexed_node_t *)node : NULL;
+}
+
+/******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
 #define	CTL_PROTO(n)							\
@@ -22,7 +44,7 @@ static int	n##_ctl(const size_t *mib, size_t miblen, void *oldp,	\
     size_t *oldlenp, void *newp, size_t newlen);
 
 #define	INDEX_PROTO(n)							\
-const ctl_node_t	*n##_index(const size_t *mib, size_t miblen,	\
+const ctl_named_node_t	*n##_index(const size_t *mib, size_t miblen,	\
     size_t i);
 
 static bool	ctl_arena_init(ctl_arena_stats_t *astats);
@@ -149,22 +171,23 @@ CTL_PROTO(stats_mapped)
 /* Maximum tree depth. */
 #define	CTL_MAX_DEPTH	6
 
-#define	NAME(n)	true,	{.named = {n
-#define	CHILD(c) sizeof(c##_node) / sizeof(ctl_node_t),	c##_node}},	NULL
-#define	CTL(c)	0,				NULL}},		c##_ctl
+#define	NAME(n)	{true},	n
+#define	CHILD(c) sizeof(c##_node) / sizeof(ctl_node_t),				\
+	(ctl_node_t *)c##_node,	NULL
+#define	CTL(c)	0,				NULL,		c##_ctl
 
 /*
  * Only handles internal indexed nodes, since there are currently no external
  * ones.
  */
-#define	INDEX(i)	false,	{.indexed = {i##_index}},		NULL
+#define	INDEX(i)	{false},	i##_index
 
-static const ctl_node_t	tcache_node[] = {
+static const ctl_named_node_t	tcache_node[] = {
 	{NAME("enabled"),	CTL(thread_tcache_enabled)},
 	{NAME("flush"),		CTL(thread_tcache_flush)}
 };
 
-static const ctl_node_t	thread_node[] = {
+static const ctl_named_node_t	thread_node[] = {
 	{NAME("arena"),		CTL(thread_arena)},
 	{NAME("allocated"),	CTL(thread_allocated)},
 	{NAME("allocatedp"),	CTL(thread_allocatedp)},
@@ -173,7 +196,7 @@ static const ctl_node_t	thread_node[] = {
 	{NAME("tcache"),	CHILD(tcache)}
 };
 
-static const ctl_node_t	config_node[] = {
+static const ctl_named_node_t	config_node[] = {
 	{NAME("debug"),			CTL(config_debug)},
 	{NAME("dss"),			CTL(config_dss)},
 	{NAME("fill"),			CTL(config_fill)},
@@ -190,7 +213,7 @@ static const ctl_node_t	config_node[] = {
 	{NAME("xmalloc"),		CTL(config_xmalloc)}
 };
 
-static const ctl_node_t opt_node[] = {
+static const ctl_named_node_t opt_node[] = {
 	{NAME("abort"),			CTL(opt_abort)},
 	{NAME("lg_chunk"),		CTL(opt_lg_chunk)},
 	{NAME("narenas"),		CTL(opt_narenas)},
@@ -216,31 +239,31 @@ static const ctl_node_t opt_node[] = {
 	{NAME("prof_accum"),		CTL(opt_prof_accum)}
 };
 
-static const ctl_node_t arenas_bin_i_node[] = {
+static const ctl_named_node_t arenas_bin_i_node[] = {
 	{NAME("size"),			CTL(arenas_bin_i_size)},
 	{NAME("nregs"),			CTL(arenas_bin_i_nregs)},
 	{NAME("run_size"),		CTL(arenas_bin_i_run_size)}
 };
-static const ctl_node_t super_arenas_bin_i_node[] = {
+static const ctl_named_node_t super_arenas_bin_i_node[] = {
 	{NAME(""),			CHILD(arenas_bin_i)}
 };
 
-static const ctl_node_t arenas_bin_node[] = {
+static const ctl_indexed_node_t arenas_bin_node[] = {
 	{INDEX(arenas_bin_i)}
 };
 
-static const ctl_node_t arenas_lrun_i_node[] = {
+static const ctl_named_node_t arenas_lrun_i_node[] = {
 	{NAME("size"),			CTL(arenas_lrun_i_size)}
 };
-static const ctl_node_t super_arenas_lrun_i_node[] = {
+static const ctl_named_node_t super_arenas_lrun_i_node[] = {
 	{NAME(""),			CHILD(arenas_lrun_i)}
 };
 
-static const ctl_node_t arenas_lrun_node[] = {
+static const ctl_indexed_node_t arenas_lrun_node[] = {
 	{INDEX(arenas_lrun_i)}
 };
 
-static const ctl_node_t arenas_node[] = {
+static const ctl_named_node_t arenas_node[] = {
 	{NAME("narenas"),		CTL(arenas_narenas)},
 	{NAME("initialized"),		CTL(arenas_initialized)},
 	{NAME("quantum"),		CTL(arenas_quantum)},
@@ -254,39 +277,39 @@ static const ctl_node_t arenas_node[] = {
 	{NAME("purge"),			CTL(arenas_purge)}
 };
 
-static const ctl_node_t	prof_node[] = {
+static const ctl_named_node_t	prof_node[] = {
 	{NAME("active"),	CTL(prof_active)},
 	{NAME("dump"),		CTL(prof_dump)},
 	{NAME("interval"),	CTL(prof_interval)}
 };
 
-static const ctl_node_t stats_chunks_node[] = {
+static const ctl_named_node_t stats_chunks_node[] = {
 	{NAME("current"),		CTL(stats_chunks_current)},
 	{NAME("total"),			CTL(stats_chunks_total)},
 	{NAME("high"),			CTL(stats_chunks_high)}
 };
 
-static const ctl_node_t stats_huge_node[] = {
+static const ctl_named_node_t stats_huge_node[] = {
 	{NAME("allocated"),		CTL(stats_huge_allocated)},
 	{NAME("nmalloc"),		CTL(stats_huge_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_huge_ndalloc)}
 };
 
-static const ctl_node_t stats_arenas_i_small_node[] = {
+static const ctl_named_node_t stats_arenas_i_small_node[] = {
 	{NAME("allocated"),		CTL(stats_arenas_i_small_allocated)},
 	{NAME("nmalloc"),		CTL(stats_arenas_i_small_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_small_ndalloc)},
 	{NAME("nrequests"),		CTL(stats_arenas_i_small_nrequests)}
 };
 
-static const ctl_node_t stats_arenas_i_large_node[] = {
+static const ctl_named_node_t stats_arenas_i_large_node[] = {
 	{NAME("allocated"),		CTL(stats_arenas_i_large_allocated)},
 	{NAME("nmalloc"),		CTL(stats_arenas_i_large_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_large_ndalloc)},
 	{NAME("nrequests"),		CTL(stats_arenas_i_large_nrequests)}
 };
 
-static const ctl_node_t stats_arenas_i_bins_j_node[] = {
+static const ctl_named_node_t stats_arenas_i_bins_j_node[] = {
 	{NAME("allocated"),		CTL(stats_arenas_i_bins_j_allocated)},
 	{NAME("nmalloc"),		CTL(stats_arenas_i_bins_j_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_bins_j_ndalloc)},
@@ -297,29 +320,29 @@ static const ctl_node_t stats_arenas_i_bins_j_node[] = {
 	{NAME("nreruns"),		CTL(stats_arenas_i_bins_j_nreruns)},
 	{NAME("curruns"),		CTL(stats_arenas_i_bins_j_curruns)}
 };
-static const ctl_node_t super_stats_arenas_i_bins_j_node[] = {
+static const ctl_named_node_t super_stats_arenas_i_bins_j_node[] = {
 	{NAME(""),			CHILD(stats_arenas_i_bins_j)}
 };
 
-static const ctl_node_t stats_arenas_i_bins_node[] = {
+static const ctl_indexed_node_t stats_arenas_i_bins_node[] = {
 	{INDEX(stats_arenas_i_bins_j)}
 };
 
-static const ctl_node_t stats_arenas_i_lruns_j_node[] = {
+static const ctl_named_node_t stats_arenas_i_lruns_j_node[] = {
 	{NAME("nmalloc"),		CTL(stats_arenas_i_lruns_j_nmalloc)},
 	{NAME("ndalloc"),		CTL(stats_arenas_i_lruns_j_ndalloc)},
 	{NAME("nrequests"),		CTL(stats_arenas_i_lruns_j_nrequests)},
 	{NAME("curruns"),		CTL(stats_arenas_i_lruns_j_curruns)}
 };
-static const ctl_node_t super_stats_arenas_i_lruns_j_node[] = {
+static const ctl_named_node_t super_stats_arenas_i_lruns_j_node[] = {
 	{NAME(""),			CHILD(stats_arenas_i_lruns_j)}
 };
 
-static const ctl_node_t stats_arenas_i_lruns_node[] = {
+static const ctl_indexed_node_t stats_arenas_i_lruns_node[] = {
 	{INDEX(stats_arenas_i_lruns_j)}
 };
 
-static const ctl_node_t stats_arenas_i_node[] = {
+static const ctl_named_node_t stats_arenas_i_node[] = {
 	{NAME("nthreads"),		CTL(stats_arenas_i_nthreads)},
 	{NAME("pactive"),		CTL(stats_arenas_i_pactive)},
 	{NAME("pdirty"),		CTL(stats_arenas_i_pdirty)},
@@ -332,15 +355,15 @@ static const ctl_node_t stats_arenas_i_node[] = {
 	{NAME("bins"),			CHILD(stats_arenas_i_bins)},
 	{NAME("lruns"),		CHILD(stats_arenas_i_lruns)}
 };
-static const ctl_node_t super_stats_arenas_i_node[] = {
+static const ctl_named_node_t super_stats_arenas_i_node[] = {
 	{NAME(""),			CHILD(stats_arenas_i)}
 };
 
-static const ctl_node_t stats_arenas_node[] = {
+static const ctl_indexed_node_t stats_arenas_node[] = {
 	{INDEX(stats_arenas_i)}
 };
 
-static const ctl_node_t stats_node[] = {
+static const ctl_named_node_t stats_node[] = {
 	{NAME("cactive"),		CTL(stats_cactive)},
 	{NAME("allocated"),		CTL(stats_allocated)},
 	{NAME("active"),		CTL(stats_active)},
@@ -350,7 +373,7 @@ static const ctl_node_t stats_node[] = {
 	{NAME("arenas"),		CHILD(stats_arenas)}
 };
 
-static const ctl_node_t	root_node[] = {
+static const ctl_named_node_t	root_node[] = {
 	{NAME("version"),	CTL(version)},
 	{NAME("epoch"),		CTL(epoch)},
 	{NAME("thread"),	CHILD(thread)},
@@ -360,7 +383,7 @@ static const ctl_node_t	root_node[] = {
 	{NAME("prof"),		CHILD(prof)},
 	{NAME("stats"),		CHILD(stats)}
 };
-static const ctl_node_t super_root_node[] = {
+static const ctl_named_node_t super_root_node[] = {
 	{NAME(""),		CHILD(root)}
 };
 
@@ -597,7 +620,7 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 	int ret;
 	const char *elm, *tdot, *dot;
 	size_t elen, i, j;
-	const ctl_node_t *node;
+	const ctl_named_node_t *node;
 
 	elm = name;
 	/* Equivalent to strchrnul(). */
@@ -609,21 +632,21 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 	}
 	node = super_root_node;
 	for (i = 0; i < *depthp; i++) {
-		assert(node->named);
-		assert(node->u.named.nchildren > 0);
-		if (node->u.named.children[0].named) {
-			const ctl_node_t *pnode = node;
+		assert(node);
+		assert(node->nchildren > 0);
+		if (ctl_named_node(node->children)) {
+			const ctl_named_node_t *pnode = node;
 
 			/* Children are named. */
-			for (j = 0; j < node->u.named.nchildren; j++) {
-				const ctl_node_t *child =
-				    &node->u.named.children[j];
-				if (strlen(child->u.named.name) == elen
-				    && strncmp(elm, child->u.named.name,
-				    elen) == 0) {
+			for (j = 0; j < node->nchildren; j++) {
+				const ctl_named_node_t *child =
+				    ctl_named_children(node, j);
+				if (strlen(child->name) == elen &&
+				    strncmp(elm, child->name, elen) == 0) {
 					node = child;
 					if (nodesp != NULL)
-						nodesp[i] = node;
+						nodesp[i] =
+						    (const ctl_node_t *)node;
 					mibp[i] = j;
 					break;
 				}
@@ -634,7 +657,7 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 			}
 		} else {
 			uintmax_t index;
-			const ctl_node_t *inode;
+			const ctl_indexed_node_t *inode;
 
 			/* Children are indexed. */
 			index = malloc_strtoumax(elm, NULL, 10);
@@ -643,16 +666,15 @@ ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
 				goto label_return;
 			}
 
-			inode = &node->u.named.children[0];
-			node = inode->u.indexed.index(mibp, *depthp,
-			    (size_t)index);
+			inode = ctl_indexed_node(node->children);
+			node = inode->index(mibp, *depthp, (size_t)index);
 			if (node == NULL) {
 				ret = ENOENT;
 				goto label_return;
 			}
 
 			if (nodesp != NULL)
-				nodesp[i] = node;
+				nodesp[i] = (const ctl_node_t *)node;
 			mibp[i] = (size_t)index;
 		}
 
@@ -696,6 +718,7 @@ ctl_byname(const char *name, void *oldp, size_t *oldlenp, void *newp,
 	size_t depth;
 	ctl_node_t const *nodes[CTL_MAX_DEPTH];
 	size_t mib[CTL_MAX_DEPTH];
+	const ctl_named_node_t *node;
 
 	if (ctl_initialized == false && ctl_init()) {
 		ret = EAGAIN;
@@ -707,13 +730,14 @@ ctl_byname(const char *name, void *oldp, size_t *oldlenp, void *newp,
 	if (ret != 0)
 		goto label_return;
 
-	if (nodes[depth-1]->ctl == NULL) {
+	node = ctl_named_node(nodes[depth-1]);
+	if (node && node->ctl) {
+		ret = node->ctl(mib, depth, oldp, oldlenp, newp, newlen);
+	} else {
 		/* The name refers to a partial path through the ctl tree. */
 		ret = ENOENT;
-		goto label_return;
 	}
 
-	ret = nodes[depth-1]->ctl(mib, depth, oldp, oldlenp, newp, newlen);
 label_return:
 	return(ret);
 }
@@ -738,7 +762,7 @@ ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen)
 {
 	int ret;
-	const ctl_node_t *node;
+	const ctl_named_node_t *node;
 	size_t i;
 
 	if (ctl_initialized == false && ctl_init()) {
@@ -749,19 +773,21 @@ ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 	/* Iterate down the tree. */
 	node = super_root_node;
 	for (i = 0; i < miblen; i++) {
-		if (node->u.named.children[0].named) {
+		assert(node);
+		assert(node->nchildren > 0);
+		if (ctl_named_node(node->children)) {
 			/* Children are named. */
-			if (node->u.named.nchildren <= mib[i]) {
+			if (node->nchildren <= mib[i]) {
 				ret = ENOENT;
 				goto label_return;
 			}
-			node = &node->u.named.children[mib[i]];
+			node = ctl_named_children(node, mib[i]);
 		} else {
-			const ctl_node_t *inode;
+			const ctl_indexed_node_t *inode;
 
 			/* Indexed element. */
-			inode = &node->u.named.children[0];
-			node = inode->u.indexed.index(mib, miblen, mib[i]);
+			inode = ctl_indexed_node(node->children);
+			node = inode->index(mib, miblen, mib[i]);
 			if (node == NULL) {
 				ret = ENOENT;
 				goto label_return;
@@ -770,12 +796,12 @@ ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 	}
 
 	/* Call the ctl function. */
-	if (node->ctl == NULL) {
+	if (node && node->ctl) {
+		ret = node->ctl(mib, miblen, oldp, oldlenp, newp, newlen);
+	} else {
 		/* Partial MIB. */
 		ret = ENOENT;
-		goto label_return;
 	}
-	ret = node->ctl(mib, miblen, oldp, oldlenp, newp, newlen);
 
 label_return:
 	return(ret);
@@ -1133,7 +1159,7 @@ CTL_RO_NL_CGEN(config_prof, opt_prof_accum, opt_prof_accum, bool)
 CTL_RO_NL_GEN(arenas_bin_i_size, arena_bin_info[mib[2]].reg_size, size_t)
 CTL_RO_NL_GEN(arenas_bin_i_nregs, arena_bin_info[mib[2]].nregs, uint32_t)
 CTL_RO_NL_GEN(arenas_bin_i_run_size, arena_bin_info[mib[2]].run_size, size_t)
-const ctl_node_t *
+const ctl_named_node_t *
 arenas_bin_i_index(const size_t *mib, size_t miblen, size_t i)
 {
 
@@ -1143,7 +1169,7 @@ arenas_bin_i_index(const size_t *mib, size_t miblen, size_t i)
 }
 
 CTL_RO_NL_GEN(arenas_lrun_i_size, ((mib[2]+1) << LG_PAGE), size_t)
-const ctl_node_t *
+const ctl_named_node_t *
 arenas_lrun_i_index(const size_t *mib, size_t miblen, size_t i)
 {
 
@@ -1326,7 +1352,7 @@ CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nreruns,
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_curruns,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].curruns, size_t)
 
-const ctl_node_t *
+const ctl_named_node_t *
 stats_arenas_i_bins_j_index(const size_t *mib, size_t miblen, size_t j)
 {
 
@@ -1344,7 +1370,7 @@ CTL_RO_CGEN(config_stats, stats_arenas_i_lruns_j_nrequests,
 CTL_RO_CGEN(config_stats, stats_arenas_i_lruns_j_curruns,
     ctl_stats.arenas[mib[2]].lstats[mib[4]].curruns, size_t)
 
-const ctl_node_t *
+const ctl_named_node_t *
 stats_arenas_i_lruns_j_index(const size_t *mib, size_t miblen, size_t j)
 {
 
@@ -1365,10 +1391,10 @@ CTL_RO_CGEN(config_stats, stats_arenas_i_nmadvise,
 CTL_RO_CGEN(config_stats, stats_arenas_i_purged,
     ctl_stats.arenas[mib[2]].astats.purged, uint64_t)
 
-const ctl_node_t *
+const ctl_named_node_t *
 stats_arenas_i_index(const size_t *mib, size_t miblen, size_t i)
 {
-	const ctl_node_t * ret;
+	const ctl_named_node_t * ret;
 
 	malloc_mutex_lock(&ctl_mtx);
 	if (ctl_stats.arenas[i].initialized == false) {
-- 
1.7.10



From justin.lebar at gmail.com  Fri Apr 20 04:55:12 2012
From: justin.lebar at gmail.com (Justin Lebar)
Date: Fri, 20 Apr 2012 21:55:12 +1000
Subject: 1kb and 2kb allocation "waste"
Message-ID: <CAFWcpZ5x0My9bZSVgHe9a5v5LvxKzWRJUE5LLRMS4zr6JOQ9Eg@mail.gmail.com>

It turns out that 1kb and 2kb allocations are responsible for upwards
of 1/3 of all wasted space in Firefox, where by "wasted space", I
mean: Open a bunch of tabs, close them, and call "waste" any heap
memory which is committed but not part of an active allocation.
(We've been calling this "external fragmentation", but that doesn't
quite match up with the common definition, as I understand it.)

I recorded a session of malloc/free's and played it back with the
malloc's from various call stacks removed, to see if the allocation
pattern around some call sites was for most of this wasted space.  But
the waste is remarkably sticky -- even when I cut out the vast
majority of 2kb allocations, I still get a large amount of waste.
This leads me to believe that ridding ourselves of this waste may
require changes to the allocator.

The essential problem, as I understand it, is that 1kb and 2kb chunks
are allocated as part of larger runs (32kb in Firefox's jemalloc -- I
haven't checked in jemalloc2).  We can't (rather, we don't)
munmap/MADV_DONTNEED one page out of a run, so a single 2kb allocation
can keep alive 32kb of memory.

My idea is that we can address this by adding a new allocation method,
between small and large.  These "medium" allocations are allocated
inside a chunk and don't have a run header, like large allocations.
But whereas one large allocation gets one entry in the chunk metadata
table, two or four medium allocations will share one entry in the
chunk metadata table.  It looks like we have plenty of bits available
to express "{first,second,third,fourth} quarter of this page is an
active 1kb alloc" and "{first,second} half of this page is an active
2kb alloc".

This may, of course, increase fragmentation inside our chunks (in
exactly the same way as if we increased the number of 4kb
allocations).  I think the trade-off should be sound, because if we
end up allocating more chunks, we can still decommit the fragmented
memory, so we're not necessarily wasting physical memory.

An alternative solution would be to implement munmap/MADV_DONTNEED for
portions of runs.  Offhand, I think this isn't as good as the first
solution, since I think it would end up requiring more madvise calls:
The run itself has metadata, so we have to madvise() around two live
objects instead of just one, which reduces our ability to coalesce
madvise calls.  Not to mention the fact that the run header is not
free.

It looks like jemalloc2 introduced size classes between 1kb and 2kb.
I haven't dug in enough to figure out if it would be possible to keep
these additional size classes and treat 1kb and 2kb specially, or if
we'd have to choose between the additional size classes and these
medium allocations.  I don't know whether the benefits of medium
allocations would outweigh the benefits of the additional size classes
for Firefox, but I'd give it good odds.

This is a solution which likely makes sense only for systems with 4kb
pages, and it looks like jemalloc2 tries hard to be agnostic about
things like page size.  I don't know how much this speaks against the
solution, partially because I have no idea how these 64kb pages come
into play.  Perhaps I'm misunderstanding what LG_PAGE==16 is meant to
mean.

Anyway, before I waste more time on this, I was hoping to get your
thoughts.  Perhaps you've thought of or even tried something like this
before?  Please let me know if you think I'm barking up the wrong
tree.

Regards,
-Justin


From jasone at canonware.com  Fri Apr 20 17:23:59 2012
From: jasone at canonware.com (Jason Evans)
Date: Fri, 20 Apr 2012 17:23:59 -0700
Subject: 1kb and 2kb allocation "waste"
In-Reply-To: <CAFWcpZ5x0My9bZSVgHe9a5v5LvxKzWRJUE5LLRMS4zr6JOQ9Eg@mail.gmail.com>
References: <CAFWcpZ5x0My9bZSVgHe9a5v5LvxKzWRJUE5LLRMS4zr6JOQ9Eg@mail.gmail.com>
Message-ID: <DEBFEC14-9C64-4702-B8A8-A1ECE5AF4438@canonware.com>

On Apr 20, 2012, at 4:55 AM, Justin Lebar wrote:
> It turns out that 1kb and 2kb allocations are responsible for upwards
> of 1/3 of all wasted space in Firefox, where by "wasted space", I
> mean: Open a bunch of tabs, close them, and call "waste" any heap
> memory which is committed but not part of an active allocation.
> (We've been calling this "external fragmentation", but that doesn't
> quite match up with the common definition, as I understand it.)

Do 1 and 2 KiB allocations make up substantially less than 1/3 of the memory devoted to small allocations?

> My idea is that we can address this by adding a new allocation method,
> between small and large.  These "medium" allocations are allocated
> inside a chunk and don't have a run header, like large allocations.
> But whereas one large allocation gets one entry in the chunk metadata
> table, two or four medium allocations will share one entry in the
> chunk metadata table.  It looks like we have plenty of bits available
> to express "{first,second,third,fourth} quarter of this page is an
> active 1kb alloc" and "{first,second} half of this page is an active
> 2kb alloc".

There was a period of time that jemalloc had a related strategy.  In 2009 I added medium size classes that went up to 32 KiB, mainly in order to close the 4 KiB .. 8 KiB internal fragmentation gap.  In order to mitigate the increased RSS due to external fragmentation (the same problem you're describing for 1 and 2 KiB objects) I added extra bookkeeping that made it possible to call madvise() for completely unused interspersed pages.  Since these size classes were all >= 4 KiB, even a single free region guaranteed that at least one page could be madvise()d away.  Unfortunately, I had to remove medium size classes when I restructured dirty page purging to happen without any locks held; it wouldn't have been possible to safely madvise() pages within active medium runs without some locking.

As you noted, your suggestion of using the chunk map to store all metadata would work okay for 1 and 2 KiB size classes, but it wouldn't work out very well for the intermediate size classes that newer versions have.

It would be awesome if small runs didn't need an embedded metadata header, and the metadata could all be in the chunk header.  However, there are a few things that get in the way of a clean solution.  First, the worst case requirements for the bitmaps that track which regions are allocated would be 1/64 of arena memory, which is rather a lot.  Second, chunk map overhead would go up some because every page would need an arena_run_t.  Third, heap profiling currently works reasonably well for very high sample rates, and that functionality would have to be sacrificed.  I've toyed with this general direction many times, but I've never been able to convince myself that the tradeoffs are compelling.  I've also tried to come up with solutions to the high bitmap overhead, but it ends up boiling down to a suballocator problem that is a liability under worst case conditions.

> This is a solution which likely makes sense only for systems with 4kb
> pages, and it looks like jemalloc2 tries hard to be agnostic about
> things like page size.  I don't know how much this speaks against the
> solution, partially because I have no idea how these 64kb pages come
> into play.  Perhaps I'm misunderstanding what LG_PAGE==16 is meant to
> mean.

Yes, there are some systems that use 64 KiB pages by default, so any solutions need to be pretty pagesize-agnostic.

Today has been a bunch of interleaved fire drills for me, so I'd better send this email before it gets lost forever.  I'm interested to hear your thoughts on the design space.  It's tempting to do an experiment that removes run headers, but the back-of-the-envelope calculations I did earlier weren't encouraging?

Jason

From justin.lebar at gmail.com  Fri Apr 20 19:35:47 2012
From: justin.lebar at gmail.com (Justin Lebar)
Date: Sat, 21 Apr 2012 12:35:47 +1000
Subject: 1kb and 2kb allocation "waste"
In-Reply-To: <DEBFEC14-9C64-4702-B8A8-A1ECE5AF4438@canonware.com>
References: <CAFWcpZ5x0My9bZSVgHe9a5v5LvxKzWRJUE5LLRMS4zr6JOQ9Eg@mail.gmail.com>
	<DEBFEC14-9C64-4702-B8A8-A1ECE5AF4438@canonware.com>
Message-ID: <CAFWcpZ5OhcDLM46j0HQwfhG2zBxC5E2rBHqygD=LEVwgHsJU0g@mail.gmail.com>

On Sat, Apr 21, 2012 at 10:23 AM, Jason Evans <jasone at canonware.com> wrote:
> On Apr 20, 2012, at 4:55 AM, Justin Lebar wrote:
>> It turns out that 1kb and 2kb allocations are responsible for upwards
>> of 1/3 of all wasted space in Firefox, where by "wasted space", I
>> mean: Open a bunch of tabs, close them, and call "waste" any heap
>> memory which is committed but not part of an active allocation.
>> (We've been calling this "external fragmentation", but that doesn't
>> quite match up with the common definition, as I understand it.)
>
> Do 1 and 2 KiB allocations make up substantially less than 1/3 of the memory devoted to small allocations?

No; in fact, in one run of the browser that I recorded, 1 and 2KiB
allocations together use 52% the memory devoted to small allocations
while accounting for only 35% of waste.  So that sounds pretty good!

On the other hand, it still doesn't tell me how to fix things, except
by saying that there's nothing to be fixed.  :)

> Yes, there are some systems that use 64 KiB pages by default, so any solutions need to be pretty pagesize-agnostic.

I guess supporting "medium" allocations of size pagesize/2 and
pagesize/4 would be feasible.

> Today has been a bunch of interleaved fire drills for me, so I'd better send this email before it gets lost forever. ?I'm interested to hear your thoughts on the design space. ?It's tempting to do an experiment that removes run headers, but the back-of-the-envelope calculations I did earlier weren't encouraging?

Yes, I suspect that for smaller allocations -- particularly when the
size of the allocation is not much larger than the size of the header
-- there isn't much to be gained by this approach.

It sounds like this might be worth digging into more.  I'll let you
know what I come up with.

-Justin


From jasone at canonware.com  Sun Apr 22 01:08:19 2012
From: jasone at canonware.com (Jason Evans)
Date: Sun, 22 Apr 2012 01:08:19 -0700
Subject: [PATCH 7/7] Remove variable length arrays and declarations within
	code
In-Reply-To: <1334903923-4973-7-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
	<1334903923-4973-7-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <53BEBC59-1F8B-40B9-9291-2F7C18428844@canonware.com>

On Apr 19, 2012, at 11:38 PM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> MSVC doesn't support C99, and building as C++ to be able to use them is
> dangerous, as C++ and C99 are incompatible.
> ---
> include/jemalloc/internal/prof.h |    3 ++-
> src/arena.c                      |   17 ++++++++++-------
> src/chunk_mmap.c                 |    5 +++--
> src/ctl.c                        |    6 ++++--
> src/stats.c                      |   12 ++++++++----
> src/tsd.c                        |    2 +-
> test/bitmap.c                    |   12 ++++++++----
> 7 files changed, 36 insertions(+), 21 deletions(-)

This diff adds calls to malloc/free from within the allocator, which perturbs heap profiling.  imalloc/idalloc are probably what you want instead.

Jason

From jasone at canonware.com  Sun Apr 22 01:09:07 2012
From: jasone at canonware.com (Jason Evans)
Date: Sun, 22 Apr 2012 01:09:07 -0700
Subject: [PATCH 6/7] Avoid using a union for ctl_node_s
In-Reply-To: <1334903923-4973-6-git-send-email-mh+jemalloc@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
	<1334903923-4973-6-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <2D0350A7-8F85-4C88-B6A2-CAB6AB5B3437@canonware.com>

On Apr 19, 2012, at 11:38 PM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> MSVC doesn't support C99, and as such doesn't support designated
> initialization of structs and unions. As there is never a mix of
> indexed and named nodes, it is pretty straightforward to use a
> different type for each.
> ---
> include/jemalloc/internal/ctl.h |   27 ++++---
> src/ctl.c                       |  164 +++++++++++++++++++++++----------------
> 2 files changed, 110 insertions(+), 81 deletions(-)

This patch causes crashes if MALLOC_CONF=stats_print:true is set.

Jason

From mh+jemalloc at glandium.org  Sun Apr 22 01:46:30 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Sun, 22 Apr 2012 10:46:30 +0200
Subject: [PATCH 7/7] Remove variable length arrays and declarations
	within code
In-Reply-To: <53BEBC59-1F8B-40B9-9291-2F7C18428844@canonware.com>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
	<1334903923-4973-7-git-send-email-mh+jemalloc@glandium.org>
	<53BEBC59-1F8B-40B9-9291-2F7C18428844@canonware.com>
Message-ID: <20120422084630.GA24075@glandium.org>

On Sun, Apr 22, 2012 at 01:08:19AM -0700, Jason Evans wrote:
> On Apr 19, 2012, at 11:38 PM, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > MSVC doesn't support C99, and building as C++ to be able to use them is
> > dangerous, as C++ and C99 are incompatible.
> > ---
> > include/jemalloc/internal/prof.h |    3 ++-
> > src/arena.c                      |   17 ++++++++++-------
> > src/chunk_mmap.c                 |    5 +++--
> > src/ctl.c                        |    6 ++++--
> > src/stats.c                      |   12 ++++++++----
> > src/tsd.c                        |    2 +-
> > test/bitmap.c                    |   12 ++++++++----
> > 7 files changed, 36 insertions(+), 21 deletions(-)
> 
> This diff adds calls to malloc/free from within the allocator, which
> perturbs heap profiling.  imalloc/idalloc are probably what you want
> instead.

alloca might work, too, if you're okay using it. We could also have a
helper macro using variable length arrays or alloca depending on the
value of __STDC_VERSION__...

Mike


From mh+jemalloc at glandium.org  Sun Apr 22 23:50:10 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 23 Apr 2012 08:50:10 +0200
Subject: [PATCH 6/7] Avoid using a union for ctl_node_s
In-Reply-To: <2D0350A7-8F85-4C88-B6A2-CAB6AB5B3437@canonware.com>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
	<1334903923-4973-6-git-send-email-mh+jemalloc@glandium.org>
	<2D0350A7-8F85-4C88-B6A2-CAB6AB5B3437@canonware.com>
Message-ID: <20120423065010.GA23732@glandium.org>

On Sun, Apr 22, 2012 at 01:09:07AM -0700, Jason Evans wrote:
> On Apr 19, 2012, at 11:38 PM, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > MSVC doesn't support C99, and as such doesn't support designated
> > initialization of structs and unions. As there is never a mix of
> > indexed and named nodes, it is pretty straightforward to use a
> > different type for each.
> > ---
> > include/jemalloc/internal/ctl.h |   27 ++++---
> > src/ctl.c                       |  164 +++++++++++++++++++++++----------------
> > 2 files changed, 110 insertions(+), 81 deletions(-)
> 
> This patch causes crashes if MALLOC_CONF=stats_print:true is set.

I ran all the tests with MALLOC_CONF=stats_print:true and got no crash.
Do you have a testcase?

Mike


From jasone at canonware.com  Mon Apr 23 11:33:39 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 23 Apr 2012 11:33:39 -0700
Subject: [PATCH 6/7] Avoid using a union for ctl_node_s
In-Reply-To: <20120423065010.GA23732@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
	<1334903923-4973-6-git-send-email-mh+jemalloc@glandium.org>
	<2D0350A7-8F85-4C88-B6A2-CAB6AB5B3437@canonware.com>
	<20120423065010.GA23732@glandium.org>
Message-ID: <6BFA1CEC-E12B-43F7-8273-6DE004E4F8FB@canonware.com>

On Apr 22, 2012, at 11:50 PM, Mike Hommey wrote:
> On Sun, Apr 22, 2012 at 01:09:07AM -0700, Jason Evans wrote:
>> On Apr 19, 2012, at 11:38 PM, Mike Hommey wrote:
>>> From: Mike Hommey <mh at glandium.org>
>>> 
>>> MSVC doesn't support C99, and as such doesn't support designated
>>> initialization of structs and unions. As there is never a mix of
>>> indexed and named nodes, it is pretty straightforward to use a
>>> different type for each.
>>> ---
>>> include/jemalloc/internal/ctl.h |   27 ++++---
>>> src/ctl.c                       |  164 +++++++++++++++++++++++----------------
>>> 2 files changed, 110 insertions(+), 81 deletions(-)
>> 
>> This patch causes crashes if MALLOC_CONF=stats_print:true is set.
> 
> I ran all the tests with MALLOC_CONF=stats_print:true and got no crash.
> Do you have a testcase?
> 
> Mike

This crashes on both Linux and FreeBSD:

	MALLOC_CONF=stats_print:true LD_PRELOAD=/home/je/jemalloc/lib/libjemalloc.so.1 /bin/ls

Anyway, I just found the problem: ctl_indexed_node() has its conditional reversed, so it returns NULL for indexed nodes.  I'll commit with the fix integrated, assuming no other problems show up.

Jason

From jasone at canonware.com  Mon Apr 23 11:53:23 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 23 Apr 2012 11:53:23 -0700
Subject: [PATCH 7/7] Remove variable length arrays and declarations within
	code
In-Reply-To: <20120422084630.GA24075@glandium.org>
References: <20120420063656.GA2098@glandium.org>
	<1334903923-4973-1-git-send-email-mh+jemalloc@glandium.org>
	<1334903923-4973-7-git-send-email-mh+jemalloc@glandium.org>
	<53BEBC59-1F8B-40B9-9291-2F7C18428844@canonware.com>
	<20120422084630.GA24075@glandium.org>
Message-ID: <A7170D01-97D6-4AB0-8130-F2AFACA4C70E@canonware.com>

On Apr 22, 2012, at 1:46 AM, Mike Hommey wrote:
> On Sun, Apr 22, 2012 at 01:08:19AM -0700, Jason Evans wrote:
>> On Apr 19, 2012, at 11:38 PM, Mike Hommey wrote:
>>> From: Mike Hommey <mh at glandium.org>
>>> 
>>> MSVC doesn't support C99, and building as C++ to be able to use them is
>>> dangerous, as C++ and C99 are incompatible.
>>> ---
>>> include/jemalloc/internal/prof.h |    3 ++-
>>> src/arena.c                      |   17 ++++++++++-------
>>> src/chunk_mmap.c                 |    5 +++--
>>> src/ctl.c                        |    6 ++++--
>>> src/stats.c                      |   12 ++++++++----
>>> src/tsd.c                        |    2 +-
>>> test/bitmap.c                    |   12 ++++++++----
>>> 7 files changed, 36 insertions(+), 21 deletions(-)
>> 
>> This diff adds calls to malloc/free from within the allocator, which
>> perturbs heap profiling.  imalloc/idalloc are probably what you want
>> instead.
> 
> alloca might work, too, if you're okay using it. We could also have a
> helper macro using variable length arrays or alloca depending on the
> value of __STDC_VERSION__...

I kind of like the helper macro idea (use variable length arrays when available, otherwise use alloca()).

Jason

From mh+jemalloc at glandium.org  Mon Apr 23 23:35:10 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 24 Apr 2012 08:35:10 +0200
Subject: [6716aa8] Force use of TLS if heap profiling is enabled
Message-ID: <20120424063510.GA23669@glandium.org>

Hi,

Out of curiosity, what makes heap profiling require __thread?
(I'm curious because it makes it unusable on OSX and Windows)

Mike


From jasone at canonware.com  Mon Apr 23 23:54:53 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 23 Apr 2012 23:54:53 -0700
Subject: [6716aa8] Force use of TLS if heap profiling is enabled
In-Reply-To: <20120424063510.GA23669@glandium.org>
References: <20120424063510.GA23669@glandium.org>
Message-ID: <2F7E1CCD-7564-48E0-A7A7-8F1245DDDE9F@canonware.com>

On Apr 23, 2012, at 11:35 PM, Mike Hommey wrote:
> Out of curiosity, what makes heap profiling require __thread?
> (I'm curious because it makes it unusable on OSX and Windows)

There's a bunch of per thread state that is needed to keep the profiling code from becoming a contention point.  It's probably possible to refactor the code to avoid the dependency on __thread (make tsd allocation safe), but right now there are other reasons heap profiling only works on Linux (e.g. "/proc/self/maps"), so for now I chose to modify the configure script to prevent an unusable configuration.

Jason

From mh+jemalloc at glandium.org  Tue Apr 24 07:39:11 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 24 Apr 2012 16:39:11 +0200
Subject: [PATCH] Avoid variable length arrays and remove declarations within
	code
In-Reply-To: <A7170D01-97D6-4AB0-8130-F2AFACA4C70E@canonware.com>
References: <A7170D01-97D6-4AB0-8130-F2AFACA4C70E@canonware.com>
Message-ID: <1335278351-8727-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

MSVC doesn't support C99, and building as C++ to be able to use them is
dangerous, as C++ and C99 are incompatible.

Introduce a VARIABLE_ARRAY macro that either uses VLA when supported,
or alloca() otherwise. Note that using alloca() inside loops doesn't
quite work like VLAs, thus the use of VARIABLE_ARRAY there is discouraged.
It might be worth investigating ways to check whether VARIABLE_ARRAY is
used in such context at runtime in debug builds and bail out if that
happens.
---
 include/jemalloc/internal/jemalloc_internal.h.in |   14 ++++++++++++++
 include/jemalloc/internal/prof.h                 |    3 ++-
 src/arena.c                                      |   18 ++++++++++--------
 src/ctl.c                                        |    4 ++--
 src/stats.c                                      |    4 ++--
 src/tsd.c                                        |    2 +-
 test/bitmap.c                                    |   16 ++++++++++++----
 7 files changed, 43 insertions(+), 18 deletions(-)

diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index 691f50a..dcc17c8 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -319,6 +319,20 @@ static const bool config_ivsalloc =
 #define	ALIGNMENT_CEILING(s, alignment)					\
 	(((s) + (alignment - 1)) & (-(alignment)))
 
+/* Declare a variable length array */
+#if __STDC_VERSION__ < 199901L
+#ifdef _MSC_VER
+#include <malloc.h>
+#define alloca _alloca
+#else
+#include <alloca.h>
+#endif
+#define VARIABLE_ARRAY(name, type, size) \
+	type *name = alloca(sizeof(type) * size)
+#else
+#define VARIABLE_ARRAY(name, type, size) type name[size]
+#endif
+
 #ifdef JEMALLOC_VALGRIND
 /*
  * The JEMALLOC_VALGRIND_*() macros must be macros rather than functions
diff --git a/include/jemalloc/internal/prof.h b/include/jemalloc/internal/prof.h
index 093ac93..e091478 100644
--- a/include/jemalloc/internal/prof.h
+++ b/include/jemalloc/internal/prof.h
@@ -526,8 +526,9 @@ prof_free(const void *ptr, size_t size)
 	cassert(config_prof);
 
 	if ((uintptr_t)ctx > (uintptr_t)1) {
+		prof_thr_cnt_t *tcnt;
 		assert(size == isalloc(ptr, true));
-		prof_thr_cnt_t *tcnt = prof_lookup(ctx->bt);
+		tcnt = prof_lookup(ctx->bt);
 
 		if (tcnt != NULL) {
 			tcnt->epoch++;
diff --git a/src/arena.c b/src/arena.c
index f13b5e1..7fac361 100644
--- a/src/arena.c
+++ b/src/arena.c
@@ -640,14 +640,14 @@ arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk)
 			if (mapelm->bits & CHUNK_MAP_LARGE)
 				pageind += mapelm->bits >> LG_PAGE;
 			else {
+				size_t binind;
+				arena_bin_info_t *bin_info;
 				arena_run_t *run = (arena_run_t *)((uintptr_t)
 				    chunk + (uintptr_t)(pageind << LG_PAGE));
 
 				assert((mapelm->bits >> LG_PAGE) == 0);
-				size_t binind = arena_bin_index(arena,
-				    run->bin);
-				arena_bin_info_t *bin_info =
-				    &arena_bin_info[binind];
+				binind = arena_bin_index(arena, run->bin);
+				bin_info = &arena_bin_info[binind];
 				pageind += bin_info->run_size >> LG_PAGE;
 			}
 		}
@@ -1056,11 +1056,12 @@ arena_bin_runs_first(arena_bin_t *bin)
 	if (mapelm != NULL) {
 		arena_chunk_t *chunk;
 		size_t pageind;
+		arena_run_t *run;
 
 		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mapelm);
 		pageind = ((((uintptr_t)mapelm - (uintptr_t)chunk->map) /
 		    sizeof(arena_chunk_map_t))) + map_bias;
-		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
+		run = (arena_run_t *)((uintptr_t)chunk +
 		    (uintptr_t)((pageind - (mapelm->bits >> LG_PAGE)) <<
 		    LG_PAGE));
 		return (run);
@@ -1596,14 +1597,15 @@ arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
 	size_t pageind;
 	arena_run_t *run;
 	arena_bin_t *bin;
-	size_t size;
+	arena_bin_info_t *bin_info;
+	size_t size, binind;
 
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
 	    (mapelm->bits >> LG_PAGE)) << LG_PAGE));
 	bin = run->bin;
-	size_t binind = arena_bin_index(arena, bin);
-	arena_bin_info_t *bin_info = &arena_bin_info[binind];
+	binind = arena_bin_index(arena, bin);
+	bin_info = &arena_bin_info[binind];
 	if (config_fill || config_stats)
 		size = bin_info->reg_size;
 
diff --git a/src/ctl.c b/src/ctl.c
index 4dbbefc..122e84e 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -520,7 +520,7 @@ static void
 ctl_refresh(void)
 {
 	unsigned i;
-	arena_t *tarenas[narenas];
+	VARIABLE_ARRAY(tarenas, arena_t *, narenas);
 
 	if (config_stats) {
 		malloc_mutex_lock(&chunks_mtx);
@@ -1233,7 +1233,7 @@ arenas_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 		ret = EFAULT;
 		goto label_return;
 	} else {
-		arena_t *tarenas[narenas];
+		VARIABLE_ARRAY(tarenas, arena_t *, narenas);
 
 		malloc_mutex_lock(&arenas_lock);
 		memcpy(tarenas, arenas, sizeof(arena_t *) * narenas);
diff --git a/src/stats.c b/src/stats.c
index 08f7098..3b5df44 100644
--- a/src/stats.c
+++ b/src/stats.c
@@ -498,7 +498,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				VARIABLE_ARRAY(initialized, bool, narenas);
 				size_t isz;
 				unsigned i, ninitialized;
 
@@ -527,7 +527,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				VARIABLE_ARRAY(initialized, bool, narenas);
 				size_t isz;
 				unsigned i;
 
diff --git a/src/tsd.c b/src/tsd.c
index 09f06e8..d7714b0 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -36,7 +36,7 @@ JEMALLOC_ATTR(visibility("default"))
 void
 _malloc_thread_cleanup(void)
 {
-	bool pending[ncleanups], again;
+	bool pending[MALLOC_TSD_CLEANUPS_MAX], again;
 	unsigned i;
 
 	for (i = 0; i < ncleanups; i++)
diff --git a/test/bitmap.c b/test/bitmap.c
index ff50ecb..b2cb630 100644
--- a/test/bitmap.c
+++ b/test/bitmap.c
@@ -30,11 +30,13 @@ test_bitmap_init(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				assert(bitmap_get(bitmap, &binfo, j) == false);
+			free(bitmap);
 
 		}
 	}
@@ -50,12 +52,14 @@ test_bitmap_set(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -70,7 +74,8 @@ test_bitmap_unset(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
@@ -81,6 +86,7 @@ test_bitmap_unset(void)
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -95,7 +101,8 @@ test_bitmap_sfu(void)
 		bitmap_info_init(&binfo, i);
 		{
 			ssize_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			/* Iteratively set bits starting at the beginning. */
@@ -125,6 +132,7 @@ test_bitmap_sfu(void)
 			}
 			assert(bitmap_sfu(bitmap, &binfo) == i - 1);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
-- 
1.7.10



From mh+jemalloc at glandium.org  Tue Apr 24 14:22:02 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 24 Apr 2012 23:22:02 +0200
Subject: [PATCH] Avoid variable length arrays and remove declarations within
	code
In-Reply-To: <A7170D01-97D6-4AB0-8130-F2AFACA4C70E@canonware.com>
References: <A7170D01-97D6-4AB0-8130-F2AFACA4C70E@canonware.com>
Message-ID: <1335302522-22177-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

MSVC doesn't support C99, and building as C++ to be able to use them is
dangerous, as C++ and C99 are incompatible.

Introduce a VARIABLE_ARRAY macro that either uses VLA when supported,
or alloca() otherwise. Note that using alloca() inside loops doesn't
quite work like VLAs, thus the use of VARIABLE_ARRAY there is discouraged.
It might be worth investigating ways to check whether VARIABLE_ARRAY is
used in such context at runtime in debug builds and bail out if that
happens.
---
 include/jemalloc/internal/jemalloc_internal.h.in |   14 ++++++++++++++
 include/jemalloc/internal/prof.h                 |    3 ++-
 src/arena.c                                      |   18 ++++++++++--------
 src/ctl.c                                        |    4 ++--
 src/stats.c                                      |    4 ++--
 src/tsd.c                                        |    2 +-
 test/bitmap.c                                    |   16 ++++++++++++----
 7 files changed, 43 insertions(+), 18 deletions(-)

diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index 691f50a..dcc17c8 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -319,6 +319,20 @@ static const bool config_ivsalloc =
 #define	ALIGNMENT_CEILING(s, alignment)					\
 	(((s) + (alignment - 1)) & (-(alignment)))
 
+/* Declare a variable length array */
+#if __STDC_VERSION__ < 199901L
+#ifdef _MSC_VER
+#include <malloc.h>
+#define alloca _alloca
+#else
+#include <alloca.h>
+#endif
+#define VARIABLE_ARRAY(name, type, size) \
+	type *name = alloca(sizeof(type) * size)
+#else
+#define VARIABLE_ARRAY(name, type, size) type name[size]
+#endif
+
 #ifdef JEMALLOC_VALGRIND
 /*
  * The JEMALLOC_VALGRIND_*() macros must be macros rather than functions
diff --git a/include/jemalloc/internal/prof.h b/include/jemalloc/internal/prof.h
index 093ac93..e091478 100644
--- a/include/jemalloc/internal/prof.h
+++ b/include/jemalloc/internal/prof.h
@@ -526,8 +526,9 @@ prof_free(const void *ptr, size_t size)
 	cassert(config_prof);
 
 	if ((uintptr_t)ctx > (uintptr_t)1) {
+		prof_thr_cnt_t *tcnt;
 		assert(size == isalloc(ptr, true));
-		prof_thr_cnt_t *tcnt = prof_lookup(ctx->bt);
+		tcnt = prof_lookup(ctx->bt);
 
 		if (tcnt != NULL) {
 			tcnt->epoch++;
diff --git a/src/arena.c b/src/arena.c
index f13b5e1..7fac361 100644
--- a/src/arena.c
+++ b/src/arena.c
@@ -640,14 +640,14 @@ arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk)
 			if (mapelm->bits & CHUNK_MAP_LARGE)
 				pageind += mapelm->bits >> LG_PAGE;
 			else {
+				size_t binind;
+				arena_bin_info_t *bin_info;
 				arena_run_t *run = (arena_run_t *)((uintptr_t)
 				    chunk + (uintptr_t)(pageind << LG_PAGE));
 
 				assert((mapelm->bits >> LG_PAGE) == 0);
-				size_t binind = arena_bin_index(arena,
-				    run->bin);
-				arena_bin_info_t *bin_info =
-				    &arena_bin_info[binind];
+				binind = arena_bin_index(arena, run->bin);
+				bin_info = &arena_bin_info[binind];
 				pageind += bin_info->run_size >> LG_PAGE;
 			}
 		}
@@ -1056,11 +1056,12 @@ arena_bin_runs_first(arena_bin_t *bin)
 	if (mapelm != NULL) {
 		arena_chunk_t *chunk;
 		size_t pageind;
+		arena_run_t *run;
 
 		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mapelm);
 		pageind = ((((uintptr_t)mapelm - (uintptr_t)chunk->map) /
 		    sizeof(arena_chunk_map_t))) + map_bias;
-		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
+		run = (arena_run_t *)((uintptr_t)chunk +
 		    (uintptr_t)((pageind - (mapelm->bits >> LG_PAGE)) <<
 		    LG_PAGE));
 		return (run);
@@ -1596,14 +1597,15 @@ arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
 	size_t pageind;
 	arena_run_t *run;
 	arena_bin_t *bin;
-	size_t size;
+	arena_bin_info_t *bin_info;
+	size_t size, binind;
 
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
 	    (mapelm->bits >> LG_PAGE)) << LG_PAGE));
 	bin = run->bin;
-	size_t binind = arena_bin_index(arena, bin);
-	arena_bin_info_t *bin_info = &arena_bin_info[binind];
+	binind = arena_bin_index(arena, bin);
+	bin_info = &arena_bin_info[binind];
 	if (config_fill || config_stats)
 		size = bin_info->reg_size;
 
diff --git a/src/ctl.c b/src/ctl.c
index 4dbbefc..122e84e 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -520,7 +520,7 @@ static void
 ctl_refresh(void)
 {
 	unsigned i;
-	arena_t *tarenas[narenas];
+	VARIABLE_ARRAY(tarenas, arena_t *, narenas);
 
 	if (config_stats) {
 		malloc_mutex_lock(&chunks_mtx);
@@ -1233,7 +1233,7 @@ arenas_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
 		ret = EFAULT;
 		goto label_return;
 	} else {
-		arena_t *tarenas[narenas];
+		VARIABLE_ARRAY(tarenas, arena_t *, narenas);
 
 		malloc_mutex_lock(&arenas_lock);
 		memcpy(tarenas, arenas, sizeof(arena_t *) * narenas);
diff --git a/src/stats.c b/src/stats.c
index 08f7098..3b5df44 100644
--- a/src/stats.c
+++ b/src/stats.c
@@ -498,7 +498,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				VARIABLE_ARRAY(initialized, bool, narenas);
 				size_t isz;
 				unsigned i, ninitialized;
 
@@ -527,7 +527,7 @@ stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
-				bool initialized[narenas];
+				VARIABLE_ARRAY(initialized, bool, narenas);
 				size_t isz;
 				unsigned i;
 
diff --git a/src/tsd.c b/src/tsd.c
index 09f06e8..d7714b0 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -36,7 +36,7 @@ JEMALLOC_ATTR(visibility("default"))
 void
 _malloc_thread_cleanup(void)
 {
-	bool pending[ncleanups], again;
+	bool pending[MALLOC_TSD_CLEANUPS_MAX], again;
 	unsigned i;
 
 	for (i = 0; i < ncleanups; i++)
diff --git a/test/bitmap.c b/test/bitmap.c
index ff50ecb..b2cb630 100644
--- a/test/bitmap.c
+++ b/test/bitmap.c
@@ -30,11 +30,13 @@ test_bitmap_init(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				assert(bitmap_get(bitmap, &binfo, j) == false);
+			free(bitmap);
 
 		}
 	}
@@ -50,12 +52,14 @@ test_bitmap_set(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -70,7 +74,8 @@ test_bitmap_unset(void)
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
@@ -81,6 +86,7 @@ test_bitmap_unset(void)
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
@@ -95,7 +101,8 @@ test_bitmap_sfu(void)
 		bitmap_info_init(&binfo, i);
 		{
 			ssize_t j;
-			bitmap_t bitmap[bitmap_info_ngroups(&binfo)];
+			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			/* Iteratively set bits starting at the beginning. */
@@ -125,6 +132,7 @@ test_bitmap_sfu(void)
 			}
 			assert(bitmap_sfu(bitmap, &binfo) == i - 1);
 			assert(bitmap_full(bitmap, &binfo));
+			free(bitmap);
 		}
 	}
 }
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:38:28 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:38:28 +0200
Subject: [PATCH 4/7] Use "hardcoded" dependencies instead of having the
	compiler generate them
In-Reply-To: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1335782311-8040-4-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

The main reason is that MSVC doesn't have flags to generate these
dependencies. It is possible to generate them with the output from the
showincludes flag, but it also requires to wrap the compiler, and filter
its output on a message that changes depending on the system locale.

Considering all c files include jemalloc_internal.h, and that this file
includes all others headers, it's just simpler to set dependencies in
stone. The generated dependencies were all the same anyways.
---
 Makefile.in |   18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/Makefile.in b/Makefile.in
index 7685f15..a351a1f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -124,23 +124,22 @@ build_doc_html: $(DOCS_HTML)
 build_doc_man: $(DOCS_MAN3)
 build_doc: $(DOCS)
 
-#
-# Include generated dependency files.
-#
--include $(COBJS:%.$(O)=%.d)
--include $(CPICOBJS:%.$(O)=%.d)
--include $(CTESTOBJS:%.$(O)=%.d)
-
 $(COBJS): $(objroot)src/%.$(O): $(srcroot)src/%.c
 $(CPICOBJS): $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
 $(CPICOBJS): CFLAGS += $(PIC_CFLAGS)
 $(CTESTOBJS): $(objroot)test/%.$(O): $(srcroot)test/%.c
 $(CTESTOBJS): CPPFLAGS += -I$(objroot)test
 
+# Dependencies
+HEADER_DIRS = $(srcroot)include/jemalloc/internal \
+	$(objroot)include/jemalloc $(objroot)include/jemalloc/internal
+HEADERS = $(wildcard $(foreach dir,$(HEADER_DIRS),$(dir)/*.h))
+$(COBJS) $(CPICOBJS) $(CTESTOBJS): $(HEADERS)
+$(CTESTOBJS): $(objroot)test/jemalloc_test.h
+
 $(COBJS) $(CPICOBJS) $(CTESTOBJS): %.$(O):
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
-	@$(CC) -MM $(CPPFLAGS) -MT $@ -o $(@:%.$(O)=%.d) $<
 
 ifneq ($(SOREV),$(SO))
 %.$(SO) : %.$(SOREV)
@@ -250,11 +249,8 @@ check: tests
 clean:
 	rm -f $(COBJS)
 	rm -f $(CPICOBJS)
-	rm -f $(COBJS:%.$(O)=%.d)
-	rm -f $(CPICOBJS:%.$(O)=%.d)
 	rm -f $(CTESTOBJS:%.$(O)=%$(EXE))
 	rm -f $(CTESTOBJS)
-	rm -f $(CTESTOBJS:%.$(O)=%.d)
 	rm -f $(CTESTOBJS:%.$(O)=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:38:25 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:38:25 +0200
Subject: [PATCH 1/7] Remove the VOID macro
Message-ID: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Windows headers define a VOID macro.
---
 src/ctl.c |    8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/src/ctl.c b/src/ctl.c
index 2734604..dddf3be 100644
--- a/src/ctl.c
+++ b/src/ctl.c
@@ -842,11 +842,6 @@ ctl_boot(void)
 	}								\
 } while (0)
 
-#define	VOID()	do {							\
-	READONLY();							\
-	WRITEONLY();							\
-} while (0)
-
 #define	READ(v, t)	do {						\
 	if (oldp != NULL && oldlenp != NULL) {				\
 		if (*oldlenp != sizeof(t)) {				\
@@ -1049,7 +1044,8 @@ thread_tcache_flush_ctl(const size_t *mib, size_t miblen, void *oldp,
 	if (config_tcache == false)
 		return (ENOENT);
 
-	VOID();
+	READONLY();
+	WRITEONLY();
 
 	tcache_flush();
 
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:38:26 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:38:26 +0200
Subject: [PATCH 2/7] Use Get/SetLastError on Win32
In-Reply-To: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1335782311-8040-2-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Using errno on win32 doesn't quite work, because the value set in a shared
library can't be read from e.g. an executable calling the function setting
errno.

At the same time, since buferror always uses errno/GetLastError, don't pass
it.
---
 include/jemalloc/internal/jemalloc_internal.h.in |   12 ++++++++--
 include/jemalloc/internal/util.h                 |   28 +++++++++++++++++++++-
 src/chunk_mmap.c                                 |    4 ++--
 src/huge.c                                       |    2 +-
 src/jemalloc.c                                   |   18 +++++++-------
 src/util.c                                       |   15 ++++++------
 test/aligned_alloc.c                             |   25 ++++++++++---------
 7 files changed, 71 insertions(+), 33 deletions(-)

diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index a364d7a..d4c4b4c 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -1,8 +1,17 @@
 #ifndef JEMALLOC_INTERNAL_H
 #define JEMALLOC_INTERNAL_H
 #include <sys/param.h>
+#include <math.h>
 #ifdef _WIN32
 #  include <windows.h>
+#  define ENOENT ERROR_PATH_NOT_FOUND
+#  define EINVAL ERROR_BAD_ARGUMENTS
+#  define EAGAIN ERROR_OUTOFMEMORY
+#  define EPERM  ERROR_WRITE_FAULT
+#  define EFAULT ERROR_INVALID_ADDRESS
+#  define ENOMEM ERROR_NOT_ENOUGH_MEMORY
+#  undef ERANGE
+#  define ERANGE ERROR_INVALID_DATA
 #else
 #  include <sys/mman.h>
 #  include <sys/syscall.h>
@@ -11,10 +20,10 @@
 #  endif
 #  include <sys/uio.h>
 #  include <pthread.h>
+#  include <errno.h>
 #endif
 #include <sys/types.h>
 
-#include <errno.h>
 #include <limits.h>
 #ifndef SIZE_T_MAX
 #  define SIZE_T_MAX	SIZE_MAX
@@ -34,7 +43,6 @@
 #include <ctype.h>
 #include <unistd.h>
 #include <fcntl.h>
-#include <math.h>
 
 #define	JEMALLOC_NO_DEMANGLE
 #include "../jemalloc at install_suffix@.h"
diff --git a/include/jemalloc/internal/util.h b/include/jemalloc/internal/util.h
index d360ae3..9661c7b 100644
--- a/include/jemalloc/internal/util.h
+++ b/include/jemalloc/internal/util.h
@@ -84,7 +84,7 @@
 
 extern void	(*je_malloc_message)(void *wcbopaque, const char *s);
 
-int	buferror(int errnum, char *buf, size_t buflen);
+int	buferror(char *buf, size_t buflen);
 uintmax_t	malloc_strtoumax(const char *nptr, char **endptr, int base);
 
 /*
@@ -109,6 +109,8 @@ void	malloc_printf(const char *format, ...)
 #ifndef JEMALLOC_ENABLE_INLINE
 size_t	pow2_ceil(size_t x);
 void	malloc_write(const char *s);
+void	set_errno(int errnum);
+int	get_errno(void);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_UTIL_C_))
@@ -140,6 +142,30 @@ malloc_write(const char *s)
 
 	je_malloc_message(NULL, s);
 }
+
+/* Sets error code */
+JEMALLOC_INLINE void
+set_errno(int errnum)
+{
+
+#ifdef _WIN32
+	SetLastError(errnum);
+#else
+	errno = errnum;
+#endif
+}
+
+/* Get last error code */
+JEMALLOC_INLINE int
+get_errno(void)
+{
+
+#ifdef _WIN32
+	return GetLastError();
+#else
+	return errno;
+#endif
+}
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
diff --git a/src/chunk_mmap.c b/src/chunk_mmap.c
index 0ad65a1..9f388d2 100644
--- a/src/chunk_mmap.c
+++ b/src/chunk_mmap.c
@@ -41,7 +41,7 @@ pages_map(void *addr, size_t size)
 		if (munmap(ret, size) == -1) {
 			char buf[BUFERROR_BUF];
 
-			buferror(errno, buf, sizeof(buf));
+			buferror(buf, sizeof(buf));
 			malloc_printf("<jemalloc: Error in munmap(): %s\n",
 			    buf);
 			if (opt_abort)
@@ -67,7 +67,7 @@ pages_unmap(void *addr, size_t size)
 	{
 		char buf[BUFERROR_BUF];
 
-		buferror(errno, buf, sizeof(buf));
+		buferror(buf, sizeof(buf));
 		malloc_printf("<jemalloc>: Error in "
 #ifdef _WIN32
 		              "VirtualFree"
diff --git a/src/huge.c b/src/huge.c
index 23eb074..67b282d 100644
--- a/src/huge.c
+++ b/src/huge.c
@@ -168,7 +168,7 @@ huge_ralloc(void *ptr, size_t oldsize, size_t size, size_t extra,
 			 */
 			char buf[BUFERROR_BUF];
 
-			buferror(errno, buf, sizeof(buf));
+			buferror(buf, sizeof(buf));
 			malloc_printf("<jemalloc>: Error in mremap(): %s\n",
 			    buf);
 			if (opt_abort)
diff --git a/src/jemalloc.c b/src/jemalloc.c
index 52296e0..cae0098 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -472,9 +472,9 @@ malloc_conf_init(void)
 				uintmax_t um;				\
 				char *end;				\
 									\
-				errno = 0;				\
+				set_errno(0);				\
 				um = malloc_strtoumax(v, &end, 0);	\
-				if (errno != 0 || (uintptr_t)end -	\
+				if (get_errno() != 0 || (uintptr_t)end -\
 				    (uintptr_t)v != vlen) {		\
 					malloc_conf_error(		\
 					    "Invalid conf value",	\
@@ -493,9 +493,9 @@ malloc_conf_init(void)
 				long l;					\
 				char *end;				\
 									\
-				errno = 0;				\
+				set_errno(0);				\
 				l = strtol(v, &end, 0);			\
-				if (errno != 0 || (uintptr_t)end -	\
+				if (get_errno() != 0 || (uintptr_t)end -\
 				    (uintptr_t)v != vlen) {		\
 					malloc_conf_error(		\
 					    "Invalid conf value",	\
@@ -831,7 +831,7 @@ label_oom:
 			    "out of memory\n");
 			abort();
 		}
-		errno = ENOMEM;
+		set_errno(ENOMEM);
 	}
 	if (config_prof && opt_prof && ret != NULL)
 		prof_malloc(ret, usize, cnt);
@@ -959,7 +959,7 @@ je_aligned_alloc(size_t alignment, size_t size)
 
 	if ((err = imemalign(&ret, alignment, size, 1)) != 0) {
 		ret = NULL;
-		errno = err;
+		set_errno(err);
 	}
 	JEMALLOC_VALGRIND_MALLOC(err == 0, ret, isalloc(ret, config_prof),
 	    false);
@@ -1029,7 +1029,7 @@ label_return:
 			    "memory\n");
 			abort();
 		}
-		errno = ENOMEM;
+		set_errno(ENOMEM);
 	}
 
 	if (config_prof && opt_prof && ret != NULL)
@@ -1130,7 +1130,7 @@ label_oom:
 				    "out of memory\n");
 				abort();
 			}
-			errno = ENOMEM;
+			set_errno(ENOMEM);
 		}
 	} else {
 		/* realloc(NULL, size) is equivalent to malloc(size). */
@@ -1172,7 +1172,7 @@ label_oom:
 				    "out of memory\n");
 				abort();
 			}
-			errno = ENOMEM;
+			set_errno(ENOMEM);
 		}
 	}
 
diff --git a/src/util.c b/src/util.c
index 2042329..64d53dd 100644
--- a/src/util.c
+++ b/src/util.c
@@ -65,7 +65,7 @@ void	(*je_malloc_message)(void *, const char *s)
  * provide a wrapper.
  */
 int
-buferror(int errnum, char *buf, size_t buflen)
+buferror(char *buf, size_t buflen)
 {
 
 #ifdef _WIN32
@@ -93,7 +93,7 @@ malloc_strtoumax(const char *nptr, char **endptr, int base)
 	const char *p, *ns;
 
 	if (base < 0 || base == 1 || base > 36) {
-		errno = EINVAL;
+		set_errno(EINVAL);
 		return (UINTMAX_MAX);
 	}
 	b = base;
@@ -168,7 +168,7 @@ malloc_strtoumax(const char *nptr, char **endptr, int base)
 		ret += digit;
 		if (ret < pret) {
 			/* Overflow. */
-			errno = ERANGE;
+			set_errno(ERANGE);
 			return (UINTMAX_MAX);
 		}
 		p++;
@@ -416,9 +416,9 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 			case '0': case '1': case '2': case '3': case '4':
 			case '5': case '6': case '7': case '8': case '9': {
 				uintmax_t uwidth;
-				errno = 0;
+				set_errno(0);
 				uwidth = malloc_strtoumax(f, (char **)&f, 10);
-				assert(uwidth != UINTMAX_MAX || errno !=
+				assert(uwidth != UINTMAX_MAX || get_errno() !=
 				    ERANGE);
 				width = (int)uwidth;
 				if (*f == '.') {
@@ -442,9 +442,10 @@ malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 			case '0': case '1': case '2': case '3': case '4':
 			case '5': case '6': case '7': case '8': case '9': {
 				uintmax_t uprec;
-				errno = 0;
+				set_errno(0);
 				uprec = malloc_strtoumax(f, (char **)&f, 10);
-				assert(uprec != UINTMAX_MAX || errno != ERANGE);
+				assert(uprec != UINTMAX_MAX || get_errno() !=
+				    ERANGE);
 				prec = (int)uprec;
 				break;
 			}
diff --git a/test/aligned_alloc.c b/test/aligned_alloc.c
index 81caa0a..5a9b0ca 100644
--- a/test/aligned_alloc.c
+++ b/test/aligned_alloc.c
@@ -17,18 +17,18 @@ main(void)
 
 	/* Test error conditions. */
 	alignment = 0;
-	errno = 0;
+	set_errno(0);
 	p = aligned_alloc(alignment, 1);
-	if (p != NULL || errno != EINVAL) {
+	if (p != NULL || get_errno() != EINVAL) {
 		malloc_printf(
 		    "Expected error for invalid alignment %zu\n", alignment);
 	}
 
 	for (alignment = sizeof(size_t); alignment < MAXALIGN;
 	    alignment <<= 1) {
-		errno = 0;
+		set_errno(0);
 		p = aligned_alloc(alignment + 1, 1);
-		if (p != NULL || errno != EINVAL) {
+		if (p != NULL || get_errno() != EINVAL) {
 			malloc_printf(
 			    "Expected error for invalid alignment %zu\n",
 			    alignment + 1);
@@ -42,9 +42,9 @@ main(void)
 	alignment = 0x80000000LU;
 	size      = 0x80000000LU;
 #endif
-	errno = 0;
+	set_errno(0);
 	p = aligned_alloc(alignment, size);
-	if (p != NULL || errno != ENOMEM) {
+	if (p != NULL || get_errno() != ENOMEM) {
 		malloc_printf(
 		    "Expected error for aligned_alloc(%zu, %zu)\n",
 		    alignment, size);
@@ -57,9 +57,9 @@ main(void)
 	alignment = 0x40000000LU;
 	size      = 0x84000001LU;
 #endif
-	errno = 0;
+	set_errno(0);
 	p = aligned_alloc(alignment, size);
-	if (p != NULL || errno != ENOMEM) {
+	if (p != NULL || get_errno() != ENOMEM) {
 		malloc_printf(
 		    "Expected error for aligned_alloc(%zu, %zu)\n",
 		    alignment, size);
@@ -71,9 +71,9 @@ main(void)
 #else
 	size = 0xfffffff0LU;
 #endif
-	errno = 0;
+	set_errno(0);
 	p = aligned_alloc(alignment, size);
-	if (p != NULL || errno != ENOMEM) {
+	if (p != NULL || get_errno() != ENOMEM) {
 		malloc_printf(
 		    "Expected error for aligned_alloc(&p, %zu, %zu)\n",
 		    alignment, size);
@@ -93,9 +93,12 @@ main(void)
 			for (i = 0; i < NITER; i++) {
 				ps[i] = aligned_alloc(alignment, size);
 				if (ps[i] == NULL) {
+					char buf[BUFERROR_BUF];
+
+					buferror(buf, sizeof(buf));
 					malloc_printf(
 					    "Error for size %zu (%#zx): %s\n",
-					    size, size, strerror(errno));
+					    size, size, buf);
 					exit(1);
 				}
 				total += malloc_usable_size(ps[i]);
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:38:27 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:38:27 +0200
Subject: [PATCH 3/7] Few configure.ac adjustments
In-Reply-To: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1335782311-8040-3-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

- Use the extensions autoconf finds for object and executable files.
- Remove the sorev variable, and replace SOREV definition with sorev's.
- Default to je_ prefix on win32.
---
 bin/jemalloc.sh.in |    2 +-
 configure.ac       |   18 ++++++------------
 2 files changed, 7 insertions(+), 13 deletions(-)

diff --git a/bin/jemalloc.sh.in b/bin/jemalloc.sh.in
index 58683f5..cdf3673 100644
--- a/bin/jemalloc.sh.in
+++ b/bin/jemalloc.sh.in
@@ -4,6 +4,6 @@ prefix=@prefix@
 exec_prefix=@exec_prefix@
 libdir=@libdir@
 
- at LD_PRELOAD_VAR@=${libdir}/libjemalloc. at sorev@
+ at LD_PRELOAD_VAR@=${libdir}/libjemalloc. at SOREV@
 export @LD_PRELOAD_VAR@
 exec "$@"
diff --git a/configure.ac b/configure.ac
index 98211c8..6e74238 100644
--- a/configure.ac
+++ b/configure.ac
@@ -195,14 +195,13 @@ AC_DEFINE_UNQUOTED([CPU_SPINWAIT], [$CPU_SPINWAIT])
 
 LD_PRELOAD_VAR="LD_PRELOAD"
 so="so"
-o="o"
+o="$ac_objext"
 a="a"
-exe=
+exe="$ac_exeext"
 libprefix="lib"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
-SOREV='$(SO).$(REV)'
-sorev="${so}.${rev}"
+SOREV="${so}.${rev}"
 PIC_CFLAGS='-fPIC -DPIC'
 
 dnl Heap profiling uses the log(3) function.
@@ -226,8 +225,7 @@ case "${host}" in
 	so="dylib"
 	force_tls="0"
 	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
-	SOREV='$(REV).$(SO)'
-	sorev="${rev}.${so}"
+	SOREV="${rev}.${so}"
 	;;
   *-*-freebsd*)
 	CFLAGS="$CFLAGS"
@@ -281,12 +279,9 @@ case "${host}" in
 	RPATH=""
 	so="dll"
 	DSO_LDFLAGS="-shared"
-	o="obj"
 	a="lib"
 	libprefix=""
-	exe=".exe"
-	SOREV='$(SO)'
-	sorev="${so}"
+	SOREV="${so}"
 	PIC_CFLAGS=""
 	;;
   *)
@@ -304,7 +299,6 @@ AC_SUBST([exe])
 AC_SUBST([libprefix])
 AC_SUBST([DSO_LDFLAGS])
 AC_SUBST([SOREV])
-AC_SUBST([sorev])
 AC_SUBST([PIC_CFLAGS])
 
 JE_COMPILABLE([__attribute__ syntax],
@@ -419,7 +413,7 @@ dnl Do not prefix public APIs by default.
 AC_ARG_WITH([jemalloc_prefix],
   [AS_HELP_STRING([--with-jemalloc-prefix=<prefix>], [Prefix to prepend to all public APIs])],
   [JEMALLOC_PREFIX="$with_jemalloc_prefix"],
-  [if test "x$abi" != "xmacho" ; then
+  [if test "x$abi" != "xmacho" -a "x$abi" != "xpecoff"; then
   JEMALLOC_PREFIX=""
 else
   JEMALLOC_PREFIX="je_"
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:38:31 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:38:31 +0200
Subject: [PATCH 7/7] Add support for MSVC
In-Reply-To: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1335782311-8040-7-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Tested with MSVC 8 32 and 64 bits.
---
 Makefile.in                                      |   21 +++++++--
 configure.ac                                     |   54 ++++++++++++++++++++--
 include/compat/stdbool.h                         |   16 +++++++
 include/compat/strings.h                         |   22 +++++++++
 include/jemalloc/internal/atomic.h               |   24 ++++++++++
 include/jemalloc/internal/jemalloc_internal.h.in |   23 +++++++--
 include/jemalloc/jemalloc_defs.h.in              |   10 ++++
 src/jemalloc.c                                   |   11 ++++-
 src/tsd.c                                        |    8 ++++
 9 files changed, 173 insertions(+), 16 deletions(-)
 create mode 100644 include/compat/stdbool.h
 create mode 100644 include/compat/strings.h

diff --git a/Makefile.in b/Makefile.in
index a351a1f..08541a7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -26,9 +26,11 @@ abs_objroot := @abs_objroot@
 CPPFLAGS := @CPPFLAGS@ -I$(srcroot)include -I$(objroot)include
 CFLAGS := @CFLAGS@
 LDFLAGS := @LDFLAGS@
+EXTRA_LDFLAGS := @EXTRA_LDFLAGS@
 LIBS := @LIBS@
 RPATH_EXTRA := @RPATH_EXTRA@
 SO := @so@
+IMPORTLIB := @importlib@
 O := @o@
 A := @a@
 EXE := @exe@
@@ -49,6 +51,9 @@ enable_experimental := @enable_experimental@
 DSO_LDFLAGS = @DSO_LDFLAGS@
 SOREV = @SOREV@
 PIC_CFLAGS = @PIC_CFLAGS@
+CTARGET = @CTARGET@
+LDTARGET = @LDTARGET@
+MKLIB = @MKLIB@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH="$(objroot)lib"
@@ -77,9 +82,13 @@ CSRCS := $(srcroot)src/jemalloc.c $(srcroot)src/arena.c $(srcroot)src/atomic.c \
 ifeq (macho, $(ABI))
 CSRCS += $(srcroot)src/zone.c
 endif
+ifeq ($(IMPORTLIB),$(SO))
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
+endif
 ifdef PIC_CFLAGS
 STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_pic.$(A)
+else
+STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_s.$(A)
 endif
 DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SOREV)
 ifneq ($(SOREV),$(SO))
@@ -129,6 +138,9 @@ $(CPICOBJS): $(objroot)src/%.pic.$(O): $(srcroot)src/%.c
 $(CPICOBJS): CFLAGS += $(PIC_CFLAGS)
 $(CTESTOBJS): $(objroot)test/%.$(O): $(srcroot)test/%.c
 $(CTESTOBJS): CPPFLAGS += -I$(objroot)test
+ifneq ($(IMPORTLIB),$(SO))
+$(COBJS): CPPFLAGS += -DDLLEXPORT
+endif
 
 # Dependencies
 HEADER_DIRS = $(srcroot)include/jemalloc/internal \
@@ -139,7 +151,7 @@ $(CTESTOBJS): $(objroot)test/jemalloc_test.h
 
 $(COBJS) $(CPICOBJS) $(CTESTOBJS): %.$(O):
 	@mkdir -p $(@D)
-	$(CC) $(CFLAGS) -c $(CPPFLAGS) -o $@ $<
+	$(CC) $(CFLAGS) -c $(CPPFLAGS) $(CTARGET) $<
 
 ifneq ($(SOREV),$(SO))
 %.$(SO) : %.$(SOREV)
@@ -149,20 +161,21 @@ endif
 
 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) : $(if $(PIC_CFLAGS),$(CPICOBJS),$(COBJS))
 	@mkdir -p $(@D)
-	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) -o $@ $+ $(LDFLAGS) $(LIBS)
+	$(CC) $(DSO_LDFLAGS) $(call RPATH,$(RPATH_EXTRA)) $(LDTARGET) $+ $(LDFLAGS) $(LIBS) $(EXTRA_LDFLAGS)
 
 $(objroot)lib/$(LIBJEMALLOC)_pic.$(A) : $(CPICOBJS)
 $(objroot)lib/$(LIBJEMALLOC).$(A) : $(COBJS)
+$(objroot)lib/$(LIBJEMALLOC)_s.$(A) : $(COBJS)
 
 $(STATIC_LIBS):
 	@mkdir -p $(@D)
-	ar crus $@ $+
+	$(MKLIB) $+
 
 $(objroot)test/bitmap$(EXE): $(objroot)src/bitmap.$(O)
 
 $(objroot)test/%$(EXE): $(objroot)test/%.$(O) $(objroot)src/util.$(O) $(DSOS)
 	@mkdir -p $(@D)
-	$(CC) -o $@ $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) -L$(objroot)lib -ljemalloc$(install_suffix) $(filter -lpthread,$(LIBS))
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(filter -lpthread,$(LIBS)) $(EXTRA_LDFLAGS)
 
 build_lib_shared: $(DSOS)
 build_lib_static: $(STATIC_LIBS)
diff --git a/configure.ac b/configure.ac
index 6e74238..500e21c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -111,6 +111,19 @@ dnl If CFLAGS isn't defined, set CFLAGS to something reasonable.  Otherwise,
 dnl just prevent autoconf from molesting CFLAGS.
 CFLAGS=$CFLAGS
 AC_PROG_CC
+if test "x$GCC" != "xyes" ; then
+  AC_CACHE_CHECK([whether compiler is MSVC],
+                 [je_cv_msvc],
+                 [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],
+                                                     [
+#ifndef _MSC_VER
+  int fail[-1];
+#endif
+])],
+                               [je_cv_msvc=yes],
+                               [je_cv_msvc=no])])
+fi
+
 if test "x$CFLAGS" = "x" ; then
   no_CFLAGS="yes"
   if test "x$GCC" = "xyes" ; then
@@ -118,6 +131,12 @@ if test "x$CFLAGS" = "x" ; then
     JE_CFLAGS_APPEND([-Wall])
     JE_CFLAGS_APPEND([-pipe])
     JE_CFLAGS_APPEND([-g3])
+  elif test "x$je_cv_msvc" = "xyes" ; then
+    CC="$CC -nologo"
+    JE_CFLAGS_APPEND([-Zi])
+    JE_CFLAGS_APPEND([-MT])
+    JE_CFLAGS_APPEND([-W3])
+    CPPFLAGS="$CPPFLAGS -I${srcroot}/include/compat"
   fi
 fi
 dnl Append EXTRA_CFLAGS to CFLAGS, if defined.
@@ -195,6 +214,7 @@ AC_DEFINE_UNQUOTED([CPU_SPINWAIT], [$CPU_SPINWAIT])
 
 LD_PRELOAD_VAR="LD_PRELOAD"
 so="so"
+importlib="${so}"
 o="$ac_objext"
 a="a"
 exe="$ac_exeext"
@@ -203,9 +223,10 @@ DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
 SOREV="${so}.${rev}"
 PIC_CFLAGS='-fPIC -DPIC'
-
-dnl Heap profiling uses the log(3) function.
-LIBS="$LIBS -lm"
+CTARGET='-o $@'
+LDTARGET='-o $@'
+EXTRA_LDFLAGS=
+MKLIB='ar crus $@'
 
 dnl Platform-specific settings.  abi and RPATH can probably be determined
 dnl programmatically, but doing so is error-prone, which makes it generally
@@ -223,6 +244,7 @@ case "${host}" in
 	RPATH=""
 	LD_PRELOAD_VAR="DYLD_INSERT_LIBRARIES"
 	so="dylib"
+	importlib="${so}"
 	force_tls="0"
 	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
 	SOREV="${rev}.${so}"
@@ -278,7 +300,17 @@ case "${host}" in
 	force_tls="0"
 	RPATH=""
 	so="dll"
-	DSO_LDFLAGS="-shared"
+	if test "x$je_cv_msvc" = "xyes" ; then
+	  importlib="lib"
+	  DSO_LDFLAGS="-LD"
+	  EXTRA_LDFLAGS="-link -DEBUG"
+	  CTARGET='-Fo$@'
+	  LDTARGET='-Fe$@'
+	  MKLIB='lib -nologo -out:$@'
+        else
+	  importlib="${so}"
+	  DSO_LDFLAGS="-shared"
+	fi
 	a="lib"
 	libprefix=""
 	SOREV="${so}"
@@ -293,13 +325,23 @@ AC_SUBST([abi])
 AC_SUBST([RPATH])
 AC_SUBST([LD_PRELOAD_VAR])
 AC_SUBST([so])
+AC_SUBST([importlib])
 AC_SUBST([o])
 AC_SUBST([a])
 AC_SUBST([exe])
 AC_SUBST([libprefix])
 AC_SUBST([DSO_LDFLAGS])
+AC_SUBST([EXTRA_LDFLAGS])
 AC_SUBST([SOREV])
 AC_SUBST([PIC_CFLAGS])
+AC_SUBST([CTARGET])
+AC_SUBST([LDTARGET])
+AC_SUBST([MKLIB])
+
+if test "x$abi" != "xpecoff"; then
+  dnl Heap profiling uses the log(3) function.
+  LIBS="$LIBS -lm"
+fi
 
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
@@ -530,6 +572,8 @@ if test "x$enable_debug" = "x0" -a "x$no_CFLAGS" = "xyes" ; then
     if test "x$GCC" = "xyes" ; then
       JE_CFLAGS_APPEND([-O3])
       JE_CFLAGS_APPEND([-funroll-loops])
+    elif test "x$je_cv_msvc" = "xyes" ; then
+      JE_CFLAGS_APPEND([-O2])
     else
       JE_CFLAGS_APPEND([-O])
     fi
@@ -833,11 +877,11 @@ AC_CACHE_CHECK([STATIC_PAGE_SHIFT],
                [je_cv_static_page_shift],
                AC_RUN_IFELSE([AC_LANG_PROGRAM(
 [[
+#include <strings.h>
 #ifdef _WIN32
 #include <windows.h>
 #else
 #include <unistd.h>
-#include <strings.h>
 #endif
 #include <stdio.h>
 ]],
diff --git a/include/compat/stdbool.h b/include/compat/stdbool.h
new file mode 100644
index 0000000..da9ee8b
--- /dev/null
+++ b/include/compat/stdbool.h
@@ -0,0 +1,16 @@
+#ifndef stdbool_h
+#define stdbool_h
+
+#include <wtypes.h>
+
+/* MSVC doesn't define _Bool or bool in C, but does have BOOL */
+/* Note this doesn't pass autoconf's test because (bool) 0.5 != true */
+typedef BOOL _Bool;
+
+#define bool _Bool
+#define true 1
+#define false 0
+
+#define __bool_true_false_are_defined 1
+
+#endif /* stdbool_h */
diff --git a/include/compat/strings.h b/include/compat/strings.h
new file mode 100644
index 0000000..6ad8039
--- /dev/null
+++ b/include/compat/strings.h
@@ -0,0 +1,22 @@
+#ifndef strings_h
+#define strings_h
+
+/* MSVC doesn't define ffs/ffsl. This dummy strings.h header is provided
+ * for both */
+#include <intrin.h>
+#pragma intrinsic(_BitScanForward)
+static __forceinline int ffsl(long x)
+{
+	unsigned long i;
+
+	if (_BitScanForward(&i, x))
+		return (i + 1);
+	return (0);
+}
+
+static __forceinline int ffs(int x)
+{
+	return ffsl(x);
+}
+
+#endif
diff --git a/include/jemalloc/internal/atomic.h b/include/jemalloc/internal/atomic.h
index 016c472..4b6f623 100644
--- a/include/jemalloc/internal/atomic.h
+++ b/include/jemalloc/internal/atomic.h
@@ -47,6 +47,18 @@ atomic_sub_uint64(uint64_t *p, uint64_t x)
 
 	return (__sync_sub_and_fetch(p, x));
 }
+#elif (defined(_MSC_VER))
+JEMALLOC_INLINE uint64_t
+atomic_add_uint64(uint64_t *p, uint64_t x)
+{
+       return InterlockedExchangeAdd64(p, x);
+}
+
+JEMALLOC_INLINE uint64_t
+atomic_sub_uint64(uint64_t *p, uint64_t x)
+{
+       return InterlockedExchangeAdd64(p, -x);
+}
 #elif (defined(JEMALLOC_OSATOMIC))
 JEMALLOC_INLINE uint64_t
 atomic_add_uint64(uint64_t *p, uint64_t x)
@@ -145,6 +157,18 @@ atomic_sub_uint32(uint32_t *p, uint32_t x)
 
 	return (__sync_sub_and_fetch(p, x));
 }
+#elif (defined(_MSC_VER))
+JEMALLOC_INLINE uint32_t
+atomic_add_uint32(uint32_t *p, uint32_t x)
+{
+       return InterlockedExchangeAdd(p, x);
+}
+
+JEMALLOC_INLINE uint32_t
+atomic_sub_uint32(uint32_t *p, uint32_t x)
+{
+       return InterlockedExchangeAdd(p, -x);
+}
 #elif (defined(JEMALLOC_OSATOMIC))
 JEMALLOC_INLINE uint32_t
 atomic_add_uint32(uint32_t *p, uint32_t x)
diff --git a/include/jemalloc/internal/jemalloc_internal.h.in b/include/jemalloc/internal/jemalloc_internal.h.in
index d4c4b4c..97c1794 100644
--- a/include/jemalloc/internal/jemalloc_internal.h.in
+++ b/include/jemalloc/internal/jemalloc_internal.h.in
@@ -1,6 +1,5 @@
 #ifndef JEMALLOC_INTERNAL_H
 #define JEMALLOC_INTERNAL_H
-#include <sys/param.h>
 #include <math.h>
 #ifdef _WIN32
 #  include <windows.h>
@@ -13,6 +12,7 @@
 #  undef ERANGE
 #  define ERANGE ERROR_INVALID_DATA
 #else
+#  include <sys/param.h>
 #  include <sys/mman.h>
 #  include <sys/syscall.h>
 #  if !defined(SYS_write) && defined(__NR_write)
@@ -41,7 +41,17 @@
 #include <string.h>
 #include <strings.h>
 #include <ctype.h>
-#include <unistd.h>
+#ifdef _MSC_VER
+#  include <io.h>
+typedef intptr_t ssize_t;
+#  define PATH_MAX 1024
+#  define STDERR_FILENO 2
+#  define __func__ __FUNCTION__
+/* Disable warnings about deprecated system functions */
+#  pragma warning(disable: 4996)
+#else
+#  include <unistd.h>
+#endif
 #include <fcntl.h>
 
 #define	JEMALLOC_NO_DEMANGLE
@@ -221,6 +231,9 @@ static const bool config_ivsalloc =
 #else
 #  define JEMALLOC_ENABLE_INLINE
 #  define JEMALLOC_INLINE static inline
+#  ifdef _MSC_VER
+#    define inline _inline
+#  endif
 #endif
 
 /* Smallest size class to support. */
@@ -232,7 +245,7 @@ static const bool config_ivsalloc =
  * classes).
  */
 #ifndef LG_QUANTUM
-#  ifdef __i386__
+#  if (defined(__i386__) || defined(_M_IX86))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __ia64__
@@ -244,7 +257,7 @@ static const bool config_ivsalloc =
 #  ifdef __sparc64__
 #    define LG_QUANTUM		4
 #  endif
-#  if (defined(__amd64__) || defined(__x86_64__))
+#  if (defined(__amd64__) || defined(__x86_64__) || defined(_M_X64))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __arm__
@@ -296,7 +309,7 @@ static const bool config_ivsalloc =
  * In addition, this controls the spacing of cacheline-spaced size classes.
  */
 #define	LG_CACHELINE		6
-#define	CACHELINE		((size_t)(1U << LG_CACHELINE))
+#define	CACHELINE		64
 #define	CACHELINE_MASK		(CACHELINE - 1)
 
 /* Return the smallest cacheline multiple that is >= s. */
diff --git a/include/jemalloc/jemalloc_defs.h.in b/include/jemalloc/jemalloc_defs.h.in
index 3e1f047..f110ed3 100644
--- a/include/jemalloc/jemalloc_defs.h.in
+++ b/include/jemalloc/jemalloc_defs.h.in
@@ -109,6 +109,16 @@
 #  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
 #  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
 #  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
+#elif _MSC_VER
+#  define JEMALLOC_ATTR(s)
+#ifdef DLLEXPORT
+#  define EXPORT __declspec(dllexport)
+#else
+#  define EXPORT __declspec(dllimport)
+#endif
+#  define JEMALLOC_ALIGNED(s) __declspec(align(s))
+#  define JEMALLOC_SECTION(s) __declspec(allocate(s))
+#  define JEMALLOC_NOINLINE __declspec(noinline)
 #else
 #  define JEMALLOC_ATTR(s)
 #  define EXPORT
diff --git a/src/jemalloc.c b/src/jemalloc.c
index fa24b05..40c775d 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -56,12 +56,19 @@ static bool			malloc_initializer = NO_INITIALIZER;
 static malloc_mutex_t	init_lock;
 
 JEMALLOC_ATTR(constructor)
-static void
-init_init_lock()
+static void WINAPI
+_init_init_lock(void)
 {
 
 	malloc_mutex_init(&init_lock);
 }
+
+#ifdef _MSC_VER
+#  pragma section(".CRT$XCU", read)
+JEMALLOC_SECTION(".CRT$XCU") JEMALLOC_ATTR(used)
+static const void (WINAPI *init_init_lock)(void) = _init_init_lock;
+#endif
+
 #else
 static malloc_mutex_t	init_lock = MALLOC_MUTEX_INITIALIZER;
 #endif
diff --git a/src/tsd.c b/src/tsd.c
index cee57c9..84492b3 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -93,6 +93,14 @@ _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 	return (true);
 }
 
+#ifdef _MSC_VER
+#  ifdef _M_IX86
+#    pragma comment(linker, "/INCLUDE:__tls_used")
+#  else
+#    pragma comment(linker, "/INCLUDE:_tls_used")
+#  endif
+#  pragma section(".CRT$XLY",long,read)
+#endif
 JEMALLOC_SECTION(".CRT$XLY") JEMALLOC_ATTR(used)
 static const BOOL	(WINAPI *tls_callback)(HINSTANCE hinstDLL,
     DWORD fdwReason, LPVOID lpvReserved) = _tls_callback;
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:38:29 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:38:29 +0200
Subject: [PATCH 5/7] Replace JEMALLOC_ATTR with various different macros when
	it makes sense
In-Reply-To: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1335782311-8040-5-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

Theses newly added macros will be used to implement the equivalent under
MSVC. Also, move the definitions to headers, where they make more sense,
and for some, are even more useful there (e.g. malloc).
---
 include/jemalloc/internal/util.h    |    2 --
 include/jemalloc/jemalloc.h.in      |   36 +++++++++++++--------------
 include/jemalloc/jemalloc_defs.h.in |   14 ++++++++---
 src/arena.c                         |    2 +-
 src/jemalloc.c                      |   47 ++++++-----------------------------
 src/mutex.c                         |    3 +--
 src/tsd.c                           |    6 +++--
 src/util.c                          |    6 ++---
 8 files changed, 43 insertions(+), 73 deletions(-)

diff --git a/include/jemalloc/internal/util.h b/include/jemalloc/internal/util.h
index 9661c7b..ffa078f 100644
--- a/include/jemalloc/internal/util.h
+++ b/include/jemalloc/internal/util.h
@@ -82,8 +82,6 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-extern void	(*je_malloc_message)(void *wcbopaque, const char *s);
-
 int	buferror(char *buf, size_t buflen);
 uintmax_t	malloc_strtoumax(const char *nptr, char **endptr, int base);
 
diff --git a/include/jemalloc/jemalloc.h.in b/include/jemalloc/jemalloc.h.in
index f0581db..055bb48 100644
--- a/include/jemalloc/jemalloc.h.in
+++ b/include/jemalloc/jemalloc.h.in
@@ -36,35 +36,35 @@ extern "C" {
  * namespace management, and should be omitted in application code unless
  * JEMALLOC_NO_DEMANGLE is defined (see below).
  */
-extern const char	*je_malloc_conf;
-extern void		(*je_malloc_message)(void *, const char *);
+extern EXPORT const char	*je_malloc_conf;
+extern EXPORT void		(*je_malloc_message)(void *, const char *);
 
-void	*je_malloc(size_t size) JEMALLOC_ATTR(malloc);
-void	*je_calloc(size_t num, size_t size) JEMALLOC_ATTR(malloc);
-int	je_posix_memalign(void **memptr, size_t alignment, size_t size)
+EXPORT void	*je_malloc(size_t size) JEMALLOC_ATTR(malloc);
+EXPORT void	*je_calloc(size_t num, size_t size) JEMALLOC_ATTR(malloc);
+EXPORT int	je_posix_memalign(void **memptr, size_t alignment, size_t size)
     JEMALLOC_ATTR(nonnull(1));
-void	*je_aligned_alloc(size_t alignment, size_t size) JEMALLOC_ATTR(malloc);
-void	*je_realloc(void *ptr, size_t size);
-void	je_free(void *ptr);
+EXPORT void	*je_aligned_alloc(size_t alignment, size_t size) JEMALLOC_ATTR(malloc);
+EXPORT void	*je_realloc(void *ptr, size_t size);
+EXPORT void	je_free(void *ptr);
 
-size_t	je_malloc_usable_size(const void *ptr);
-void	je_malloc_stats_print(void (*write_cb)(void *, const char *),
+EXPORT size_t	je_malloc_usable_size(const void *ptr);
+EXPORT void	je_malloc_stats_print(void (*write_cb)(void *, const char *),
     void *je_cbopaque, const char *opts);
-int	je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
+EXPORT int	je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
     size_t newlen);
-int	je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp);
-int	je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp,
+EXPORT int	je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp);
+EXPORT int	je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen);
 
 #ifdef JEMALLOC_EXPERIMENTAL
-int	je_allocm(void **ptr, size_t *rsize, size_t size, int flags)
+EXPORT int	je_allocm(void **ptr, size_t *rsize, size_t size, int flags)
     JEMALLOC_ATTR(nonnull(1));
-int	je_rallocm(void **ptr, size_t *rsize, size_t size, size_t extra,
+EXPORT int	je_rallocm(void **ptr, size_t *rsize, size_t size, size_t extra,
     int flags) JEMALLOC_ATTR(nonnull(1));
-int	je_sallocm(const void *ptr, size_t *rsize, int flags)
+EXPORT int	je_sallocm(const void *ptr, size_t *rsize, int flags)
     JEMALLOC_ATTR(nonnull(1));
-int	je_dallocm(void *ptr, int flags) JEMALLOC_ATTR(nonnull(1));
-int	je_nallocm(size_t *rsize, size_t size, int flags);
+EXPORT int	je_dallocm(void *ptr, int flags) JEMALLOC_ATTR(nonnull(1));
+EXPORT int	je_nallocm(size_t *rsize, size_t size, int flags);
 #endif
 
 /*
diff --git a/include/jemalloc/jemalloc_defs.h.in b/include/jemalloc/jemalloc_defs.h.in
index 6e81655..3e1f047 100644
--- a/include/jemalloc/jemalloc_defs.h.in
+++ b/include/jemalloc/jemalloc_defs.h.in
@@ -104,11 +104,17 @@
 /* Defined if __attribute__((...)) syntax is supported. */
 #undef JEMALLOC_HAVE_ATTR
 #ifdef JEMALLOC_HAVE_ATTR
-#  define JEMALLOC_CATTR(s, a) __attribute__((s))
-#  define JEMALLOC_ATTR(s) JEMALLOC_CATTR(s,)
+#  define JEMALLOC_ATTR(s) __attribute__((s))
+#  define EXPORT JEMALLOC_ATTR(visibility("default"))
+#  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
+#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
 #else
-#  define JEMALLOC_CATTR(s, a) a
-#  define JEMALLOC_ATTR(s) JEMALLOC_CATTR(s,)
+#  define JEMALLOC_ATTR(s)
+#  define EXPORT
+#  define JEMALLOC_ALIGNED(s)
+#  define JEMALLOC_SECTION(s)
+#  define JEMALLOC_NOINLINE
 #endif
 
 /* Defined if sbrk() is supported. */
diff --git a/src/arena.c b/src/arena.c
index 7fac361..51c268c 100644
--- a/src/arena.c
+++ b/src/arena.c
@@ -7,7 +7,7 @@
 ssize_t		opt_lg_dirty_mult = LG_DIRTY_MULT_DEFAULT;
 arena_bin_info_t	arena_bin_info[NBINS];
 
-JEMALLOC_ATTR(aligned(CACHELINE))
+JEMALLOC_ALIGNED(CACHELINE)
 const uint8_t	small_size2bin[] = {
 #define	S2B_8(i)	i,
 #define	S2B_16(i)	S2B_8(i) S2B_8(i)
diff --git a/src/jemalloc.c b/src/jemalloc.c
index cae0098..fa24b05 100644
--- a/src/jemalloc.c
+++ b/src/jemalloc.c
@@ -9,7 +9,7 @@ malloc_tsd_data(, thread_allocated, thread_allocated_t,
     THREAD_ALLOCATED_INITIALIZER)
 
 /* Runtime configuration options. */
-const char	*je_malloc_conf JEMALLOC_ATTR(visibility("default"));
+const char	*je_malloc_conf;
 #ifdef JEMALLOC_DEBUG
 bool	opt_abort = true;
 #  ifdef JEMALLOC_FILL
@@ -787,8 +787,6 @@ malloc_init_hard(void)
  * Begin malloc(3)-compatible functions.
  */
 
-JEMALLOC_ATTR(malloc)
-JEMALLOC_ATTR(visibility("default"))
 void *
 je_malloc(size_t size)
 {
@@ -938,8 +936,6 @@ label_return:
 	return (ret);
 }
 
-JEMALLOC_ATTR(nonnull(1))
-JEMALLOC_ATTR(visibility("default"))
 int
 je_posix_memalign(void **memptr, size_t alignment, size_t size)
 {
@@ -949,8 +945,6 @@ je_posix_memalign(void **memptr, size_t alignment, size_t size)
 	return (ret);
 }
 
-JEMALLOC_ATTR(malloc)
-JEMALLOC_ATTR(visibility("default"))
 void *
 je_aligned_alloc(size_t alignment, size_t size)
 {
@@ -966,8 +960,6 @@ je_aligned_alloc(size_t alignment, size_t size)
 	return (ret);
 }
 
-JEMALLOC_ATTR(malloc)
-JEMALLOC_ATTR(visibility("default"))
 void *
 je_calloc(size_t num, size_t size)
 {
@@ -1043,7 +1035,6 @@ label_return:
 	return (ret);
 }
 
-JEMALLOC_ATTR(visibility("default"))
 void *
 je_realloc(void *ptr, size_t size)
 {
@@ -1191,7 +1182,6 @@ label_return:
 	return (ret);
 }
 
-JEMALLOC_ATTR(visibility("default"))
 void
 je_free(void *ptr)
 {
@@ -1226,8 +1216,6 @@ je_free(void *ptr)
  */
 
 #ifdef JEMALLOC_OVERRIDE_MEMALIGN
-JEMALLOC_ATTR(malloc)
-JEMALLOC_ATTR(visibility("default"))
 void *
 je_memalign(size_t alignment, size_t size)
 {
@@ -1239,8 +1227,6 @@ je_memalign(size_t alignment, size_t size)
 #endif
 
 #ifdef JEMALLOC_OVERRIDE_VALLOC
-JEMALLOC_ATTR(malloc)
-JEMALLOC_ATTR(visibility("default"))
 void *
 je_valloc(size_t size)
 {
@@ -1269,16 +1255,13 @@ je_valloc(size_t size)
  * passed an extra argument for the caller return address, which will be
  * ignored.
  */
-JEMALLOC_ATTR(visibility("default"))
-void (* const __free_hook)(void *ptr) = je_free;
+EXPORT void (* const __free_hook)(void *ptr) = je_free;
 
-JEMALLOC_ATTR(visibility("default"))
-void *(* const __malloc_hook)(size_t size) = je_malloc;
+EXPORT void *(* const __malloc_hook)(size_t size) = je_malloc;
 
-JEMALLOC_ATTR(visibility("default"))
-void *(* const __realloc_hook)(void *ptr, size_t size) = je_realloc;
+EXPORT void *(* const __realloc_hook)(void *ptr, size_t size) = je_realloc;
 
-JEMALLOC_ATTR(visibility("default"))
+EXPORT
 void *(* const __memalign_hook)(size_t alignment, size_t size) = je_memalign;
 #endif
 
@@ -1290,7 +1273,6 @@ void *(* const __memalign_hook)(size_t alignment, size_t size) = je_memalign;
  * Begin non-standard functions.
  */
 
-JEMALLOC_ATTR(visibility("default"))
 size_t
 je_malloc_usable_size(const void *ptr)
 {
@@ -1306,7 +1288,6 @@ je_malloc_usable_size(const void *ptr)
 	return (ret);
 }
 
-JEMALLOC_ATTR(visibility("default"))
 void
 je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *opts)
@@ -1315,7 +1296,6 @@ je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
 	stats_print(write_cb, cbopaque, opts);
 }
 
-JEMALLOC_ATTR(visibility("default"))
 int
 je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
     size_t newlen)
@@ -1327,7 +1307,6 @@ je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
 	return (ctl_byname(name, oldp, oldlenp, newp, newlen));
 }
 
-JEMALLOC_ATTR(visibility("default"))
 int
 je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp)
 {
@@ -1338,7 +1317,6 @@ je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp)
 	return (ctl_nametomib(name, mibp, miblenp));
 }
 
-JEMALLOC_ATTR(visibility("default"))
 int
 je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
   void *newp, size_t newlen)
@@ -1374,8 +1352,6 @@ iallocm(size_t usize, size_t alignment, bool zero)
 		return (imalloc(usize));
 }
 
-JEMALLOC_ATTR(nonnull(1))
-JEMALLOC_ATTR(visibility("default"))
 int
 je_allocm(void **ptr, size_t *rsize, size_t size, int flags)
 {
@@ -1444,8 +1420,6 @@ label_oom:
 	return (ALLOCM_ERR_OOM);
 }
 
-JEMALLOC_ATTR(nonnull(1))
-JEMALLOC_ATTR(visibility("default"))
 int
 je_rallocm(void **ptr, size_t *rsize, size_t size, size_t extra, int flags)
 {
@@ -1555,8 +1529,6 @@ label_oom:
 	return (ALLOCM_ERR_OOM);
 }
 
-JEMALLOC_ATTR(nonnull(1))
-JEMALLOC_ATTR(visibility("default"))
 int
 je_sallocm(const void *ptr, size_t *rsize, int flags)
 {
@@ -1576,8 +1548,6 @@ je_sallocm(const void *ptr, size_t *rsize, int flags)
 	return (ALLOCM_SUCCESS);
 }
 
-JEMALLOC_ATTR(nonnull(1))
-JEMALLOC_ATTR(visibility("default"))
 int
 je_dallocm(void *ptr, int flags)
 {
@@ -1605,7 +1575,6 @@ je_dallocm(void *ptr, int flags)
 	return (ALLOCM_SUCCESS);
 }
 
-JEMALLOC_ATTR(visibility("default"))
 int
 je_nallocm(size_t *rsize, size_t size, int flags)
 {
@@ -1641,8 +1610,7 @@ je_nallocm(size_t *rsize, size_t size, int flags)
 void
 jemalloc_prefork(void)
 #else
-JEMALLOC_ATTR(visibility("default"))
-void
+EXPORT void
 _malloc_prefork(void)
 #endif
 {
@@ -1663,8 +1631,7 @@ _malloc_prefork(void)
 void
 jemalloc_postfork_parent(void)
 #else
-JEMALLOC_ATTR(visibility("default"))
-void
+EXPORT void
 _malloc_postfork(void)
 #endif
 {
diff --git a/src/mutex.c b/src/mutex.c
index 159d82a..0019c1a 100644
--- a/src/mutex.c
+++ b/src/mutex.c
@@ -48,8 +48,7 @@ pthread_create_once(void)
 	isthreaded = true;
 }
 
-JEMALLOC_ATTR(visibility("default"))
-int
+EXPORT int
 pthread_create(pthread_t *__restrict thread,
     const pthread_attr_t *__restrict attr, void *(*start_routine)(void *),
     void *__restrict arg)
diff --git a/src/tsd.c b/src/tsd.c
index d7714b0..cee57c9 100644
--- a/src/tsd.c
+++ b/src/tsd.c
@@ -32,7 +32,9 @@ malloc_tsd_no_cleanup(void *arg)
 }
 
 #if defined(JEMALLOC_MALLOC_THREAD_CLEANUP) || defined(_WIN32)
-JEMALLOC_ATTR(visibility("default"))
+#ifndef _WIN32
+EXPORT
+#endif
 void
 _malloc_thread_cleanup(void)
 {
@@ -91,7 +93,7 @@ _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 	return (true);
 }
 
-JEMALLOC_ATTR(section(".CRT$XLY")) JEMALLOC_ATTR(used)
+JEMALLOC_SECTION(".CRT$XLY") JEMALLOC_ATTR(used)
 static const BOOL	(WINAPI *tls_callback)(HINSTANCE hinstDLL,
     DWORD fdwReason, LPVOID lpvReserved) = _tls_callback;
 #endif
diff --git a/src/util.c b/src/util.c
index 64d53dd..56e79cf 100644
--- a/src/util.c
+++ b/src/util.c
@@ -40,8 +40,7 @@ static char	*x2s(uintmax_t x, bool alt_form, bool uppercase, char *s,
 /******************************************************************************/
 
 /* malloc_message() setup. */
-JEMALLOC_CATTR(visibility("hidden"), static)
-void
+static void
 wrtmessage(void *cbopaque, const char *s)
 {
 
@@ -57,8 +56,7 @@ wrtmessage(void *cbopaque, const char *s)
 #endif
 }
 
-void	(*je_malloc_message)(void *, const char *s)
-    JEMALLOC_ATTR(visibility("default")) = wrtmessage;
+EXPORT void	(*je_malloc_message)(void *, const char *s) = wrtmessage;
 
 /*
  * glibc provides a non-standard strerror_r() when _GNU_SOURCE is defined, so
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:38:30 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:38:30 +0200
Subject: [PATCH 6/7] Import msinttypes
In-Reply-To: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <1335782311-8040-6-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

http://code.google.com/p/msinttypes/
---
 include/compat/inttypes.h |  305 +++++++++++++++++++++++++++++++++++++++++++++
 include/compat/stdint.h   |  247 ++++++++++++++++++++++++++++++++++++
 2 files changed, 552 insertions(+)
 create mode 100644 include/compat/inttypes.h
 create mode 100644 include/compat/stdint.h

diff --git a/include/compat/inttypes.h b/include/compat/inttypes.h
new file mode 100644
index 0000000..2554277
--- /dev/null
+++ b/include/compat/inttypes.h
@@ -0,0 +1,305 @@
+// ISO C9x  compliant inttypes.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
+// 
+//  Copyright (c) 2006 Alexander Chemeris
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+// 
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+// 
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_INTTYPES_H_ // [
+#define _MSC_INTTYPES_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include "stdint.h"
+
+// 7.8 Format conversion of integer types
+
+typedef struct {
+   intmax_t quot;
+   intmax_t rem;
+} imaxdiv_t;
+
+// 7.8.1 Macros for format specifiers
+
+#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) // [   See footnote 185 at page 198
+
+// The fprintf macros for signed integers are:
+#define PRId8       "d"
+#define PRIi8       "i"
+#define PRIdLEAST8  "d"
+#define PRIiLEAST8  "i"
+#define PRIdFAST8   "d"
+#define PRIiFAST8   "i"
+
+#define PRId16       "hd"
+#define PRIi16       "hi"
+#define PRIdLEAST16  "hd"
+#define PRIiLEAST16  "hi"
+#define PRIdFAST16   "hd"
+#define PRIiFAST16   "hi"
+
+#define PRId32       "I32d"
+#define PRIi32       "I32i"
+#define PRIdLEAST32  "I32d"
+#define PRIiLEAST32  "I32i"
+#define PRIdFAST32   "I32d"
+#define PRIiFAST32   "I32i"
+
+#define PRId64       "I64d"
+#define PRIi64       "I64i"
+#define PRIdLEAST64  "I64d"
+#define PRIiLEAST64  "I64i"
+#define PRIdFAST64   "I64d"
+#define PRIiFAST64   "I64i"
+
+#define PRIdMAX     "I64d"
+#define PRIiMAX     "I64i"
+
+#define PRIdPTR     "Id"
+#define PRIiPTR     "Ii"
+
+// The fprintf macros for unsigned integers are:
+#define PRIo8       "o"
+#define PRIu8       "u"
+#define PRIx8       "x"
+#define PRIX8       "X"
+#define PRIoLEAST8  "o"
+#define PRIuLEAST8  "u"
+#define PRIxLEAST8  "x"
+#define PRIXLEAST8  "X"
+#define PRIoFAST8   "o"
+#define PRIuFAST8   "u"
+#define PRIxFAST8   "x"
+#define PRIXFAST8   "X"
+
+#define PRIo16       "ho"
+#define PRIu16       "hu"
+#define PRIx16       "hx"
+#define PRIX16       "hX"
+#define PRIoLEAST16  "ho"
+#define PRIuLEAST16  "hu"
+#define PRIxLEAST16  "hx"
+#define PRIXLEAST16  "hX"
+#define PRIoFAST16   "ho"
+#define PRIuFAST16   "hu"
+#define PRIxFAST16   "hx"
+#define PRIXFAST16   "hX"
+
+#define PRIo32       "I32o"
+#define PRIu32       "I32u"
+#define PRIx32       "I32x"
+#define PRIX32       "I32X"
+#define PRIoLEAST32  "I32o"
+#define PRIuLEAST32  "I32u"
+#define PRIxLEAST32  "I32x"
+#define PRIXLEAST32  "I32X"
+#define PRIoFAST32   "I32o"
+#define PRIuFAST32   "I32u"
+#define PRIxFAST32   "I32x"
+#define PRIXFAST32   "I32X"
+
+#define PRIo64       "I64o"
+#define PRIu64       "I64u"
+#define PRIx64       "I64x"
+#define PRIX64       "I64X"
+#define PRIoLEAST64  "I64o"
+#define PRIuLEAST64  "I64u"
+#define PRIxLEAST64  "I64x"
+#define PRIXLEAST64  "I64X"
+#define PRIoFAST64   "I64o"
+#define PRIuFAST64   "I64u"
+#define PRIxFAST64   "I64x"
+#define PRIXFAST64   "I64X"
+
+#define PRIoMAX     "I64o"
+#define PRIuMAX     "I64u"
+#define PRIxMAX     "I64x"
+#define PRIXMAX     "I64X"
+
+#define PRIoPTR     "Io"
+#define PRIuPTR     "Iu"
+#define PRIxPTR     "Ix"
+#define PRIXPTR     "IX"
+
+// The fscanf macros for signed integers are:
+#define SCNd8       "d"
+#define SCNi8       "i"
+#define SCNdLEAST8  "d"
+#define SCNiLEAST8  "i"
+#define SCNdFAST8   "d"
+#define SCNiFAST8   "i"
+
+#define SCNd16       "hd"
+#define SCNi16       "hi"
+#define SCNdLEAST16  "hd"
+#define SCNiLEAST16  "hi"
+#define SCNdFAST16   "hd"
+#define SCNiFAST16   "hi"
+
+#define SCNd32       "ld"
+#define SCNi32       "li"
+#define SCNdLEAST32  "ld"
+#define SCNiLEAST32  "li"
+#define SCNdFAST32   "ld"
+#define SCNiFAST32   "li"
+
+#define SCNd64       "I64d"
+#define SCNi64       "I64i"
+#define SCNdLEAST64  "I64d"
+#define SCNiLEAST64  "I64i"
+#define SCNdFAST64   "I64d"
+#define SCNiFAST64   "I64i"
+
+#define SCNdMAX     "I64d"
+#define SCNiMAX     "I64i"
+
+#ifdef _WIN64 // [
+#  define SCNdPTR     "I64d"
+#  define SCNiPTR     "I64i"
+#else  // _WIN64 ][
+#  define SCNdPTR     "ld"
+#  define SCNiPTR     "li"
+#endif  // _WIN64 ]
+
+// The fscanf macros for unsigned integers are:
+#define SCNo8       "o"
+#define SCNu8       "u"
+#define SCNx8       "x"
+#define SCNX8       "X"
+#define SCNoLEAST8  "o"
+#define SCNuLEAST8  "u"
+#define SCNxLEAST8  "x"
+#define SCNXLEAST8  "X"
+#define SCNoFAST8   "o"
+#define SCNuFAST8   "u"
+#define SCNxFAST8   "x"
+#define SCNXFAST8   "X"
+
+#define SCNo16       "ho"
+#define SCNu16       "hu"
+#define SCNx16       "hx"
+#define SCNX16       "hX"
+#define SCNoLEAST16  "ho"
+#define SCNuLEAST16  "hu"
+#define SCNxLEAST16  "hx"
+#define SCNXLEAST16  "hX"
+#define SCNoFAST16   "ho"
+#define SCNuFAST16   "hu"
+#define SCNxFAST16   "hx"
+#define SCNXFAST16   "hX"
+
+#define SCNo32       "lo"
+#define SCNu32       "lu"
+#define SCNx32       "lx"
+#define SCNX32       "lX"
+#define SCNoLEAST32  "lo"
+#define SCNuLEAST32  "lu"
+#define SCNxLEAST32  "lx"
+#define SCNXLEAST32  "lX"
+#define SCNoFAST32   "lo"
+#define SCNuFAST32   "lu"
+#define SCNxFAST32   "lx"
+#define SCNXFAST32   "lX"
+
+#define SCNo64       "I64o"
+#define SCNu64       "I64u"
+#define SCNx64       "I64x"
+#define SCNX64       "I64X"
+#define SCNoLEAST64  "I64o"
+#define SCNuLEAST64  "I64u"
+#define SCNxLEAST64  "I64x"
+#define SCNXLEAST64  "I64X"
+#define SCNoFAST64   "I64o"
+#define SCNuFAST64   "I64u"
+#define SCNxFAST64   "I64x"
+#define SCNXFAST64   "I64X"
+
+#define SCNoMAX     "I64o"
+#define SCNuMAX     "I64u"
+#define SCNxMAX     "I64x"
+#define SCNXMAX     "I64X"
+
+#ifdef _WIN64 // [
+#  define SCNoPTR     "I64o"
+#  define SCNuPTR     "I64u"
+#  define SCNxPTR     "I64x"
+#  define SCNXPTR     "I64X"
+#else  // _WIN64 ][
+#  define SCNoPTR     "lo"
+#  define SCNuPTR     "lu"
+#  define SCNxPTR     "lx"
+#  define SCNXPTR     "lX"
+#endif  // _WIN64 ]
+
+#endif // __STDC_FORMAT_MACROS ]
+
+// 7.8.2 Functions for greatest-width integer types
+
+// 7.8.2.1 The imaxabs function
+#define imaxabs _abs64
+
+// 7.8.2.2 The imaxdiv function
+
+// This is modified version of div() function from Microsoft's div.c found
+// in %MSVC.NET%\crt\src\div.c
+#ifdef STATIC_IMAXDIV // [
+static
+#else // STATIC_IMAXDIV ][
+_inline
+#endif // STATIC_IMAXDIV ]
+imaxdiv_t __cdecl imaxdiv(intmax_t numer, intmax_t denom)
+{
+   imaxdiv_t result;
+
+   result.quot = numer / denom;
+   result.rem = numer % denom;
+
+   if (numer < 0 && result.rem > 0) {
+      // did division wrong; must fix up
+      ++result.quot;
+      result.rem -= denom;
+   }
+
+   return result;
+}
+
+// 7.8.2.3 The strtoimax and strtoumax functions
+#define strtoimax _strtoi64
+#define strtoumax _strtoui64
+
+// 7.8.2.4 The wcstoimax and wcstoumax functions
+#define wcstoimax _wcstoi64
+#define wcstoumax _wcstoui64
+
+
+#endif // _MSC_INTTYPES_H_ ]
diff --git a/include/compat/stdint.h b/include/compat/stdint.h
new file mode 100644
index 0000000..59d0673
--- /dev/null
+++ b/include/compat/stdint.h
@@ -0,0 +1,247 @@
+// ISO C9x  compliant stdint.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
+// 
+//  Copyright (c) 2006-2008 Alexander Chemeris
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+// 
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+// 
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_STDINT_H_ // [
+#define _MSC_STDINT_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <limits.h>
+
+// For Visual Studio 6 in C++ mode and for many Visual Studio versions when
+// compiling for ARM we should wrap <wchar.h> include with 'extern "C++" {}'
+// or compiler give many errors like this:
+//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed
+#ifdef __cplusplus
+extern "C" {
+#endif
+#  include <wchar.h>
+#ifdef __cplusplus
+}
+#endif
+
+// Define _W64 macros to mark types changing their size, like intptr_t.
+#ifndef _W64
+#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
+#     define _W64 __w64
+#  else
+#     define _W64
+#  endif
+#endif
+
+
+// 7.18.1 Integer types
+
+// 7.18.1.1 Exact-width integer types
+
+// Visual Studio 6 and Embedded Visual C++ 4 doesn't
+// realize that, e.g. char has the same size as __int8
+// so we give up on __intX for them.
+#if (_MSC_VER < 1300)
+   typedef signed char       int8_t;
+   typedef signed short      int16_t;
+   typedef signed int        int32_t;
+   typedef unsigned char     uint8_t;
+   typedef unsigned short    uint16_t;
+   typedef unsigned int      uint32_t;
+#else
+   typedef signed __int8     int8_t;
+   typedef signed __int16    int16_t;
+   typedef signed __int32    int32_t;
+   typedef unsigned __int8   uint8_t;
+   typedef unsigned __int16  uint16_t;
+   typedef unsigned __int32  uint32_t;
+#endif
+typedef signed __int64       int64_t;
+typedef unsigned __int64     uint64_t;
+
+
+// 7.18.1.2 Minimum-width integer types
+typedef int8_t    int_least8_t;
+typedef int16_t   int_least16_t;
+typedef int32_t   int_least32_t;
+typedef int64_t   int_least64_t;
+typedef uint8_t   uint_least8_t;
+typedef uint16_t  uint_least16_t;
+typedef uint32_t  uint_least32_t;
+typedef uint64_t  uint_least64_t;
+
+// 7.18.1.3 Fastest minimum-width integer types
+typedef int8_t    int_fast8_t;
+typedef int16_t   int_fast16_t;
+typedef int32_t   int_fast32_t;
+typedef int64_t   int_fast64_t;
+typedef uint8_t   uint_fast8_t;
+typedef uint16_t  uint_fast16_t;
+typedef uint32_t  uint_fast32_t;
+typedef uint64_t  uint_fast64_t;
+
+// 7.18.1.4 Integer types capable of holding object pointers
+#ifdef _WIN64 // [
+   typedef signed __int64    intptr_t;
+   typedef unsigned __int64  uintptr_t;
+#else // _WIN64 ][
+   typedef _W64 signed int   intptr_t;
+   typedef _W64 unsigned int uintptr_t;
+#endif // _WIN64 ]
+
+// 7.18.1.5 Greatest-width integer types
+typedef int64_t   intmax_t;
+typedef uint64_t  uintmax_t;
+
+
+// 7.18.2 Limits of specified-width integer types
+
+#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259
+
+// 7.18.2.1 Limits of exact-width integer types
+#define INT8_MIN     ((int8_t)_I8_MIN)
+#define INT8_MAX     _I8_MAX
+#define INT16_MIN    ((int16_t)_I16_MIN)
+#define INT16_MAX    _I16_MAX
+#define INT32_MIN    ((int32_t)_I32_MIN)
+#define INT32_MAX    _I32_MAX
+#define INT64_MIN    ((int64_t)_I64_MIN)
+#define INT64_MAX    _I64_MAX
+#define UINT8_MAX    _UI8_MAX
+#define UINT16_MAX   _UI16_MAX
+#define UINT32_MAX   _UI32_MAX
+#define UINT64_MAX   _UI64_MAX
+
+// 7.18.2.2 Limits of minimum-width integer types
+#define INT_LEAST8_MIN    INT8_MIN
+#define INT_LEAST8_MAX    INT8_MAX
+#define INT_LEAST16_MIN   INT16_MIN
+#define INT_LEAST16_MAX   INT16_MAX
+#define INT_LEAST32_MIN   INT32_MIN
+#define INT_LEAST32_MAX   INT32_MAX
+#define INT_LEAST64_MIN   INT64_MIN
+#define INT_LEAST64_MAX   INT64_MAX
+#define UINT_LEAST8_MAX   UINT8_MAX
+#define UINT_LEAST16_MAX  UINT16_MAX
+#define UINT_LEAST32_MAX  UINT32_MAX
+#define UINT_LEAST64_MAX  UINT64_MAX
+
+// 7.18.2.3 Limits of fastest minimum-width integer types
+#define INT_FAST8_MIN    INT8_MIN
+#define INT_FAST8_MAX    INT8_MAX
+#define INT_FAST16_MIN   INT16_MIN
+#define INT_FAST16_MAX   INT16_MAX
+#define INT_FAST32_MIN   INT32_MIN
+#define INT_FAST32_MAX   INT32_MAX
+#define INT_FAST64_MIN   INT64_MIN
+#define INT_FAST64_MAX   INT64_MAX
+#define UINT_FAST8_MAX   UINT8_MAX
+#define UINT_FAST16_MAX  UINT16_MAX
+#define UINT_FAST32_MAX  UINT32_MAX
+#define UINT_FAST64_MAX  UINT64_MAX
+
+// 7.18.2.4 Limits of integer types capable of holding object pointers
+#ifdef _WIN64 // [
+#  define INTPTR_MIN   INT64_MIN
+#  define INTPTR_MAX   INT64_MAX
+#  define UINTPTR_MAX  UINT64_MAX
+#else // _WIN64 ][
+#  define INTPTR_MIN   INT32_MIN
+#  define INTPTR_MAX   INT32_MAX
+#  define UINTPTR_MAX  UINT32_MAX
+#endif // _WIN64 ]
+
+// 7.18.2.5 Limits of greatest-width integer types
+#define INTMAX_MIN   INT64_MIN
+#define INTMAX_MAX   INT64_MAX
+#define UINTMAX_MAX  UINT64_MAX
+
+// 7.18.3 Limits of other integer types
+
+#ifdef _WIN64 // [
+#  define PTRDIFF_MIN  _I64_MIN
+#  define PTRDIFF_MAX  _I64_MAX
+#else  // _WIN64 ][
+#  define PTRDIFF_MIN  _I32_MIN
+#  define PTRDIFF_MAX  _I32_MAX
+#endif  // _WIN64 ]
+
+#define SIG_ATOMIC_MIN  INT_MIN
+#define SIG_ATOMIC_MAX  INT_MAX
+
+#ifndef SIZE_MAX // [
+#  ifdef _WIN64 // [
+#     define SIZE_MAX  _UI64_MAX
+#  else // _WIN64 ][
+#     define SIZE_MAX  _UI32_MAX
+#  endif // _WIN64 ]
+#endif // SIZE_MAX ]
+
+// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>
+#ifndef WCHAR_MIN // [
+#  define WCHAR_MIN  0
+#endif  // WCHAR_MIN ]
+#ifndef WCHAR_MAX // [
+#  define WCHAR_MAX  _UI16_MAX
+#endif  // WCHAR_MAX ]
+
+#define WINT_MIN  0
+#define WINT_MAX  _UI16_MAX
+
+#endif // __STDC_LIMIT_MACROS ]
+
+
+// 7.18.4 Limits of other integer types
+
+#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260
+
+// 7.18.4.1 Macros for minimum-width integer constants
+
+#define INT8_C(val)  val##i8
+#define INT16_C(val) val##i16
+#define INT32_C(val) val##i32
+#define INT64_C(val) val##i64
+
+#define UINT8_C(val)  val##ui8
+#define UINT16_C(val) val##ui16
+#define UINT32_C(val) val##ui32
+#define UINT64_C(val) val##ui64
+
+// 7.18.4.2 Macros for greatest-width integer constants
+#define INTMAX_C   INT64_C
+#define UINTMAX_C  UINT64_C
+
+#endif // __STDC_CONSTANT_MACROS ]
+
+
+#endif // _MSC_STDINT_H_ ]
-- 
1.7.10



From mh+jemalloc at glandium.org  Mon Apr 30 03:44:48 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:44:48 +0200
Subject: [PATCH 7/7] Add support for MSVC
In-Reply-To: <1335782311-8040-7-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
	<1335782311-8040-7-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <20120430104448.GA8246@glandium.org>

On Mon, Apr 30, 2012 at 12:38:31PM +0200, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> Tested with MSVC 8 32 and 64 bits.

BTW, MSVC gives some interesting warnings, some of which might be worth
investigating (especially the C4146 ones).

I'm attaching a log for each of 32 and 64 bits builds.

Cheers,

Mike
-------------- next part --------------
util.c
../src/util.c(175) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
jemalloc.c
c:\MinGW\msys\1.0\home\mh\jemalloc\foo\include\jemalloc/internal/jemalloc_internal.h(614) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
c:\MinGW\msys\1.0\home\mh\jemalloc\foo\include\jemalloc/internal/jemalloc_internal.h(750) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
../src/jemalloc.c(539) : warning C4244: '=' : conversion from 'uintmax_t' to 'size_t', possible loss of data
../src/jemalloc.c(541) : warning C4244: '=' : conversion from 'uintmax_t' to 'size_t', possible loss of data
../src/jemalloc.c(548) : warning C4244: '=' : conversion from 'uintmax_t' to 'size_t', possible loss of data
arena.c
../src/arena.c(1438) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
atomic.c
c:\MinGW\msys\1.0\home\mh\jemalloc\include\jemalloc/internal/atomic.h(170) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
base.c
bitmap.c
chunk.c
../src/chunk.c(58) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
chunk_dss.c
../src/chunk_dss.c(75) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
chunk_mmap.c
../src/chunk_mmap.c(146) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
ckh.c
../src/ckh.c(544) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/ckh.c(545) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/ckh.c(547) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/ckh.c(549) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/ckh.c(592) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/ckh.c(593) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/ckh.c(596) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/ckh.c(597) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
ctl.c
extent.c
hash.c
huge.c
mb.c
mutex.c
prof.c
../src/prof.c(804) : warning C4013: 'getpid' undefined; assuming extern returning int
../src/prof.c(1064) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/prof.c(1065) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/prof.c(1067) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
../src/prof.c(1069) : warning C4244: '=' : conversion from 'uint64_t' to 'size_t', possible loss of data
quarantine.c
rtree.c
stats.c
../src/stats.c(347) : warning C4090: 'function' : different 'const' qualifiers
../src/stats.c(394) : warning C4090: 'function' : different 'const' qualifiers
tcache.c
tsd.c
LINK : lib/jemalloc.dll not found or not built by the last incremental link; performing full link
   Creating library lib/jemalloc.lib and object lib/jemalloc.exp
aligned_alloc.c
LINK : test/aligned_alloc.exe not found or not built by the last incremental link; performing full link
   Creating library test/aligned_alloc.lib and object test/aligned_alloc.exp
allocated.c
LINK : test/allocated.exe not found or not built by the last incremental link; performing full link
   Creating library test/allocated.lib and object test/allocated.exp
bitmap.c
../test/bitmap.c(109) : warning C4018: '<' : signed/unsigned mismatch
../test/bitmap.c(128) : warning C4018: '<' : signed/unsigned mismatch
LINK : test/bitmap.exe not found or not built by the last incremental link; performing full link
   Creating library test/bitmap.lib and object test/bitmap.exp
mremap.c
LINK : test/mremap.exe not found or not built by the last incremental link; performing full link
   Creating library test/mremap.lib and object test/mremap.exp
posix_memalign.c
LINK : test/posix_memalign.exe not found or not built by the last incremental link; performing full link
   Creating library test/posix_memalign.lib and object test/posix_memalign.exp
thread_arena.c
LINK : test/thread_arena.exe not found or not built by the last incremental link; performing full link
   Creating library test/thread_arena.lib and object test/thread_arena.exp
thread_tcache_enabled.c
LINK : test/thread_tcache_enabled.exe not found or not built by the last incremental link; performing full link
   Creating library test/thread_tcache_enabled.lib and object test/thread_tcache_enabled.exp
allocm.c
LINK : test/allocm.exe not found or not built by the last incremental link; performing full link
   Creating library test/allocm.lib and object test/allocm.exp
rallocm.c
LINK : test/rallocm.exe not found or not built by the last incremental link; performing full link
   Creating library test/rallocm.lib and object test/rallocm.exp
=========================================
test/aligned_alloc ... pass
test/allocated ... pass
test/bitmap ... pass
test/mremap ... pass
test/posix_memalign ... pass
test/thread_arena ... pass
test/thread_tcache_enabled ... pass
test/allocm ... pass
test/rallocm ... pass
=========================================
Failures: 0/9
-------------- next part --------------
util.c
../src/util.c(55) : warning C4267: 'function' : conversion from 'size_t' to 'unsigned int', possible loss of data
../src/util.c(71) : warning C4267: 'function' : conversion from 'size_t' to 'DWORD', possible loss of data
../src/util.c(175) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
../src/util.c(562) : warning C4267: '=' : conversion from 'size_t' to 'int', possible loss of data
jemalloc.c
include\jemalloc/internal/jemalloc_internal.h(614) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
include\jemalloc/internal/jemalloc_internal.h(750) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
../src/jemalloc.c(758) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
../src/jemalloc.c(765) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
arena.c
../include\jemalloc/internal/arena.h(475) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../include\jemalloc/internal/arena.h(515) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
../src/arena.c(141) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
../src/arena.c(1438) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
../src/arena.c(2023) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../src/arena.c(2051) : warning C4267: '=' : conversion from 'size_t' to 'uint32_t', possible loss of data
../src/arena.c(2063) : warning C4267: '+=' : conversion from 'size_t' to 'uint32_t', possible loss of data
../src/arena.c(2073) : warning C4267: '=' : conversion from 'size_t' to 'uint32_t', possible loss of data
../src/arena.c(2092) : warning C4267: '=' : conversion from 'size_t' to 'uint32_t', possible loss of data
../src/arena.c(2104) : warning C4267: '+=' : conversion from 'size_t' to 'uint32_t', possible loss of data
../src/arena.c(2116) : warning C4267: '=' : conversion from 'size_t' to 'uint32_t', possible loss of data
../src/arena.c(2132) : warning C4267: '=' : conversion from 'size_t' to 'uint32_t', possible loss of data
atomic.c
../include\jemalloc/internal/atomic.h(60) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
../include\jemalloc/internal/atomic.h(170) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
base.c
bitmap.c
../include\jemalloc/internal/bitmap.h(70) : warning C4267: 'initializing' : conversion from 'size_t' to 'unsigned int', possible loss of data
chunk.c
../src/chunk.c(58) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
../src/chunk.c(298) : warning C4267: 'function' : conversion from 'size_t' to 'unsigned int', possible loss of data
chunk_dss.c
../src/chunk_dss.c(75) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
chunk_mmap.c
../src/chunk_mmap.c(146) : warning C4146: unary minus operator applied to unsigned type, result still unsigned
ckh.c
../src/ckh.c(281) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
../src/ckh.c(327) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
ctl.c
../src/ctl.c(649) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../src/ctl.c(790) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../src/ctl.c(1196) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
../src/ctl.c(1214) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
extent.c
hash.c
huge.c
mb.c
mutex.c
prof.c
../src/prof.c(586) : warning C4267: '=' : conversion from 'size_t' to 'unsigned int', possible loss of data
../src/prof.c(804) : warning C4013: 'getpid' undefined; assuming extern returning int
../src/prof.c(814) : warning C4244: '+=' : conversion from 'ssize_t' to 'unsigned int', possible loss of data
quarantine.c
rtree.c
../src/rtree.c(10) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
stats.c
../src/stats.c(347) : warning C4090: 'function' : different 'const' qualifiers
../src/stats.c(394) : warning C4090: 'function' : different 'const' qualifiers
tcache.c
../src/tcache.c(402) : warning C4334: '<<' : result of 32-bit shift implicitly converted to 64 bits (was 64-bit shift intended?)
../src/tcache.c(405) : warning C4334: '<<' : result of 32-bit shift implicitly converted to 64 bits (was 64-bit shift intended?)
tsd.c
LINK : lib/jemalloc.dll not found or not built by the last incremental link; performing full link
   Creating library lib/jemalloc.lib and object lib/jemalloc.exp
aligned_alloc.c
LINK : test/aligned_alloc.exe not found or not built by the last incremental link; performing full link
   Creating library test/aligned_alloc.lib and object test/aligned_alloc.exp
allocated.c
LINK : test/allocated.exe not found or not built by the last incremental link; performing full link
   Creating library test/allocated.lib and object test/allocated.exp
bitmap.c
../test/bitmap.c(109) : warning C4018: '<' : signed/unsigned mismatch
../test/bitmap.c(128) : warning C4018: '<' : signed/unsigned mismatch
LINK : test/bitmap.exe not found or not built by the last incremental link; performing full link
   Creating library test/bitmap.lib and object test/bitmap.exp
mremap.c
LINK : test/mremap.exe not found or not built by the last incremental link; performing full link
   Creating library test/mremap.lib and object test/mremap.exp
posix_memalign.c
LINK : test/posix_memalign.exe not found or not built by the last incremental link; performing full link
   Creating library test/posix_memalign.lib and object test/posix_memalign.exp
thread_arena.c
LINK : test/thread_arena.exe not found or not built by the last incremental link; performing full link
   Creating library test/thread_arena.lib and object test/thread_arena.exp
thread_tcache_enabled.c
LINK : test/thread_tcache_enabled.exe not found or not built by the last incremental link; performing full link
   Creating library test/thread_tcache_enabled.lib and object test/thread_tcache_enabled.exp
allocm.c
../test/allocm.c(73) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(73) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(77) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(77) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(80) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(80) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(84) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(84) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(97) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(97) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(101) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(101) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(105) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(105) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(115) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(115) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(119) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(119) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(122) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(122) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(126) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(126) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(145) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(145) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(155) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
../test/allocm.c(155) : warning C4267: 'function' : conversion from 'size_t' to 'int', possible loss of data
LINK : test/allocm.exe not found or not built by the last incremental link; performing full link
   Creating library test/allocm.lib and object test/allocm.exp
rallocm.c
LINK : test/rallocm.exe not found or not built by the last incremental link; performing full link
   Creating library test/rallocm.lib and object test/rallocm.exp
=========================================
test/aligned_alloc ... pass
test/allocated ... pass
test/bitmap ... pass
test/mremap ... pass
test/posix_memalign ... pass
test/thread_arena ... pass
test/thread_tcache_enabled ... pass
test/allocm ... pass
test/rallocm ... pass
=========================================
Failures: 0/9

From mh+jemalloc at glandium.org  Mon Apr 30 03:49:07 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 12:49:07 +0200
Subject: [PATCH 7/7] Add support for MSVC
In-Reply-To: <20120430104448.GA8246@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
	<1335782311-8040-7-git-send-email-mh+jemalloc@glandium.org>
	<20120430104448.GA8246@glandium.org>
Message-ID: <20120430104907.GA8419@glandium.org>

On Mon, Apr 30, 2012 at 12:44:48PM +0200, Mike Hommey wrote:
> On Mon, Apr 30, 2012 at 12:38:31PM +0200, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > Tested with MSVC 8 32 and 64 bits.
> 
> BTW, MSVC gives some interesting warnings, some of which might be worth
> investigating (especially the C4146 ones).
> 
> I'm attaching a log for each of 32 and 64 bits builds.

Erf, I overlooked these logs, some of the warning comes from patch 7/7.
Please squash the following when applying:

diff --git a/include/jemalloc/internal/atomic.h b/include/jemalloc/internal/atomic.h
index 4b6f623..286b457 100644
--- a/include/jemalloc/internal/atomic.h
+++ b/include/jemalloc/internal/atomic.h
@@ -57,7 +57,7 @@ atomic_add_uint64(uint64_t *p, uint64_t x)
 JEMALLOC_INLINE uint64_t
 atomic_sub_uint64(uint64_t *p, uint64_t x)
 {
-       return InterlockedExchangeAdd64(p, -x);
+       return InterlockedExchangeAdd64(p, -((int64_t)x));
 }
 #elif (defined(JEMALLOC_OSATOMIC))
 JEMALLOC_INLINE uint64_t
@@ -167,7 +167,7 @@ atomic_add_uint32(uint32_t *p, uint32_t x)
 JEMALLOC_INLINE uint32_t
 atomic_sub_uint32(uint32_t *p, uint32_t x)
 {
-       return InterlockedExchangeAdd(p, -x);
+       return InterlockedExchangeAdd(p, -((int32_t)x));
 }
 #elif (defined(JEMALLOC_OSATOMIC))
 JEMALLOC_INLINE uint32_t

Mike


From mh+jemalloc at glandium.org  Mon Apr 30 06:15:15 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Mon, 30 Apr 2012 15:15:15 +0200
Subject: Check for VALGRIND_RESIZEINPLACE_BLOCK support
Message-ID: <1335791715-16039-1-git-send-email-mh+jemalloc@glandium.org>

From: Mike Hommey <mh at glandium.org>

VALGRIND_RESIZEINPLACE_BLOCK was added in valgrind 3.7. Unfortunately, the
__VALGRIND_MINOR__ macro still says 6 in 3.7 :(
---
 configure.ac |    5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/configure.ac b/configure.ac
index 500e21c..fe45a98 100644
--- a/configure.ac
+++ b/configure.ac
@@ -841,10 +841,7 @@ if test "x$enable_valgrind" = "x1" ; then
 #include <valgrind/valgrind.h>
 #include <valgrind/memcheck.h>
 
-#if defined(__VALGRIND_MAJOR__) && defined(__VALGRIND_MINOR__)		\
-    && (__VALGRIND_MAJOR__ > 3 || (__VALGRIND_MAJOR__ == 3 &&		\
-    __VALGRIND_MINOR__ >= 6))
-#else
+#if !defined(VALGRIND_RESIZEINPLACE_BLOCK)
 #  error "Incompatible Valgrind version"
 #endif
 ], [], [je_cv_valgrind])
-- 
1.7.10



From jasone at canonware.com  Mon Apr 30 18:17:32 2012
From: jasone at canonware.com (Jason Evans)
Date: Mon, 30 Apr 2012 18:17:32 -0700
Subject: [PATCH 4/7] Use "hardcoded" dependencies instead of having the
	compiler generate them
In-Reply-To: <1335782311-8040-4-git-send-email-mh+jemalloc@glandium.org>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
	<1335782311-8040-4-git-send-email-mh+jemalloc@glandium.org>
Message-ID: <6CDFD803-1938-47C4-BC62-64AEC272FF3F@canonware.com>

On Apr 30, 2012, at 3:38 AM, Mike Hommey wrote:
> From: Mike Hommey <mh at glandium.org>
> 
> The main reason is that MSVC doesn't have flags to generate these
> dependencies. It is possible to generate them with the output from the
> showincludes flag, but it also requires to wrap the compiler, and filter
> its output on a message that changes depending on the system locale.
> 
> Considering all c files include jemalloc_internal.h, and that this file
> includes all others headers, it's just simpler to set dependencies in
> stone. The generated dependencies were all the same anyways.

I don't want to throw away the automatic dependency generation because it's, well, automatic.  Can't the hard-coding be limited to MSVC somehow?

Thanks,
Jason

From justin.lebar at gmail.com  Mon Apr 30 18:21:16 2012
From: justin.lebar at gmail.com (Justin Lebar)
Date: Mon, 30 Apr 2012 21:21:16 -0400
Subject: [PATCH 4/7] Use "hardcoded" dependencies instead of having the
	compiler generate them
In-Reply-To: <6CDFD803-1938-47C4-BC62-64AEC272FF3F@canonware.com>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
	<1335782311-8040-4-git-send-email-mh+jemalloc@glandium.org>
	<6CDFD803-1938-47C4-BC62-64AEC272FF3F@canonware.com>
Message-ID: <CAFWcpZ7Ge6dBODviwW_h23p0jcPPE85M-Atyd3G=DXiSg=Z1Zw@mail.gmail.com>

> I don't want to throw away the automatic dependency generation because it's, well, automatic. ?Can't the hard-coding be limited to MSVC somehow?

If we did that, then if the dependencies were ever changed, only those
building on Windows would notice.

Could we have, as part of configure, an assertion that the
dependencies are as we expect?

-Justin


From mh+jemalloc at glandium.org  Mon Apr 30 22:29:43 2012
From: mh+jemalloc at glandium.org (Mike Hommey)
Date: Tue, 1 May 2012 07:29:43 +0200
Subject: [PATCH 4/7] Use "hardcoded" dependencies instead of having the
	compiler generate them
In-Reply-To: <6CDFD803-1938-47C4-BC62-64AEC272FF3F@canonware.com>
References: <1335782311-8040-1-git-send-email-mh+jemalloc@glandium.org>
	<1335782311-8040-4-git-send-email-mh+jemalloc@glandium.org>
	<6CDFD803-1938-47C4-BC62-64AEC272FF3F@canonware.com>
Message-ID: <20120501052943.GA659@glandium.org>

On Mon, Apr 30, 2012 at 06:17:32PM -0700, Jason Evans wrote:
> On Apr 30, 2012, at 3:38 AM, Mike Hommey wrote:
> > From: Mike Hommey <mh at glandium.org>
> > 
> > The main reason is that MSVC doesn't have flags to generate these
> > dependencies. It is possible to generate them with the output from
> > the showincludes flag, but it also requires to wrap the compiler,
> > and filter its output on a message that changes depending on the
> > system locale.
> > 
> > Considering all c files include jemalloc_internal.h, and that this
> > file includes all others headers, it's just simpler to set
> > dependencies in stone. The generated dependencies were all the same
> > anyways.
> 
> I don't want to throw away the automatic dependency generation because
> it's, well, automatic.  Can't the hard-coding be limited to MSVC
> somehow?

Do you have any plans of not including all headers from
jemalloc_internal.h? If not, then what's the point in automatic
dependency generation when you know the result already, and it's the
same for all files?

Mike


